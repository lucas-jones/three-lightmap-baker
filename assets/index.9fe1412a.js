const uv=function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function e(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerpolicy&&(s.referrerPolicy=i.referrerpolicy),i.crossorigin==="use-credentials"?s.credentials="include":i.crossorigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(i){if(i.ep)return;i.ep=!0;const s=e(i);fetch(i.href,s)}};uv();/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Od="129",Ji={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Qi={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},hv=0,Wu=1,dv=2,Vd=1,pv=2,br=3,Ri=0,ye=1,on=2,zd=1,Er=0,Sr=1,ju=2,Xu=3,qu=4,fv=5,bs=100,mv=101,gv=102,Yu=103,Zu=104,vv=200,_v=201,xv=202,yv=203,Ud=204,Hd=205,bv=206,wv=207,Mv=208,Ev=209,Sv=210,Tv=0,Av=1,Cv=2,Bl=3,Pv=4,Lv=5,Rv=6,Iv=7,ha=0,Dv=1,Nv=2,Tr=0,Fv=1,kv=2,Bv=3,Ov=4,Vv=5,Gd=300,oc=301,ac=302,Ku=303,$u=304,lc=306,cc=307,Ls=1e3,Ve=1001,ia=1002,oe=1003,Ol=1004,Vl=1005,Re=1006,Wd=1007,Bs=1008,zv=1008,Dr=1009,zl=1010,jd=1011,Nr=1012,Qo=1013,On=1014,Ne=1015,sa=1016,Uv=1017,Hv=1018,Gv=1019,Ar=1020,Wv=1021,li=1022,Fe=1023,jv=1024,Xv=1025,Cs=1026,Fr=1027,Xd=1028,qd=1029,Yd=1030,uc=1031,qv=1032,ra=1033,Ju=33776,Qu=33777,th=33778,eh=33779,nh=35840,ih=35841,sh=35842,rh=35843,Yv=36196,oh=37492,ah=37496,Zv=37808,Kv=37809,$v=37810,Jv=37811,Qv=37812,t_=37813,e_=37814,n_=37815,i_=37816,s_=37817,r_=37818,o_=37819,a_=37820,l_=37821,c_=36492,u_=37840,h_=37841,d_=37842,p_=37843,f_=37844,m_=37845,g_=37846,v_=37847,__=37848,x_=37849,y_=37850,b_=37851,w_=37852,M_=37853,E_=2200,S_=2201,T_=2202,kr=2300,Rs=2301,qa=2302,Es=2400,Ss=2401,oa=2402,hc=2500,Zd=2501,Kd=0,$d=1,aa=2,Yr=3e3,Br=3001,A_=3007,C_=3002,P_=3003,L_=3004,R_=3005,I_=3006,D_=3200,N_=3201,Di=0,F_=1,Ya=7680,k_=519,Or=35044,la=35048,lh="300 es";class fi{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const s=i.indexOf(e);s!==-1&&i.splice(s,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const i=n.slice(0);for(let s=0,a=i.length;s<a;s++)i[s].call(this,t);t.target=null}}}const Te=[];for(let r=0;r<256;r++)Te[r]=(r<16?"0":"")+r.toString(16);let lo=1234567;const Cr=Math.PI/180,Vr=180/Math.PI;function Ye(){const r=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Te[r&255]+Te[r>>8&255]+Te[r>>16&255]+Te[r>>24&255]+"-"+Te[t&255]+Te[t>>8&255]+"-"+Te[t>>16&15|64]+Te[t>>24&255]+"-"+Te[e&63|128]+Te[e>>8&255]+"-"+Te[e>>16&255]+Te[e>>24&255]+Te[n&255]+Te[n>>8&255]+Te[n>>16&255]+Te[n>>24&255]).toUpperCase()}function Le(r,t,e){return Math.max(t,Math.min(e,r))}function dc(r,t){return(r%t+t)%t}function B_(r,t,e,n,i){return n+(r-t)*(i-n)/(e-t)}function O_(r,t,e){return r!==t?(e-r)/(t-r):0}function Pr(r,t,e){return(1-e)*r+e*t}function V_(r,t,e,n){return Pr(r,t,1-Math.exp(-e*n))}function z_(r,t=1){return t-Math.abs(dc(r,t*2)-t)}function U_(r,t,e){return r<=t?0:r>=e?1:(r=(r-t)/(e-t),r*r*(3-2*r))}function H_(r,t,e){return r<=t?0:r>=e?1:(r=(r-t)/(e-t),r*r*r*(r*(r*6-15)+10))}function G_(r,t){return r+Math.floor(Math.random()*(t-r+1))}function W_(r,t){return r+Math.random()*(t-r)}function j_(r){return r*(.5-Math.random())}function X_(r){return r!==void 0&&(lo=r%2147483647),lo=lo*16807%2147483647,(lo-1)/2147483646}function q_(r){return r*Cr}function Y_(r){return r*Vr}function Ul(r){return(r&r-1)===0&&r!==0}function Jd(r){return Math.pow(2,Math.ceil(Math.log(r)/Math.LN2))}function Qd(r){return Math.pow(2,Math.floor(Math.log(r)/Math.LN2))}function Z_(r,t,e,n,i){const s=Math.cos,a=Math.sin,l=s(e/2),u=a(e/2),h=s((t+n)/2),p=a((t+n)/2),f=s((t-n)/2),m=a((t-n)/2),v=s((n-t)/2),x=a((n-t)/2);switch(i){case"XYX":r.set(l*p,u*f,u*m,l*h);break;case"YZY":r.set(u*m,l*p,u*f,l*h);break;case"ZXZ":r.set(u*f,u*m,l*p,l*h);break;case"XZX":r.set(l*p,u*x,u*v,l*h);break;case"YXY":r.set(u*v,l*p,u*x,l*h);break;case"ZYZ":r.set(u*x,u*v,l*p,l*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}var K_=Object.freeze({__proto__:null,DEG2RAD:Cr,RAD2DEG:Vr,generateUUID:Ye,clamp:Le,euclideanModulo:dc,mapLinear:B_,inverseLerp:O_,lerp:Pr,damp:V_,pingpong:z_,smoothstep:U_,smootherstep:H_,randInt:G_,randFloat:W_,randFloatSpread:j_,seededRandom:X_,degToRad:q_,radToDeg:Y_,isPowerOfTwo:Ul,ceilPowerOfTwo:Jd,floorPowerOfTwo:Qd,setQuaternionFromProperEuler:Z_});class nt{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),s=this.x-t.x,a=this.y-t.y;return this.x=s*n-a*i+t.x,this.y=s*i+a*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}nt.prototype.isVector2=!0;class Ae{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,s,a,l,u,h){const p=this.elements;return p[0]=t,p[1]=i,p[2]=l,p[3]=e,p[4]=s,p[5]=u,p[6]=n,p[7]=a,p[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,s=this.elements,a=n[0],l=n[3],u=n[6],h=n[1],p=n[4],f=n[7],m=n[2],v=n[5],x=n[8],b=i[0],w=i[3],_=i[6],y=i[1],M=i[4],T=i[7],A=i[2],E=i[5],P=i[8];return s[0]=a*b+l*y+u*A,s[3]=a*w+l*M+u*E,s[6]=a*_+l*T+u*P,s[1]=h*b+p*y+f*A,s[4]=h*w+p*M+f*E,s[7]=h*_+p*T+f*P,s[2]=m*b+v*y+x*A,s[5]=m*w+v*M+x*E,s[8]=m*_+v*T+x*P,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],l=t[5],u=t[6],h=t[7],p=t[8];return e*a*p-e*l*h-n*s*p+n*l*u+i*s*h-i*a*u}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],l=t[5],u=t[6],h=t[7],p=t[8],f=p*a-l*h,m=l*u-p*s,v=h*s-a*u,x=e*f+n*m+i*v;if(x===0)return this.set(0,0,0,0,0,0,0,0,0);const b=1/x;return t[0]=f*b,t[1]=(i*h-p*n)*b,t[2]=(l*n-i*a)*b,t[3]=m*b,t[4]=(p*e-i*u)*b,t[5]=(i*s-l*e)*b,t[6]=v*b,t[7]=(n*u-h*e)*b,t[8]=(a*e-n*s)*b,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,s,a,l){const u=Math.cos(s),h=Math.sin(s);return this.set(n*u,n*h,-n*(u*a+h*l)+a+t,-i*h,i*u,-i*(-h*a+u*l)+l+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),i=this.elements,s=i[0],a=i[3],l=i[6],u=i[1],h=i[4],p=i[7];return i[0]=e*s+n*u,i[3]=e*a+n*h,i[6]=e*l+n*p,i[1]=-n*s+e*u,i[4]=-n*a+e*h,i[7]=-n*l+e*p,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}Ae.prototype.isMatrix3=!0;let ts;class Os{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement=="undefined")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{ts===void 0&&(ts=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),ts.width=t.width,ts.height=t.height;const n=ts.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=ts}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let $_=0;class Ce extends fi{constructor(t=Ce.DEFAULT_IMAGE,e=Ce.DEFAULT_MAPPING,n=Ve,i=Ve,s=Re,a=Bs,l=Fe,u=Dr,h=1,p=Yr){super(),Object.defineProperty(this,"id",{value:$_++}),this.uuid=Ye(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=s,this.minFilter=a,this.anisotropy=h,this.format=l,this.internalFormat=null,this.type=u,this.offset=new nt(0,0),this.repeat=new nt(1,1),this.center=new nt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ae,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=p,this.version=0,this.onUpdate=null}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const i=this.image;if(i.uuid===void 0&&(i.uuid=Ye()),!e&&t.images[i.uuid]===void 0){let s;if(Array.isArray(i)){s=[];for(let a=0,l=i.length;a<l;a++)i[a].isDataTexture?s.push(Za(i[a].image)):s.push(Za(i[a]))}else s=Za(i);t.images[i.uuid]={uuid:i.uuid,url:s}}n.image=i.uuid}return e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==Gd)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case Ls:t.x=t.x-Math.floor(t.x);break;case Ve:t.x=t.x<0?0:1;break;case ia:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case Ls:t.y=t.y-Math.floor(t.y);break;case Ve:t.y=t.y<0?0:1;break;case ia:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&this.version++}}Ce.DEFAULT_IMAGE=void 0;Ce.DEFAULT_MAPPING=Gd;Ce.prototype.isTexture=!0;function Za(r){return typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&r instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap?Os.getDataURL(r):r.data?{data:Array.prototype.slice.call(r.data),width:r.width,height:r.height,type:r.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class ne{constructor(t=0,e=0,n=0,i=1){this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,s=this.w,a=t.elements;return this.x=a[0]*e+a[4]*n+a[8]*i+a[12]*s,this.y=a[1]*e+a[5]*n+a[9]*i+a[13]*s,this.z=a[2]*e+a[6]*n+a[10]*i+a[14]*s,this.w=a[3]*e+a[7]*n+a[11]*i+a[15]*s,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,s;const u=t.elements,h=u[0],p=u[4],f=u[8],m=u[1],v=u[5],x=u[9],b=u[2],w=u[6],_=u[10];if(Math.abs(p-m)<.01&&Math.abs(f-b)<.01&&Math.abs(x-w)<.01){if(Math.abs(p+m)<.1&&Math.abs(f+b)<.1&&Math.abs(x+w)<.1&&Math.abs(h+v+_-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const M=(h+1)/2,T=(v+1)/2,A=(_+1)/2,E=(p+m)/4,P=(f+b)/4,I=(x+w)/4;return M>T&&M>A?M<.01?(n=0,i=.707106781,s=.707106781):(n=Math.sqrt(M),i=E/n,s=P/n):T>A?T<.01?(n=.707106781,i=0,s=.707106781):(i=Math.sqrt(T),n=E/i,s=I/i):A<.01?(n=.707106781,i=.707106781,s=0):(s=Math.sqrt(A),n=P/s,i=I/s),this.set(n,i,s,e),this}let y=Math.sqrt((w-x)*(w-x)+(f-b)*(f-b)+(m-p)*(m-p));return Math.abs(y)<.001&&(y=1),this.x=(w-x)/y,this.y=(f-b)/y,this.z=(m-p)/y,this.w=Math.acos((h+v+_-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}ne.prototype.isVector4=!0;class rn extends fi{constructor(t,e,n){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new ne(0,0,t,e),this.scissorTest=!1,this.viewport=new ne(0,0,t,e),n=n||{},this.texture=new Ce(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=1,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:Re,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){(this.width!==t||this.height!==e||this.depth!==n)&&(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}rn.prototype.isWebGLRenderTarget=!0;class J_ extends rn{constructor(t,e,n){super(t,e);const i=this.texture;this.texture=[];for(let s=0;s<n;s++)this.texture[s]=i.clone()}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,s=this.texture.length;i<s;i++)this.texture[i].image.width=t,this.texture[i].image.height=e,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone();return this}}J_.prototype.isWebGLMultipleRenderTargets=!0;class Q_ extends rn{constructor(t,e,n){super(t,e,n),this.samples=4}copy(t){return super.copy.call(this,t),this.samples=t.samples,this}}Q_.prototype.isWebGLMultisampleRenderTarget=!0;class se{constructor(t=0,e=0,n=0,i=1){this._x=t,this._y=e,this._z=n,this._w=i}static slerp(t,e,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,i)}static slerpFlat(t,e,n,i,s,a,l){let u=n[i+0],h=n[i+1],p=n[i+2],f=n[i+3];const m=s[a+0],v=s[a+1],x=s[a+2],b=s[a+3];if(l===0){t[e+0]=u,t[e+1]=h,t[e+2]=p,t[e+3]=f;return}if(l===1){t[e+0]=m,t[e+1]=v,t[e+2]=x,t[e+3]=b;return}if(f!==b||u!==m||h!==v||p!==x){let w=1-l;const _=u*m+h*v+p*x+f*b,y=_>=0?1:-1,M=1-_*_;if(M>Number.EPSILON){const A=Math.sqrt(M),E=Math.atan2(A,_*y);w=Math.sin(w*E)/A,l=Math.sin(l*E)/A}const T=l*y;if(u=u*w+m*T,h=h*w+v*T,p=p*w+x*T,f=f*w+b*T,w===1-l){const A=1/Math.sqrt(u*u+h*h+p*p+f*f);u*=A,h*=A,p*=A,f*=A}}t[e]=u,t[e+1]=h,t[e+2]=p,t[e+3]=f}static multiplyQuaternionsFlat(t,e,n,i,s,a){const l=n[i],u=n[i+1],h=n[i+2],p=n[i+3],f=s[a],m=s[a+1],v=s[a+2],x=s[a+3];return t[e]=l*x+p*f+u*v-h*m,t[e+1]=u*x+p*m+h*f-l*v,t[e+2]=h*x+p*v+l*m-u*f,t[e+3]=p*x-l*f-u*m-h*v,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,i=t._y,s=t._z,a=t._order,l=Math.cos,u=Math.sin,h=l(n/2),p=l(i/2),f=l(s/2),m=u(n/2),v=u(i/2),x=u(s/2);switch(a){case"XYZ":this._x=m*p*f+h*v*x,this._y=h*v*f-m*p*x,this._z=h*p*x+m*v*f,this._w=h*p*f-m*v*x;break;case"YXZ":this._x=m*p*f+h*v*x,this._y=h*v*f-m*p*x,this._z=h*p*x-m*v*f,this._w=h*p*f+m*v*x;break;case"ZXY":this._x=m*p*f-h*v*x,this._y=h*v*f+m*p*x,this._z=h*p*x+m*v*f,this._w=h*p*f-m*v*x;break;case"ZYX":this._x=m*p*f-h*v*x,this._y=h*v*f+m*p*x,this._z=h*p*x-m*v*f,this._w=h*p*f+m*v*x;break;case"YZX":this._x=m*p*f+h*v*x,this._y=h*v*f+m*p*x,this._z=h*p*x-m*v*f,this._w=h*p*f-m*v*x;break;case"XZY":this._x=m*p*f-h*v*x,this._y=h*v*f-m*p*x,this._z=h*p*x+m*v*f,this._w=h*p*f+m*v*x;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],s=e[8],a=e[1],l=e[5],u=e[9],h=e[2],p=e[6],f=e[10],m=n+l+f;if(m>0){const v=.5/Math.sqrt(m+1);this._w=.25/v,this._x=(p-u)*v,this._y=(s-h)*v,this._z=(a-i)*v}else if(n>l&&n>f){const v=2*Math.sqrt(1+n-l-f);this._w=(p-u)/v,this._x=.25*v,this._y=(i+a)/v,this._z=(s+h)/v}else if(l>f){const v=2*Math.sqrt(1+l-n-f);this._w=(s-h)/v,this._x=(i+a)/v,this._y=.25*v,this._z=(u+p)/v}else{const v=2*Math.sqrt(1+f-n-l);this._w=(a-i)/v,this._x=(s+h)/v,this._y=(u+p)/v,this._z=.25*v}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Le(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,s=t._z,a=t._w,l=e._x,u=e._y,h=e._z,p=e._w;return this._x=n*p+a*l+i*h-s*u,this._y=i*p+a*u+s*l-n*h,this._z=s*p+a*h+n*u-i*l,this._w=a*p-n*l-i*u-s*h,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,i=this._y,s=this._z,a=this._w;let l=a*t._w+n*t._x+i*t._y+s*t._z;if(l<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,l=-l):this.copy(t),l>=1)return this._w=a,this._x=n,this._y=i,this._z=s,this;const u=1-l*l;if(u<=Number.EPSILON){const v=1-e;return this._w=v*a+e*this._w,this._x=v*n+e*this._x,this._y=v*i+e*this._y,this._z=v*s+e*this._z,this.normalize(),this._onChangeCallback(),this}const h=Math.sqrt(u),p=Math.atan2(h,l),f=Math.sin((1-e)*p)/h,m=Math.sin(e*p)/h;return this._w=a*f+this._w*m,this._x=n*f+this._x*m,this._y=i*f+this._y*m,this._z=s*f+this._z*m,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}se.prototype.isQuaternion=!0;class C{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(ch.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(ch.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*i,this.y=s[1]*e+s[4]*n+s[7]*i,this.z=s[2]*e+s[5]*n+s[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,s=t.elements,a=1/(s[3]*e+s[7]*n+s[11]*i+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*i+s[12])*a,this.y=(s[1]*e+s[5]*n+s[9]*i+s[13])*a,this.z=(s[2]*e+s[6]*n+s[10]*i+s[14])*a,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,s=t.x,a=t.y,l=t.z,u=t.w,h=u*e+a*i-l*n,p=u*n+l*e-s*i,f=u*i+s*n-a*e,m=-s*e-a*n-l*i;return this.x=h*u+m*-s+p*-l-f*-a,this.y=p*u+m*-a+f*-s-h*-l,this.z=f*u+m*-l+h*-a-p*-s,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i,this.y=s[1]*e+s[5]*n+s[9]*i,this.z=s[2]*e+s[6]*n+s[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,s=t.z,a=e.x,l=e.y,u=e.z;return this.x=i*u-s*l,this.y=s*a-n*u,this.z=n*l-i*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return Ka.copy(this).projectOnVector(t),this.sub(Ka)}reflect(t){return this.sub(Ka.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Le(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}C.prototype.isVector3=!0;const Ka=new C,ch=new se;class ve{constructor(t=new C(1/0,1/0,1/0),e=new C(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,s=-1/0,a=-1/0,l=-1/0;for(let u=0,h=t.length;u<h;u+=3){const p=t[u],f=t[u+1],m=t[u+2];p<e&&(e=p),f<n&&(n=f),m<i&&(i=m),p>s&&(s=p),f>a&&(a=f),m>l&&(l=m)}return this.min.set(e,n,i),this.max.set(s,a,l),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,s=-1/0,a=-1/0,l=-1/0;for(let u=0,h=t.count;u<h;u++){const p=t.getX(u),f=t.getY(u),m=t.getZ(u);p<e&&(e=p),f<n&&(n=f),m<i&&(i=m),p>s&&(s=p),f>a&&(a=f),m>l&&(l=m)}return this.min.set(e,n,i),this.max.set(s,a,l),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=sr.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return t===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),t=new C),this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return t===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),t=new C),this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;e!==void 0&&(e.boundingBox===null&&e.computeBoundingBox(),$a.copy(e.boundingBox),$a.applyMatrix4(t.matrixWorld),this.union($a));const n=t.children;for(let i=0,s=n.length;i<s;i++)this.expandByObject(n[i]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),e=new C),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,sr),sr.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(rr),co.subVectors(this.max,rr),es.subVectors(t.a,rr),ns.subVectors(t.b,rr),is.subVectors(t.c,rr),Zn.subVectors(ns,es),Kn.subVectors(is,ns),Mi.subVectors(es,is);let e=[0,-Zn.z,Zn.y,0,-Kn.z,Kn.y,0,-Mi.z,Mi.y,Zn.z,0,-Zn.x,Kn.z,0,-Kn.x,Mi.z,0,-Mi.x,-Zn.y,Zn.x,0,-Kn.y,Kn.x,0,-Mi.y,Mi.x,0];return!Ja(e,es,ns,is,co)||(e=[1,0,0,0,1,0,0,0,1],!Ja(e,es,ns,is,co))?!1:(uo.crossVectors(Zn,Kn),e=[uo.x,uo.y,uo.z],Ja(e,es,ns,is,co))}clampPoint(t,e){return e===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),e=new C),e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return sr.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return t===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(t.center),t.radius=this.getSize(sr).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Ln[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Ln[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Ln[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Ln[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Ln[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Ln[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Ln[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Ln[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Ln),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}ve.prototype.isBox3=!0;const Ln=[new C,new C,new C,new C,new C,new C,new C,new C],sr=new C,$a=new ve,es=new C,ns=new C,is=new C,Zn=new C,Kn=new C,Mi=new C,rr=new C,co=new C,uo=new C,Ei=new C;function Ja(r,t,e,n,i){for(let s=0,a=r.length-3;s<=a;s+=3){Ei.fromArray(r,s);const l=i.x*Math.abs(Ei.x)+i.y*Math.abs(Ei.y)+i.z*Math.abs(Ei.z),u=t.dot(Ei),h=e.dot(Ei),p=n.dot(Ei);if(Math.max(-Math.max(u,h,p),Math.min(u,h,p))>l)return!1}return!0}const t0=new ve,uh=new C,Qa=new C,tl=new C;class mi{constructor(t=new C,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):t0.setFromPoints(t).getCenter(n);let i=0;for(let s=0,a=t.length;s<a;s++)i=Math.max(i,n.distanceToSquared(t[s]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),e=new C),e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return t===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),t=new ve),this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){tl.subVectors(t,this.center);const e=tl.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),i=(n-this.radius)*.5;this.center.add(tl.multiplyScalar(i/n)),this.radius+=i}return this}union(t){return Qa.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(uh.copy(t.center).add(Qa)),this.expandByPoint(uh.copy(t.center).sub(Qa)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Rn=new C,el=new C,ho=new C,$n=new C,nl=new C,po=new C,il=new C;class Ni{constructor(t=new C,e=new C(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e===void 0&&(console.warn("THREE.Ray: .at() target is now required"),e=new C),e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Rn)),this}closestPointToPoint(t,e){e===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),e=new C),e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Rn.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Rn.copy(this.direction).multiplyScalar(e).add(this.origin),Rn.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){el.copy(t).add(e).multiplyScalar(.5),ho.copy(e).sub(t).normalize(),$n.copy(this.origin).sub(el);const s=t.distanceTo(e)*.5,a=-this.direction.dot(ho),l=$n.dot(this.direction),u=-$n.dot(ho),h=$n.lengthSq(),p=Math.abs(1-a*a);let f,m,v,x;if(p>0)if(f=a*u-l,m=a*l-u,x=s*p,f>=0)if(m>=-x)if(m<=x){const b=1/p;f*=b,m*=b,v=f*(f+a*m+2*l)+m*(a*f+m+2*u)+h}else m=s,f=Math.max(0,-(a*m+l)),v=-f*f+m*(m+2*u)+h;else m=-s,f=Math.max(0,-(a*m+l)),v=-f*f+m*(m+2*u)+h;else m<=-x?(f=Math.max(0,-(-a*s+l)),m=f>0?-s:Math.min(Math.max(-s,-u),s),v=-f*f+m*(m+2*u)+h):m<=x?(f=0,m=Math.min(Math.max(-s,-u),s),v=m*(m+2*u)+h):(f=Math.max(0,-(a*s+l)),m=f>0?s:Math.min(Math.max(-s,-u),s),v=-f*f+m*(m+2*u)+h);else m=a>0?-s:s,f=Math.max(0,-(a*m+l)),v=-f*f+m*(m+2*u)+h;return n&&n.copy(this.direction).multiplyScalar(f).add(this.origin),i&&i.copy(ho).multiplyScalar(m).add(el),v}intersectSphere(t,e){Rn.subVectors(t.center,this.origin);const n=Rn.dot(this.direction),i=Rn.dot(Rn)-n*n,s=t.radius*t.radius;if(i>s)return null;const a=Math.sqrt(s-i),l=n-a,u=n+a;return l<0&&u<0?null:l<0?this.at(u,e):this.at(l,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,s,a,l,u;const h=1/this.direction.x,p=1/this.direction.y,f=1/this.direction.z,m=this.origin;return h>=0?(n=(t.min.x-m.x)*h,i=(t.max.x-m.x)*h):(n=(t.max.x-m.x)*h,i=(t.min.x-m.x)*h),p>=0?(s=(t.min.y-m.y)*p,a=(t.max.y-m.y)*p):(s=(t.max.y-m.y)*p,a=(t.min.y-m.y)*p),n>a||s>i||((s>n||n!==n)&&(n=s),(a<i||i!==i)&&(i=a),f>=0?(l=(t.min.z-m.z)*f,u=(t.max.z-m.z)*f):(l=(t.max.z-m.z)*f,u=(t.min.z-m.z)*f),n>u||l>i)||((l>n||n!==n)&&(n=l),(u<i||i!==i)&&(i=u),i<0)?null:this.at(n>=0?n:i,e)}intersectsBox(t){return this.intersectBox(t,Rn)!==null}intersectTriangle(t,e,n,i,s){nl.subVectors(e,t),po.subVectors(n,t),il.crossVectors(nl,po);let a=this.direction.dot(il),l;if(a>0){if(i)return null;l=1}else if(a<0)l=-1,a=-a;else return null;$n.subVectors(this.origin,t);const u=l*this.direction.dot(po.crossVectors($n,po));if(u<0)return null;const h=l*this.direction.dot(nl.cross($n));if(h<0||u+h>a)return null;const p=-l*$n.dot(il);return p<0?null:this.at(p/a,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Et{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,s,a,l,u,h,p,f,m,v,x,b,w){const _=this.elements;return _[0]=t,_[4]=e,_[8]=n,_[12]=i,_[1]=s,_[5]=a,_[9]=l,_[13]=u,_[2]=h,_[6]=p,_[10]=f,_[14]=m,_[3]=v,_[7]=x,_[11]=b,_[15]=w,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Et().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/ss.setFromMatrixColumn(t,0).length(),s=1/ss.setFromMatrixColumn(t,1).length(),a=1/ss.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*s,e[5]=n[5]*s,e[6]=n[6]*s,e[7]=0,e[8]=n[8]*a,e[9]=n[9]*a,e[10]=n[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,i=t.y,s=t.z,a=Math.cos(n),l=Math.sin(n),u=Math.cos(i),h=Math.sin(i),p=Math.cos(s),f=Math.sin(s);if(t.order==="XYZ"){const m=a*p,v=a*f,x=l*p,b=l*f;e[0]=u*p,e[4]=-u*f,e[8]=h,e[1]=v+x*h,e[5]=m-b*h,e[9]=-l*u,e[2]=b-m*h,e[6]=x+v*h,e[10]=a*u}else if(t.order==="YXZ"){const m=u*p,v=u*f,x=h*p,b=h*f;e[0]=m+b*l,e[4]=x*l-v,e[8]=a*h,e[1]=a*f,e[5]=a*p,e[9]=-l,e[2]=v*l-x,e[6]=b+m*l,e[10]=a*u}else if(t.order==="ZXY"){const m=u*p,v=u*f,x=h*p,b=h*f;e[0]=m-b*l,e[4]=-a*f,e[8]=x+v*l,e[1]=v+x*l,e[5]=a*p,e[9]=b-m*l,e[2]=-a*h,e[6]=l,e[10]=a*u}else if(t.order==="ZYX"){const m=a*p,v=a*f,x=l*p,b=l*f;e[0]=u*p,e[4]=x*h-v,e[8]=m*h+b,e[1]=u*f,e[5]=b*h+m,e[9]=v*h-x,e[2]=-h,e[6]=l*u,e[10]=a*u}else if(t.order==="YZX"){const m=a*u,v=a*h,x=l*u,b=l*h;e[0]=u*p,e[4]=b-m*f,e[8]=x*f+v,e[1]=f,e[5]=a*p,e[9]=-l*p,e[2]=-h*p,e[6]=v*f+x,e[10]=m-b*f}else if(t.order==="XZY"){const m=a*u,v=a*h,x=l*u,b=l*h;e[0]=u*p,e[4]=-f,e[8]=h*p,e[1]=m*f+b,e[5]=a*p,e[9]=v*f-x,e[2]=x*f-v,e[6]=l*p,e[10]=b*f+m}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(e0,t,n0)}lookAt(t,e,n){const i=this.elements;return He.subVectors(t,e),He.lengthSq()===0&&(He.z=1),He.normalize(),Jn.crossVectors(n,He),Jn.lengthSq()===0&&(Math.abs(n.z)===1?He.x+=1e-4:He.z+=1e-4,He.normalize(),Jn.crossVectors(n,He)),Jn.normalize(),fo.crossVectors(He,Jn),i[0]=Jn.x,i[4]=fo.x,i[8]=He.x,i[1]=Jn.y,i[5]=fo.y,i[9]=He.y,i[2]=Jn.z,i[6]=fo.z,i[10]=He.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,s=this.elements,a=n[0],l=n[4],u=n[8],h=n[12],p=n[1],f=n[5],m=n[9],v=n[13],x=n[2],b=n[6],w=n[10],_=n[14],y=n[3],M=n[7],T=n[11],A=n[15],E=i[0],P=i[4],I=i[8],N=i[12],z=i[1],W=i[5],H=i[9],D=i[13],V=i[2],G=i[6],B=i[10],j=i[14],ot=i[3],Q=i[7],ut=i[11],rt=i[15];return s[0]=a*E+l*z+u*V+h*ot,s[4]=a*P+l*W+u*G+h*Q,s[8]=a*I+l*H+u*B+h*ut,s[12]=a*N+l*D+u*j+h*rt,s[1]=p*E+f*z+m*V+v*ot,s[5]=p*P+f*W+m*G+v*Q,s[9]=p*I+f*H+m*B+v*ut,s[13]=p*N+f*D+m*j+v*rt,s[2]=x*E+b*z+w*V+_*ot,s[6]=x*P+b*W+w*G+_*Q,s[10]=x*I+b*H+w*B+_*ut,s[14]=x*N+b*D+w*j+_*rt,s[3]=y*E+M*z+T*V+A*ot,s[7]=y*P+M*W+T*G+A*Q,s[11]=y*I+M*H+T*B+A*ut,s[15]=y*N+M*D+T*j+A*rt,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],s=t[12],a=t[1],l=t[5],u=t[9],h=t[13],p=t[2],f=t[6],m=t[10],v=t[14],x=t[3],b=t[7],w=t[11],_=t[15];return x*(+s*u*f-i*h*f-s*l*m+n*h*m+i*l*v-n*u*v)+b*(+e*u*v-e*h*m+s*a*m-i*a*v+i*h*p-s*u*p)+w*(+e*h*f-e*l*v-s*a*f+n*a*v+s*l*p-n*h*p)+_*(-i*l*p-e*u*f+e*l*m+i*a*f-n*a*m+n*u*p)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],a=t[4],l=t[5],u=t[6],h=t[7],p=t[8],f=t[9],m=t[10],v=t[11],x=t[12],b=t[13],w=t[14],_=t[15],y=f*w*h-b*m*h+b*u*v-l*w*v-f*u*_+l*m*_,M=x*m*h-p*w*h-x*u*v+a*w*v+p*u*_-a*m*_,T=p*b*h-x*f*h+x*l*v-a*b*v-p*l*_+a*f*_,A=x*f*u-p*b*u-x*l*m+a*b*m+p*l*w-a*f*w,E=e*y+n*M+i*T+s*A;if(E===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const P=1/E;return t[0]=y*P,t[1]=(b*m*s-f*w*s-b*i*v+n*w*v+f*i*_-n*m*_)*P,t[2]=(l*w*s-b*u*s+b*i*h-n*w*h-l*i*_+n*u*_)*P,t[3]=(f*u*s-l*m*s-f*i*h+n*m*h+l*i*v-n*u*v)*P,t[4]=M*P,t[5]=(p*w*s-x*m*s+x*i*v-e*w*v-p*i*_+e*m*_)*P,t[6]=(x*u*s-a*w*s-x*i*h+e*w*h+a*i*_-e*u*_)*P,t[7]=(a*m*s-p*u*s+p*i*h-e*m*h-a*i*v+e*u*v)*P,t[8]=T*P,t[9]=(x*f*s-p*b*s-x*n*v+e*b*v+p*n*_-e*f*_)*P,t[10]=(a*b*s-x*l*s+x*n*h-e*b*h-a*n*_+e*l*_)*P,t[11]=(p*l*s-a*f*s-p*n*h+e*f*h+a*n*v-e*l*v)*P,t[12]=A*P,t[13]=(p*b*i-x*f*i+x*n*m-e*b*m-p*n*w+e*f*w)*P,t[14]=(x*l*i-a*b*i-x*n*u+e*b*u+a*n*w-e*l*w)*P,t[15]=(a*f*i-p*l*i+p*n*u-e*f*u-a*n*m+e*l*m)*P,this}scale(t){const e=this.elements,n=t.x,i=t.y,s=t.z;return e[0]*=n,e[4]*=i,e[8]*=s,e[1]*=n,e[5]*=i,e[9]*=s,e[2]*=n,e[6]*=i,e[10]*=s,e[3]*=n,e[7]*=i,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),s=1-n,a=t.x,l=t.y,u=t.z,h=s*a,p=s*l;return this.set(h*a+n,h*l-i*u,h*u+i*l,0,h*l+i*u,p*l+n,p*u-i*a,0,h*u-i*l,p*u+i*a,s*u*u+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,s,a){return this.set(1,n,s,0,t,1,a,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,s=e._x,a=e._y,l=e._z,u=e._w,h=s+s,p=a+a,f=l+l,m=s*h,v=s*p,x=s*f,b=a*p,w=a*f,_=l*f,y=u*h,M=u*p,T=u*f,A=n.x,E=n.y,P=n.z;return i[0]=(1-(b+_))*A,i[1]=(v+T)*A,i[2]=(x-M)*A,i[3]=0,i[4]=(v-T)*E,i[5]=(1-(m+_))*E,i[6]=(w+y)*E,i[7]=0,i[8]=(x+M)*P,i[9]=(w-y)*P,i[10]=(1-(m+b))*P,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let s=ss.set(i[0],i[1],i[2]).length();const a=ss.set(i[4],i[5],i[6]).length(),l=ss.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),t.x=i[12],t.y=i[13],t.z=i[14],Je.copy(this);const h=1/s,p=1/a,f=1/l;return Je.elements[0]*=h,Je.elements[1]*=h,Je.elements[2]*=h,Je.elements[4]*=p,Je.elements[5]*=p,Je.elements[6]*=p,Je.elements[8]*=f,Je.elements[9]*=f,Je.elements[10]*=f,e.setFromRotationMatrix(Je),n.x=s,n.y=a,n.z=l,this}makePerspective(t,e,n,i,s,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const l=this.elements,u=2*s/(e-t),h=2*s/(n-i),p=(e+t)/(e-t),f=(n+i)/(n-i),m=-(a+s)/(a-s),v=-2*a*s/(a-s);return l[0]=u,l[4]=0,l[8]=p,l[12]=0,l[1]=0,l[5]=h,l[9]=f,l[13]=0,l[2]=0,l[6]=0,l[10]=m,l[14]=v,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(t,e,n,i,s,a){const l=this.elements,u=1/(e-t),h=1/(n-i),p=1/(a-s),f=(e+t)*u,m=(n+i)*h,v=(a+s)*p;return l[0]=2*u,l[4]=0,l[8]=0,l[12]=-f,l[1]=0,l[5]=2*h,l[9]=0,l[13]=-m,l[2]=0,l[6]=0,l[10]=-2*p,l[14]=-v,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}Et.prototype.isMatrix4=!0;const ss=new C,Je=new Et,e0=new C(0,0,0),n0=new C(1,1,1),Jn=new C,fo=new C,He=new C,hh=new Et,dh=new se;class Fi{constructor(t=0,e=0,n=0,i=Fi.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._order=i||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e,n){const i=t.elements,s=i[0],a=i[4],l=i[8],u=i[1],h=i[5],p=i[9],f=i[2],m=i[6],v=i[10];switch(e=e||this._order,e){case"XYZ":this._y=Math.asin(Le(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-p,v),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(m,h),this._z=0);break;case"YXZ":this._x=Math.asin(-Le(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(l,v),this._z=Math.atan2(u,h)):(this._y=Math.atan2(-f,s),this._z=0);break;case"ZXY":this._x=Math.asin(Le(m,-1,1)),Math.abs(m)<.9999999?(this._y=Math.atan2(-f,v),this._z=Math.atan2(-a,h)):(this._y=0,this._z=Math.atan2(u,s));break;case"ZYX":this._y=Math.asin(-Le(f,-1,1)),Math.abs(f)<.9999999?(this._x=Math.atan2(m,v),this._z=Math.atan2(u,s)):(this._x=0,this._z=Math.atan2(-a,h));break;case"YZX":this._z=Math.asin(Le(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(-p,h),this._y=Math.atan2(-f,s)):(this._x=0,this._y=Math.atan2(l,v));break;case"XZY":this._z=Math.asin(-Le(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(m,h),this._y=Math.atan2(l,s)):(this._x=Math.atan2(-p,v),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n!==!1&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return hh.makeRotationFromQuaternion(t),this.setFromRotationMatrix(hh,e,n)}setFromVector3(t,e){return this.set(t.x,t.y,t.z,e||this._order)}reorder(t){return dh.setFromEuler(this),this.setFromQuaternion(dh,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new C(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Fi.prototype.isEuler=!0;Fi.DefaultOrder="XYZ";Fi.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class tp{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}}let i0=0;const ph=new C,rs=new se,In=new Et,mo=new C,or=new C,s0=new C,r0=new se,fh=new C(1,0,0),mh=new C(0,1,0),gh=new C(0,0,1),o0={type:"added"},vh={type:"removed"};class Wt extends fi{constructor(){super(),Object.defineProperty(this,"id",{value:i0++}),this.uuid=Ye(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Wt.DefaultUp.clone();const t=new C,e=new Fi,n=new se,i=new C(1,1,1);function s(){n.setFromEuler(e,!1)}function a(){e.setFromQuaternion(n,void 0,!1)}e._onChange(s),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Et},normalMatrix:{value:new Ae}}),this.matrix=new Et,this.matrixWorld=new Et,this.matrixAutoUpdate=Wt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new tp,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return rs.setFromAxisAngle(t,e),this.quaternion.multiply(rs),this}rotateOnWorldAxis(t,e){return rs.setFromAxisAngle(t,e),this.quaternion.premultiply(rs),this}rotateX(t){return this.rotateOnAxis(fh,t)}rotateY(t){return this.rotateOnAxis(mh,t)}rotateZ(t){return this.rotateOnAxis(gh,t)}translateOnAxis(t,e){return ph.copy(t).applyQuaternion(this.quaternion),this.position.add(ph.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(fh,t)}translateY(t){return this.translateOnAxis(mh,t)}translateZ(t){return this.translateOnAxis(gh,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(In.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?mo.copy(t):mo.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),or.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?In.lookAt(or,mo,this.up):In.lookAt(mo,or,this.up),this.quaternion.setFromRotationMatrix(In),i&&(In.extractRotation(i.matrixWorld),rs.setFromRotationMatrix(In),this.quaternion.premultiply(rs.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(o0)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(vh)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(vh)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),In.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),In.multiply(t.parent.matrixWorld)),t.applyMatrix4(In),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const a=this.children[n].getObjectByProperty(t,e);if(a!==void 0)return a}}getWorldPosition(t){return t===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),t=new C),this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return t===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),t=new se),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(or,t,s0),t}getWorldScale(t){return t===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),t=new C),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(or,r0,t),t}getWorldDirection(t){t===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),t=new C),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function s(l,u){return l[u.uuid]===void 0&&(l[u.uuid]=u.toJSON(t)),u.uuid}if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(t.geometries,this.geometry);const l=this.geometry.parameters;if(l!==void 0&&l.shapes!==void 0){const u=l.shapes;if(Array.isArray(u))for(let h=0,p=u.length;h<p;h++){const f=u[h];s(t.shapes,f)}else s(t.shapes,u)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const l=[];for(let u=0,h=this.material.length;u<h;u++)l.push(s(t.materials,this.material[u]));i.material=l}else i.material=s(t.materials,this.material);if(this.children.length>0){i.children=[];for(let l=0;l<this.children.length;l++)i.children.push(this.children[l].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let l=0;l<this.animations.length;l++){const u=this.animations[l];i.animations.push(s(t.animations,u))}}if(e){const l=a(t.geometries),u=a(t.materials),h=a(t.textures),p=a(t.images),f=a(t.shapes),m=a(t.skeletons),v=a(t.animations);l.length>0&&(n.geometries=l),u.length>0&&(n.materials=u),h.length>0&&(n.textures=h),p.length>0&&(n.images=p),f.length>0&&(n.shapes=f),m.length>0&&(n.skeletons=m),v.length>0&&(n.animations=v)}return n.object=i,n;function a(l){const u=[];for(const h in l){const p=l[h];delete p.metadata,u.push(p)}return u}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const i=t.children[n];this.add(i.clone())}return this}}Wt.DefaultUp=new C(0,1,0);Wt.DefaultMatrixAutoUpdate=!0;Wt.prototype.isObject3D=!0;const sl=new C,a0=new C,l0=new Ae;class qe{constructor(t=new C(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=sl.subVectors(n,e).cross(a0.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),e=new C),e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){e===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),e=new C);const n=t.delta(sl),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:e.copy(n).multiplyScalar(s).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),t=new C),t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||l0.getNormalMatrix(t),i=this.coplanarPoint(sl).applyMatrix4(t),s=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}qe.prototype.isPlane=!0;const Qe=new C,Dn=new C,rl=new C,Nn=new C,os=new C,as=new C,_h=new C,ol=new C,al=new C,ll=new C;class de{constructor(t=new C,e=new C,n=new C){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),i=new C),i.subVectors(n,e),Qe.subVectors(t,e),i.cross(Qe);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(t,e,n,i,s){Qe.subVectors(i,e),Dn.subVectors(n,e),rl.subVectors(t,e);const a=Qe.dot(Qe),l=Qe.dot(Dn),u=Qe.dot(rl),h=Dn.dot(Dn),p=Dn.dot(rl),f=a*h-l*l;if(s===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),s=new C),f===0)return s.set(-2,-1,-1);const m=1/f,v=(h*u-l*p)*m,x=(a*p-l*u)*m;return s.set(1-v-x,x,v)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,Nn),Nn.x>=0&&Nn.y>=0&&Nn.x+Nn.y<=1}static getUV(t,e,n,i,s,a,l,u){return this.getBarycoord(t,e,n,i,Nn),u.set(0,0),u.addScaledVector(s,Nn.x),u.addScaledVector(a,Nn.y),u.addScaledVector(l,Nn.z),u}static isFrontFacing(t,e,n,i){return Qe.subVectors(n,e),Dn.subVectors(t,e),Qe.cross(Dn).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Qe.subVectors(this.c,this.b),Dn.subVectors(this.a,this.b),Qe.cross(Dn).length()*.5}getMidpoint(t){return t===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),t=new C),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return de.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),t=new qe),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return de.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,s){return de.getUV(t,this.a,this.b,this.c,e,n,i,s)}containsPoint(t){return de.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return de.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){e===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),e=new C);const n=this.a,i=this.b,s=this.c;let a,l;os.subVectors(i,n),as.subVectors(s,n),ol.subVectors(t,n);const u=os.dot(ol),h=as.dot(ol);if(u<=0&&h<=0)return e.copy(n);al.subVectors(t,i);const p=os.dot(al),f=as.dot(al);if(p>=0&&f<=p)return e.copy(i);const m=u*f-p*h;if(m<=0&&u>=0&&p<=0)return a=u/(u-p),e.copy(n).addScaledVector(os,a);ll.subVectors(t,s);const v=os.dot(ll),x=as.dot(ll);if(x>=0&&v<=x)return e.copy(s);const b=v*h-u*x;if(b<=0&&h>=0&&x<=0)return l=h/(h-x),e.copy(n).addScaledVector(as,l);const w=p*x-v*f;if(w<=0&&f-p>=0&&v-x>=0)return _h.subVectors(s,i),l=(f-p)/(f-p+(v-x)),e.copy(i).addScaledVector(_h,l);const _=1/(w+b+m);return a=b*_,l=m*_,e.copy(n).addScaledVector(os,a).addScaledVector(as,l)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let c0=0;class Me extends fi{constructor(){super(),Object.defineProperty(this,"id",{value:c0++}),this.uuid=Ye(),this.name="",this.type="Material",this.fog=!0,this.blending=Sr,this.side=Ri,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=Ud,this.blendDst=Hd,this.blendEquation=bs,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Bl,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=k_,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Ya,this.stencilZFail=Ya,this.stencilZPass=Ya,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}onBuild(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===zd;continue}const i=this[e];if(i===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Sr&&(n.blending=this.blending),this.side!==Ri&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(n.morphTargets=!0),this.morphNormals===!0&&(n.morphNormals=!0),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function i(s){const a=[];for(const l in s){const u=s[l];delete u.metadata,a.push(u)}return a}if(e){const s=i(t.textures),a=i(t.images);s.length>0&&(n.textures=s),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const i=e.length;n=new Array(i);for(let s=0;s!==i;++s)n[s]=e[s].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}Me.prototype.isMaterial=!0;const ep={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},tn={h:0,s:0,l:0},go={h:0,s:0,l:0};function cl(r,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?r+(t-r)*6*e:e<1/2?t:e<2/3?r+(t-r)*6*(2/3-e):r}function ul(r){return r<.04045?r*.0773993808:Math.pow(r*.9478672986+.0521327014,2.4)}function hl(r){return r<.0031308?r*12.92:1.055*Math.pow(r,.41666)-.055}class yt{constructor(t,e,n){return e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=dc(t,1),e=Le(e,0,1),n=Le(n,0,1),e===0)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,s=2*n-i;this.r=cl(s,i,t+1/3),this.g=cl(s,i,t),this.b=cl(s,i,t-1/3)}return this}setStyle(t){function e(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let i;const s=n[1],a=n[2];switch(s){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,e(i[4]),this;if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,e(i[4]),this;break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const l=parseFloat(i[1])/360,u=parseInt(i[2],10)/100,h=parseInt(i[3],10)/100;return e(i[4]),this.setHSL(l,u,h)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const i=n[1],s=i.length;if(s===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=ep[t.toLowerCase()];return e!==void 0?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=ul(t.r),this.g=ul(t.g),this.b=ul(t.b),this}copyLinearToSRGB(t){return this.r=hl(t.r),this.g=hl(t.g),this.b=hl(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){t===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),t={h:0,s:0,l:0});const e=this.r,n=this.g,i=this.b,s=Math.max(e,n,i),a=Math.min(e,n,i);let l,u;const h=(a+s)/2;if(a===s)l=0,u=0;else{const p=s-a;switch(u=h<=.5?p/(s+a):p/(2-s-a),s){case e:l=(n-i)/p+(n<i?6:0);break;case n:l=(i-e)/p+2;break;case i:l=(e-n)/p+4;break}l/=6}return t.h=l,t.s=u,t.l=h,t}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(t,e,n){return this.getHSL(tn),tn.h+=t,tn.s+=e,tn.l+=n,this.setHSL(tn.h,tn.s,tn.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(tn),t.getHSL(go);const n=Pr(tn.h,go.h,e),i=Pr(tn.s,go.s,e),s=Pr(tn.l,go.l,e);return this.setHSL(n,i,s),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}yt.NAMES=ep;yt.prototype.isColor=!0;yt.prototype.r=1;yt.prototype.g=1;yt.prototype.b=1;class sn extends Me{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new yt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ha,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.morphTargets=t.morphTargets,this}}sn.prototype.isMeshBasicMaterial=!0;const re=new C,vo=new nt;class ae{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n===!0,this.usage=Or,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let i=0,s=t.length;i<s;i++){let a=t[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),a=new yt),e[n++]=a.r,e[n++]=a.g,e[n++]=a.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let i=0,s=t.length;i<s;i++){let a=t[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),a=new nt),e[n++]=a.x,e[n++]=a.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let i=0,s=t.length;i<s;i++){let a=t[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),a=new C),e[n++]=a.x,e[n++]=a.y,e[n++]=a.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let i=0,s=t.length;i<s;i++){let a=t[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),a=new ne),e[n++]=a.x,e[n++]=a.y,e[n++]=a.z,e[n++]=a.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)vo.fromBufferAttribute(this,e),vo.applyMatrix3(t),this.setXY(e,vo.x,vo.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)re.fromBufferAttribute(this,e),re.applyMatrix3(t),this.setXYZ(e,re.x,re.y,re.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)re.x=this.getX(e),re.y=this.getY(e),re.z=this.getZ(e),re.applyMatrix4(t),this.setXYZ(e,re.x,re.y,re.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)re.x=this.getX(e),re.y=this.getY(e),re.z=this.getZ(e),re.applyNormalMatrix(t),this.setXYZ(e,re.x,re.y,re.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)re.x=this.getX(e),re.y=this.getY(e),re.z=this.getZ(e),re.transformDirection(t),this.setXYZ(e,re.x,re.y,re.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==Or&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}}ae.prototype.isBufferAttribute=!0;class np extends ae{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class ip extends ae{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class u0 extends ae{constructor(t,e,n){super(new Uint16Array(t),e,n)}}u0.prototype.isFloat16BufferAttribute=!0;class qt extends ae{constructor(t,e,n){super(new Float32Array(t),e,n)}}function sp(r){if(r.length===0)return-1/0;let t=r[0];for(let e=1,n=r.length;e<n;++e)r[e]>t&&(t=r[e]);return t}let h0=0;const Xe=new Et,dl=new Wt,ls=new C,Ge=new ve,ar=new ve,we=new C;class Yt extends fi{constructor(){super(),Object.defineProperty(this,"id",{value:h0++}),this.uuid=Ye(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(sp(t)>65535?ip:np)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new Ae().getNormalMatrix(t);n.applyNormalMatrix(s),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return Xe.makeRotationFromQuaternion(t),this.applyMatrix4(Xe),this}rotateX(t){return Xe.makeRotationX(t),this.applyMatrix4(Xe),this}rotateY(t){return Xe.makeRotationY(t),this.applyMatrix4(Xe),this}rotateZ(t){return Xe.makeRotationZ(t),this.applyMatrix4(Xe),this}translate(t,e,n){return Xe.makeTranslation(t,e,n),this.applyMatrix4(Xe),this}scale(t,e,n){return Xe.makeScale(t,e,n),this.applyMatrix4(Xe),this}lookAt(t){return dl.lookAt(t),dl.updateMatrix(),this.applyMatrix4(dl.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ls).negate(),this.translate(ls.x,ls.y,ls.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const s=t[n];e.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new qt(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new ve);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new C(-1/0,-1/0,-1/0),new C(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++){const s=e[n];Ge.setFromBufferAttribute(s),this.morphTargetsRelative?(we.addVectors(this.boundingBox.min,Ge.min),this.boundingBox.expandByPoint(we),we.addVectors(this.boundingBox.max,Ge.max),this.boundingBox.expandByPoint(we)):(this.boundingBox.expandByPoint(Ge.min),this.boundingBox.expandByPoint(Ge.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new mi);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new C,1/0);return}if(t){const n=this.boundingSphere.center;if(Ge.setFromBufferAttribute(t),e)for(let s=0,a=e.length;s<a;s++){const l=e[s];ar.setFromBufferAttribute(l),this.morphTargetsRelative?(we.addVectors(Ge.min,ar.min),Ge.expandByPoint(we),we.addVectors(Ge.max,ar.max),Ge.expandByPoint(we)):(Ge.expandByPoint(ar.min),Ge.expandByPoint(ar.max))}Ge.getCenter(n);let i=0;for(let s=0,a=t.count;s<a;s++)we.fromBufferAttribute(t,s),i=Math.max(i,n.distanceToSquared(we));if(e)for(let s=0,a=e.length;s<a;s++){const l=e[s],u=this.morphTargetsRelative;for(let h=0,p=l.count;h<p;h++)we.fromBufferAttribute(l,h),u&&(ls.fromBufferAttribute(t,h),we.add(ls)),i=Math.max(i,n.distanceToSquared(we))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeFaceNormals(){}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.array,i=e.position.array,s=e.normal.array,a=e.uv.array,l=i.length/3;e.tangent===void 0&&this.setAttribute("tangent",new ae(new Float32Array(4*l),4));const u=e.tangent.array,h=[],p=[];for(let z=0;z<l;z++)h[z]=new C,p[z]=new C;const f=new C,m=new C,v=new C,x=new nt,b=new nt,w=new nt,_=new C,y=new C;function M(z,W,H){f.fromArray(i,z*3),m.fromArray(i,W*3),v.fromArray(i,H*3),x.fromArray(a,z*2),b.fromArray(a,W*2),w.fromArray(a,H*2),m.sub(f),v.sub(f),b.sub(x),w.sub(x);const D=1/(b.x*w.y-w.x*b.y);!isFinite(D)||(_.copy(m).multiplyScalar(w.y).addScaledVector(v,-b.y).multiplyScalar(D),y.copy(v).multiplyScalar(b.x).addScaledVector(m,-w.x).multiplyScalar(D),h[z].add(_),h[W].add(_),h[H].add(_),p[z].add(y),p[W].add(y),p[H].add(y))}let T=this.groups;T.length===0&&(T=[{start:0,count:n.length}]);for(let z=0,W=T.length;z<W;++z){const H=T[z],D=H.start,V=H.count;for(let G=D,B=D+V;G<B;G+=3)M(n[G+0],n[G+1],n[G+2])}const A=new C,E=new C,P=new C,I=new C;function N(z){P.fromArray(s,z*3),I.copy(P);const W=h[z];A.copy(W),A.sub(P.multiplyScalar(P.dot(W))).normalize(),E.crossVectors(I,W);const D=E.dot(p[z])<0?-1:1;u[z*4]=A.x,u[z*4+1]=A.y,u[z*4+2]=A.z,u[z*4+3]=D}for(let z=0,W=T.length;z<W;++z){const H=T[z],D=H.start,V=H.count;for(let G=D,B=D+V;G<B;G+=3)N(n[G+0]),N(n[G+1]),N(n[G+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new ae(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let m=0,v=n.count;m<v;m++)n.setXYZ(m,0,0,0);const i=new C,s=new C,a=new C,l=new C,u=new C,h=new C,p=new C,f=new C;if(t)for(let m=0,v=t.count;m<v;m+=3){const x=t.getX(m+0),b=t.getX(m+1),w=t.getX(m+2);i.fromBufferAttribute(e,x),s.fromBufferAttribute(e,b),a.fromBufferAttribute(e,w),p.subVectors(a,s),f.subVectors(i,s),p.cross(f),l.fromBufferAttribute(n,x),u.fromBufferAttribute(n,b),h.fromBufferAttribute(n,w),l.add(p),u.add(p),h.add(p),n.setXYZ(x,l.x,l.y,l.z),n.setXYZ(b,u.x,u.y,u.z),n.setXYZ(w,h.x,h.y,h.z)}else for(let m=0,v=e.count;m<v;m+=3)i.fromBufferAttribute(e,m+0),s.fromBufferAttribute(e,m+1),a.fromBufferAttribute(e,m+2),p.subVectors(a,s),f.subVectors(i,s),p.cross(f),n.setXYZ(m+0,p.x,p.y,p.z),n.setXYZ(m+1,p.x,p.y,p.z),n.setXYZ(m+2,p.x,p.y,p.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!(t&&t.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(t.attributes[i]===void 0)continue;const a=n[i].array,l=t.attributes[i],u=l.array,h=l.itemSize*e,p=Math.min(u.length,a.length-h);for(let f=0,m=h;f<p;f++,m++)a[m]=u[f]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)we.fromBufferAttribute(t,e),we.normalize(),t.setXYZ(e,we.x,we.y,we.z)}toNonIndexed(){function t(l,u){const h=l.array,p=l.itemSize,f=l.normalized,m=new h.constructor(u.length*p);let v=0,x=0;for(let b=0,w=u.length;b<w;b++){v=u[b]*p;for(let _=0;_<p;_++)m[x++]=h[v++]}return new ae(m,p,f)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Yt,n=this.index.array,i=this.attributes;for(const l in i){const u=i[l],h=t(u,n);e.setAttribute(l,h)}const s=this.morphAttributes;for(const l in s){const u=[],h=s[l];for(let p=0,f=h.length;p<f;p++){const m=h[p],v=t(m,n);u.push(v)}e.morphAttributes[l]=u}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let l=0,u=a.length;l<u;l++){const h=a[l];e.addGroup(h.start,h.count,h.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const u=this.parameters;for(const h in u)u[h]!==void 0&&(t[h]=u[h]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const u in n){const h=n[u];t.data.attributes[u]=h.toJSON(t.data)}const i={};let s=!1;for(const u in this.morphAttributes){const h=this.morphAttributes[u],p=[];for(let f=0,m=h.length;f<m;f++){const v=h[f];p.push(v.toJSON(t.data))}p.length>0&&(i[u]=p,s=!0)}s&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const l=this.boundingSphere;return l!==null&&(t.data.boundingSphere={center:l.center.toArray(),radius:l.radius}),t}clone(){return new Yt().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const i=t.attributes;for(const h in i){const p=i[h];this.setAttribute(h,p.clone(e))}const s=t.morphAttributes;for(const h in s){const p=[],f=s[h];for(let m=0,v=f.length;m<v;m++)p.push(f[m].clone(e));this.morphAttributes[h]=p}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let h=0,p=a.length;h<p;h++){const f=a[h];this.addGroup(f.start,f.count,f.materialIndex)}const l=t.boundingBox;l!==null&&(this.boundingBox=l.clone());const u=t.boundingSphere;return u!==null&&(this.boundingSphere=u.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}Yt.prototype.isBufferGeometry=!0;const xh=new Et,cs=new Ni,pl=new mi,Qn=new C,ti=new C,ei=new C,fl=new C,ml=new C,gl=new C,_o=new C,xo=new C,yo=new C,bo=new nt,wo=new nt,Mo=new nt,vl=new C,Eo=new C;class wt extends Wt{constructor(t=new Yt,e=new sn){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const l=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,i=this.material,s=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),pl.copy(n.boundingSphere),pl.applyMatrix4(s),t.ray.intersectsSphere(pl)===!1)||(xh.copy(s).invert(),cs.copy(t.ray).applyMatrix4(xh),n.boundingBox!==null&&cs.intersectsBox(n.boundingBox)===!1))return;let a;if(n.isBufferGeometry){const l=n.index,u=n.attributes.position,h=n.morphAttributes.position,p=n.morphTargetsRelative,f=n.attributes.uv,m=n.attributes.uv2,v=n.groups,x=n.drawRange;if(l!==null)if(Array.isArray(i))for(let b=0,w=v.length;b<w;b++){const _=v[b],y=i[_.materialIndex],M=Math.max(_.start,x.start),T=Math.min(_.start+_.count,x.start+x.count);for(let A=M,E=T;A<E;A+=3){const P=l.getX(A),I=l.getX(A+1),N=l.getX(A+2);a=So(this,y,t,cs,u,h,p,f,m,P,I,N),a&&(a.faceIndex=Math.floor(A/3),a.face.materialIndex=_.materialIndex,e.push(a))}}else{const b=Math.max(0,x.start),w=Math.min(l.count,x.start+x.count);for(let _=b,y=w;_<y;_+=3){const M=l.getX(_),T=l.getX(_+1),A=l.getX(_+2);a=So(this,i,t,cs,u,h,p,f,m,M,T,A),a&&(a.faceIndex=Math.floor(_/3),e.push(a))}}else if(u!==void 0)if(Array.isArray(i))for(let b=0,w=v.length;b<w;b++){const _=v[b],y=i[_.materialIndex],M=Math.max(_.start,x.start),T=Math.min(_.start+_.count,x.start+x.count);for(let A=M,E=T;A<E;A+=3){const P=A,I=A+1,N=A+2;a=So(this,y,t,cs,u,h,p,f,m,P,I,N),a&&(a.faceIndex=Math.floor(A/3),a.face.materialIndex=_.materialIndex,e.push(a))}}else{const b=Math.max(0,x.start),w=Math.min(u.count,x.start+x.count);for(let _=b,y=w;_<y;_+=3){const M=_,T=_+1,A=_+2;a=So(this,i,t,cs,u,h,p,f,m,M,T,A),a&&(a.faceIndex=Math.floor(_/3),e.push(a))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}wt.prototype.isMesh=!0;function d0(r,t,e,n,i,s,a,l){let u;if(t.side===ye?u=n.intersectTriangle(a,s,i,!0,l):u=n.intersectTriangle(i,s,a,t.side!==on,l),u===null)return null;Eo.copy(l),Eo.applyMatrix4(r.matrixWorld);const h=e.ray.origin.distanceTo(Eo);return h<e.near||h>e.far?null:{distance:h,point:Eo.clone(),object:r}}function So(r,t,e,n,i,s,a,l,u,h,p,f){Qn.fromBufferAttribute(i,h),ti.fromBufferAttribute(i,p),ei.fromBufferAttribute(i,f);const m=r.morphTargetInfluences;if(t.morphTargets&&s&&m){_o.set(0,0,0),xo.set(0,0,0),yo.set(0,0,0);for(let x=0,b=s.length;x<b;x++){const w=m[x],_=s[x];w!==0&&(fl.fromBufferAttribute(_,h),ml.fromBufferAttribute(_,p),gl.fromBufferAttribute(_,f),a?(_o.addScaledVector(fl,w),xo.addScaledVector(ml,w),yo.addScaledVector(gl,w)):(_o.addScaledVector(fl.sub(Qn),w),xo.addScaledVector(ml.sub(ti),w),yo.addScaledVector(gl.sub(ei),w)))}Qn.add(_o),ti.add(xo),ei.add(yo)}r.isSkinnedMesh&&(r.boneTransform(h,Qn),r.boneTransform(p,ti),r.boneTransform(f,ei));const v=d0(r,t,e,n,Qn,ti,ei,vl);if(v){l&&(bo.fromBufferAttribute(l,h),wo.fromBufferAttribute(l,p),Mo.fromBufferAttribute(l,f),v.uv=de.getUV(vl,Qn,ti,ei,bo,wo,Mo,new nt)),u&&(bo.fromBufferAttribute(u,h),wo.fromBufferAttribute(u,p),Mo.fromBufferAttribute(u,f),v.uv2=de.getUV(vl,Qn,ti,ei,bo,wo,Mo,new nt));const x={a:h,b:p,c:f,normal:new C,materialIndex:0};de.getNormal(Qn,ti,ei,x.normal),v.face=x}return v}class fn extends Yt{constructor(t=1,e=1,n=1,i=1,s=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:s,depthSegments:a};const l=this;i=Math.floor(i),s=Math.floor(s),a=Math.floor(a);const u=[],h=[],p=[],f=[];let m=0,v=0;x("z","y","x",-1,-1,n,e,t,a,s,0),x("z","y","x",1,-1,n,e,-t,a,s,1),x("x","z","y",1,1,t,n,e,i,a,2),x("x","z","y",1,-1,t,n,-e,i,a,3),x("x","y","z",1,-1,t,e,n,i,s,4),x("x","y","z",-1,-1,t,e,-n,i,s,5),this.setIndex(u),this.setAttribute("position",new qt(h,3)),this.setAttribute("normal",new qt(p,3)),this.setAttribute("uv",new qt(f,2));function x(b,w,_,y,M,T,A,E,P,I,N){const z=T/P,W=A/I,H=T/2,D=A/2,V=E/2,G=P+1,B=I+1;let j=0,ot=0;const Q=new C;for(let ut=0;ut<B;ut++){const rt=ut*W-D;for(let Tt=0;Tt<G;Tt++){const ct=Tt*z-H;Q[b]=ct*y,Q[w]=rt*M,Q[_]=V,h.push(Q.x,Q.y,Q.z),Q[b]=0,Q[w]=0,Q[_]=E>0?1:-1,p.push(Q.x,Q.y,Q.z),f.push(Tt/P),f.push(1-ut/I),j+=1}}for(let ut=0;ut<I;ut++)for(let rt=0;rt<P;rt++){const Tt=m+rt+G*ut,ct=m+rt+G*(ut+1),ft=m+(rt+1)+G*(ut+1),Ft=m+(rt+1)+G*ut;u.push(Tt,ct,Ft),u.push(ct,ft,Ft),ot+=6}l.addGroup(v,ot,N),v+=ot,m+=j}}}function Is(r){const t={};for(const e in r){t[e]={};for(const n in r[e]){const i=r[e][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?t[e][n]=i.clone():Array.isArray(i)?t[e][n]=i.slice():t[e][n]=i}}return t}function Pe(r){const t={};for(let e=0;e<r.length;e++){const n=Is(r[e]);for(const i in n)t[i]=n[i]}return t}const p0={clone:Is,merge:Pe};var f0=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,m0=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class yn extends Me{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=f0,this.fragmentShader=m0,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&(t.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Is(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?e.uniforms[i]={type:"t",value:a.toJSON(t).uuid}:a&&a.isColor?e.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?e.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?e.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?e.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?e.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?e.uniforms[i]={type:"m4",value:a.toArray()}:e.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}yn.prototype.isShaderMaterial=!0;class pc extends Wt{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Et,this.projectionMatrix=new Et,this.projectionMatrixInverse=new Et}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){t===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),t=new C),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}pc.prototype.isCamera=!0;class De extends pc{constructor(t=50,e=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=Vr*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(Cr*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return Vr*2*Math.atan(Math.tan(Cr*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,s,a){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(Cr*.5*this.fov)/this.zoom,n=2*e,i=this.aspect*n,s=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const u=a.fullWidth,h=a.fullHeight;s+=a.offsetX*i/u,e-=a.offsetY*n/h,i*=a.width/u,n*=a.height/h}const l=this.filmOffset;l!==0&&(s+=t*l/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}De.prototype.isPerspectiveCamera=!0;const us=90,hs=1;class fc extends Wt{constructor(t,e,n){if(super(),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const i=new De(us,hs,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new C(1,0,0)),this.add(i);const s=new De(us,hs,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new C(-1,0,0)),this.add(s);const a=new De(us,hs,t,e);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new C(0,1,0)),this.add(a);const l=new De(us,hs,t,e);l.layers=this.layers,l.up.set(0,0,-1),l.lookAt(new C(0,-1,0)),this.add(l);const u=new De(us,hs,t,e);u.layers=this.layers,u.up.set(0,-1,0),u.lookAt(new C(0,0,1)),this.add(u);const h=new De(us,hs,t,e);h.layers=this.layers,h.up.set(0,-1,0),h.lookAt(new C(0,0,-1)),this.add(h)}update(t,e){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,s,a,l,u,h]=this.children,p=t.xr.enabled,f=t.getRenderTarget();t.xr.enabled=!1;const m=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,s),t.setRenderTarget(n,2),t.render(e,a),t.setRenderTarget(n,3),t.render(e,l),t.setRenderTarget(n,4),t.render(e,u),n.texture.generateMipmaps=m,t.setRenderTarget(n,5),t.render(e,h),t.setRenderTarget(f),t.xr.enabled=p}}class da extends Ce{constructor(t,e,n,i,s,a,l,u,h,p){t=t!==void 0?t:[],e=e!==void 0?e:oc,l=l!==void 0?l:li,super(t,e,n,i,s,a,l,u,h,p),this._needsFlipEnvMap=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}da.prototype.isCubeTexture=!0;class rp extends rn{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),e=e||{},this.texture=new da(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:Re,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=Fe,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new fn(5,5,5),s=new yn({name:"CubemapFromEquirect",uniforms:Is(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:ye,blending:Er});s.uniforms.tEquirect.value=e;const a=new wt(i,s),l=e.minFilter;return e.minFilter===Bs&&(e.minFilter=Re),new fc(1,10,this).update(t,a),e.minFilter=l,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,n,i){const s=t.getRenderTarget();for(let a=0;a<6;a++)t.setRenderTarget(this,a),t.clear(e,n,i);t.setRenderTarget(s)}}rp.prototype.isWebGLCubeRenderTarget=!0;const ds=new mi,To=new C;class pa{constructor(t=new qe,e=new qe,n=new qe,i=new qe,s=new qe,a=new qe){this.planes=[t,e,n,i,s,a]}set(t,e,n,i,s,a){const l=this.planes;return l[0].copy(t),l[1].copy(e),l[2].copy(n),l[3].copy(i),l[4].copy(s),l[5].copy(a),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],s=n[1],a=n[2],l=n[3],u=n[4],h=n[5],p=n[6],f=n[7],m=n[8],v=n[9],x=n[10],b=n[11],w=n[12],_=n[13],y=n[14],M=n[15];return e[0].setComponents(l-i,f-u,b-m,M-w).normalize(),e[1].setComponents(l+i,f+u,b+m,M+w).normalize(),e[2].setComponents(l+s,f+h,b+v,M+_).normalize(),e[3].setComponents(l-s,f-h,b-v,M-_).normalize(),e[4].setComponents(l-a,f-p,b-x,M-y).normalize(),e[5].setComponents(l+a,f+p,b+x,M+y).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),ds.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(ds)}intersectsSprite(t){return ds.center.set(0,0,0),ds.radius=.7071067811865476,ds.applyMatrix4(t.matrixWorld),this.intersectsSphere(ds)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(To.x=i.normal.x>0?t.max.x:t.min.x,To.y=i.normal.y>0?t.max.y:t.min.y,To.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(To)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function op(){let r=null,t=!1,e=null,n=null;function i(s,a){e(s,a),n=r.requestAnimationFrame(i)}return{start:function(){t!==!0&&e!==null&&(n=r.requestAnimationFrame(i),t=!0)},stop:function(){r.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(s){e=s},setContext:function(s){r=s}}}function g0(r,t){const e=t.isWebGL2,n=new WeakMap;function i(h,p){const f=h.array,m=h.usage,v=r.createBuffer();r.bindBuffer(p,v),r.bufferData(p,f,m),h.onUploadCallback();let x=5126;return f instanceof Float32Array?x=5126:f instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):f instanceof Uint16Array?h.isFloat16BufferAttribute?e?x=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):x=5123:f instanceof Int16Array?x=5122:f instanceof Uint32Array?x=5125:f instanceof Int32Array?x=5124:f instanceof Int8Array?x=5120:(f instanceof Uint8Array||f instanceof Uint8ClampedArray)&&(x=5121),{buffer:v,type:x,bytesPerElement:f.BYTES_PER_ELEMENT,version:h.version}}function s(h,p,f){const m=p.array,v=p.updateRange;r.bindBuffer(f,h),v.count===-1?r.bufferSubData(f,0,m):(e?r.bufferSubData(f,v.offset*m.BYTES_PER_ELEMENT,m,v.offset,v.count):r.bufferSubData(f,v.offset*m.BYTES_PER_ELEMENT,m.subarray(v.offset,v.offset+v.count)),v.count=-1)}function a(h){return h.isInterleavedBufferAttribute&&(h=h.data),n.get(h)}function l(h){h.isInterleavedBufferAttribute&&(h=h.data);const p=n.get(h);p&&(r.deleteBuffer(p.buffer),n.delete(h))}function u(h,p){if(h.isGLBufferAttribute){const m=n.get(h);(!m||m.version<h.version)&&n.set(h,{buffer:h.buffer,type:h.type,bytesPerElement:h.elementSize,version:h.version});return}h.isInterleavedBufferAttribute&&(h=h.data);const f=n.get(h);f===void 0?n.set(h,i(h,p)):f.version<h.version&&(s(f.buffer,h,p),f.version=h.version)}return{get:a,remove:l,update:u}}class mn extends Yt{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const s=t/2,a=e/2,l=Math.floor(n),u=Math.floor(i),h=l+1,p=u+1,f=t/l,m=e/u,v=[],x=[],b=[],w=[];for(let _=0;_<p;_++){const y=_*m-a;for(let M=0;M<h;M++){const T=M*f-s;x.push(T,-y,0),b.push(0,0,1),w.push(M/l),w.push(1-_/u)}}for(let _=0;_<u;_++)for(let y=0;y<l;y++){const M=y+h*_,T=y+h*(_+1),A=y+1+h*(_+1),E=y+1+h*_;v.push(M,T,E),v.push(T,A,E)}this.setIndex(v),this.setAttribute("position",new qt(x,3)),this.setAttribute("normal",new qt(b,3)),this.setAttribute("uv",new qt(w,2))}}var v0=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,_0=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,x0=`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,y0=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,b0=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,w0="vec3 transformed = vec3( position );",M0=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,E0=`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,S0=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,T0=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,A0=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,C0=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,P0=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,L0=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,R0=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,I0=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,D0=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,N0=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,F0=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,k0=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,B0=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,O0=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,V0=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,z0=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,U0="gl_FragColor = linearToOutputTexel( gl_FragColor );",H0=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,G0=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,W0=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,j0=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,X0=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,q0=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Y0=`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,Z0=`#ifdef USE_FOG
	varying float fogDepth;
#endif`,K0=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,$0=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,J0=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,Q0=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,tx=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,ex=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,nx=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,ix=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,sx=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,rx=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,ox=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,ax=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,lx=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,cx=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,ux=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,hx=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,dx=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,px=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,fx=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,mx=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,gx=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,vx=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,_x=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,xx=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,yx=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,bx=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,wx=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,Mx=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,Ex=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,Sx=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,Tx=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,Ax=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,Cx=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,Px=`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,Lx=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,Rx=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Ix=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Dx=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Nx=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Fx=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,kx=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Bx=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Ox=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Vx=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,zx=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Ux=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Hx=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Gx=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Wx=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,jx=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Xx=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,qx=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Yx=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Zx=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Kx=`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,$x=`#ifdef USE_TRANSMISSION
	#ifdef USE_TRANSMISSIONMAP
		totalTransmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSNMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;
	vec3 v = normalize( cameraPosition - pos );
	vec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );
	vec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );
	vec3 f90 = vec3( 1.0 );
	vec3 f_transmission = totalTransmission * getIBLVolumeRefraction(
		normal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance);
	diffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );
#endif`,Jx=`#ifdef USE_TRANSMISSION
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec4 vWorldPosition;
	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {
		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);
		vec3 modelScale;
		modelScale.x = length(vec3(modelMatrix[0].xyz));
		modelScale.y = length(vec3(modelMatrix[1].xyz));
		modelScale.z = length(vec3(modelMatrix[2].xyz));
		return normalize(refractionVector) * thickness * modelScale;
	}
	float applyIorToRoughness(float roughness, float ior) {
		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);
	}
	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {
		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);
		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;
	}
	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {
		if (attenuationDistance == 0.0) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;
			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);			return transmittance * radiance;
		}
	}
	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {
		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);
		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);
		float NdotV = saturate(dot(n, viewDir));
		vec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);
		vec3 specularColor = f0 * brdf.x + f90 * brdf.y;
		return (1.0 - specularColor) * attenuatedColor * baseColor;
	}
#endif`,Qx=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,ty=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,ey=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,ny=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,iy=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,sy=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,ry=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,oy=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,ay=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,ly=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,cy=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,uy=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,hy=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,dy=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,py=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,fy=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,my=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,gy=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vy=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,_y=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,xy=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,yy=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,by=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,wy=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,My=`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Ey=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Sy=`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Ty=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ay=`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Cy=`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform vec3 attenuationColor;
	uniform float attenuationDistance;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <transmission_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef USE_TRANSMISSION
		float totalTransmission = transmission;
		float thicknessFactor = thickness;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	vec3 rawDiffuseColor = diffuseColor.rgb;
	#include <transmission_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Py=`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#ifdef USE_TRANSMISSION
	varying vec4 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition;
#endif
}`,Ly=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,Ry=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Iy=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Dy=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Ny=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Fy=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,ky=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,By=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const Ut={alphamap_fragment:v0,alphamap_pars_fragment:_0,alphatest_fragment:x0,aomap_fragment:y0,aomap_pars_fragment:b0,begin_vertex:w0,beginnormal_vertex:M0,bsdfs:E0,bumpmap_pars_fragment:S0,clipping_planes_fragment:T0,clipping_planes_pars_fragment:A0,clipping_planes_pars_vertex:C0,clipping_planes_vertex:P0,color_fragment:L0,color_pars_fragment:R0,color_pars_vertex:I0,color_vertex:D0,common:N0,cube_uv_reflection_fragment:F0,defaultnormal_vertex:k0,displacementmap_pars_vertex:B0,displacementmap_vertex:O0,emissivemap_fragment:V0,emissivemap_pars_fragment:z0,encodings_fragment:U0,encodings_pars_fragment:H0,envmap_fragment:G0,envmap_common_pars_fragment:W0,envmap_pars_fragment:j0,envmap_pars_vertex:X0,envmap_physical_pars_fragment:ix,envmap_vertex:q0,fog_vertex:Y0,fog_pars_vertex:Z0,fog_fragment:K0,fog_pars_fragment:$0,gradientmap_pars_fragment:J0,lightmap_fragment:Q0,lightmap_pars_fragment:tx,lights_lambert_vertex:ex,lights_pars_begin:nx,lights_toon_fragment:sx,lights_toon_pars_fragment:rx,lights_phong_fragment:ox,lights_phong_pars_fragment:ax,lights_physical_fragment:lx,lights_physical_pars_fragment:cx,lights_fragment_begin:ux,lights_fragment_maps:hx,lights_fragment_end:dx,logdepthbuf_fragment:px,logdepthbuf_pars_fragment:fx,logdepthbuf_pars_vertex:mx,logdepthbuf_vertex:gx,map_fragment:vx,map_pars_fragment:_x,map_particle_fragment:xx,map_particle_pars_fragment:yx,metalnessmap_fragment:bx,metalnessmap_pars_fragment:wx,morphnormal_vertex:Mx,morphtarget_pars_vertex:Ex,morphtarget_vertex:Sx,normal_fragment_begin:Tx,normal_fragment_maps:Ax,normalmap_pars_fragment:Cx,clearcoat_normal_fragment_begin:Px,clearcoat_normal_fragment_maps:Lx,clearcoat_pars_fragment:Rx,packing:Ix,premultiplied_alpha_fragment:Dx,project_vertex:Nx,dithering_fragment:Fx,dithering_pars_fragment:kx,roughnessmap_fragment:Bx,roughnessmap_pars_fragment:Ox,shadowmap_pars_fragment:Vx,shadowmap_pars_vertex:zx,shadowmap_vertex:Ux,shadowmask_pars_fragment:Hx,skinbase_vertex:Gx,skinning_pars_vertex:Wx,skinning_vertex:jx,skinnormal_vertex:Xx,specularmap_fragment:qx,specularmap_pars_fragment:Yx,tonemapping_fragment:Zx,tonemapping_pars_fragment:Kx,transmission_fragment:$x,transmission_pars_fragment:Jx,uv_pars_fragment:Qx,uv_pars_vertex:ty,uv_vertex:ey,uv2_pars_fragment:ny,uv2_pars_vertex:iy,uv2_vertex:sy,worldpos_vertex:ry,background_frag:oy,background_vert:ay,cube_frag:ly,cube_vert:cy,depth_frag:uy,depth_vert:hy,distanceRGBA_frag:dy,distanceRGBA_vert:py,equirect_frag:fy,equirect_vert:my,linedashed_frag:gy,linedashed_vert:vy,meshbasic_frag:_y,meshbasic_vert:xy,meshlambert_frag:yy,meshlambert_vert:by,meshmatcap_frag:wy,meshmatcap_vert:My,meshtoon_frag:Ey,meshtoon_vert:Sy,meshphong_frag:Ty,meshphong_vert:Ay,meshphysical_frag:Cy,meshphysical_vert:Py,normal_frag:Ly,normal_vert:Ry,points_frag:Iy,points_vert:Dy,shadow_frag:Ny,shadow_vert:Fy,sprite_frag:ky,sprite_vert:By},vt={common:{diffuse:{value:new yt(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Ae},uv2Transform:{value:new Ae},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new nt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new yt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new yt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Ae}},sprite:{diffuse:{value:new yt(16777215)},opacity:{value:1},center:{value:new nt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Ae}}},gn={basic:{uniforms:Pe([vt.common,vt.specularmap,vt.envmap,vt.aomap,vt.lightmap,vt.fog]),vertexShader:Ut.meshbasic_vert,fragmentShader:Ut.meshbasic_frag},lambert:{uniforms:Pe([vt.common,vt.specularmap,vt.envmap,vt.aomap,vt.lightmap,vt.emissivemap,vt.fog,vt.lights,{emissive:{value:new yt(0)}}]),vertexShader:Ut.meshlambert_vert,fragmentShader:Ut.meshlambert_frag},phong:{uniforms:Pe([vt.common,vt.specularmap,vt.envmap,vt.aomap,vt.lightmap,vt.emissivemap,vt.bumpmap,vt.normalmap,vt.displacementmap,vt.fog,vt.lights,{emissive:{value:new yt(0)},specular:{value:new yt(1118481)},shininess:{value:30}}]),vertexShader:Ut.meshphong_vert,fragmentShader:Ut.meshphong_frag},standard:{uniforms:Pe([vt.common,vt.envmap,vt.aomap,vt.lightmap,vt.emissivemap,vt.bumpmap,vt.normalmap,vt.displacementmap,vt.roughnessmap,vt.metalnessmap,vt.fog,vt.lights,{emissive:{value:new yt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ut.meshphysical_vert,fragmentShader:Ut.meshphysical_frag},toon:{uniforms:Pe([vt.common,vt.aomap,vt.lightmap,vt.emissivemap,vt.bumpmap,vt.normalmap,vt.displacementmap,vt.gradientmap,vt.fog,vt.lights,{emissive:{value:new yt(0)}}]),vertexShader:Ut.meshtoon_vert,fragmentShader:Ut.meshtoon_frag},matcap:{uniforms:Pe([vt.common,vt.bumpmap,vt.normalmap,vt.displacementmap,vt.fog,{matcap:{value:null}}]),vertexShader:Ut.meshmatcap_vert,fragmentShader:Ut.meshmatcap_frag},points:{uniforms:Pe([vt.points,vt.fog]),vertexShader:Ut.points_vert,fragmentShader:Ut.points_frag},dashed:{uniforms:Pe([vt.common,vt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ut.linedashed_vert,fragmentShader:Ut.linedashed_frag},depth:{uniforms:Pe([vt.common,vt.displacementmap]),vertexShader:Ut.depth_vert,fragmentShader:Ut.depth_frag},normal:{uniforms:Pe([vt.common,vt.bumpmap,vt.normalmap,vt.displacementmap,{opacity:{value:1}}]),vertexShader:Ut.normal_vert,fragmentShader:Ut.normal_frag},sprite:{uniforms:Pe([vt.sprite,vt.fog]),vertexShader:Ut.sprite_vert,fragmentShader:Ut.sprite_frag},background:{uniforms:{uvTransform:{value:new Ae},t2D:{value:null}},vertexShader:Ut.background_vert,fragmentShader:Ut.background_frag},cube:{uniforms:Pe([vt.envmap,{opacity:{value:1}}]),vertexShader:Ut.cube_vert,fragmentShader:Ut.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ut.equirect_vert,fragmentShader:Ut.equirect_frag},distanceRGBA:{uniforms:Pe([vt.common,vt.displacementmap,{referencePosition:{value:new C},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ut.distanceRGBA_vert,fragmentShader:Ut.distanceRGBA_frag},shadow:{uniforms:Pe([vt.lights,vt.fog,{color:{value:new yt(0)},opacity:{value:1}}]),vertexShader:Ut.shadow_vert,fragmentShader:Ut.shadow_frag}};gn.physical={uniforms:Pe([gn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new nt(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new yt(0)},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new nt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new yt(0)}}]),vertexShader:Ut.meshphysical_vert,fragmentShader:Ut.meshphysical_frag};function Oy(r,t,e,n,i){const s=new yt(0);let a=0,l,u,h=null,p=0,f=null;function m(x,b){let w=!1,_=b.isScene===!0?b.background:null;_&&_.isTexture&&(_=t.get(_));const y=r.xr,M=y.getSession&&y.getSession();M&&M.environmentBlendMode==="additive"&&(_=null),_===null?v(s,a):_&&_.isColor&&(v(_,1),w=!0),(r.autoClear||w)&&r.clear(r.autoClearColor,r.autoClearDepth,r.autoClearStencil),_&&(_.isCubeTexture||_.mapping===lc)?(u===void 0&&(u=new wt(new fn(1,1,1),new yn({name:"BackgroundCubeMaterial",uniforms:Is(gn.cube.uniforms),vertexShader:gn.cube.vertexShader,fragmentShader:gn.cube.fragmentShader,side:ye,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(T,A,E){this.matrixWorld.copyPosition(E.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(u)),u.material.uniforms.envMap.value=_,u.material.uniforms.flipEnvMap.value=_.isCubeTexture&&_._needsFlipEnvMap?-1:1,(h!==_||p!==_.version||f!==r.toneMapping)&&(u.material.needsUpdate=!0,h=_,p=_.version,f=r.toneMapping),x.unshift(u,u.geometry,u.material,0,0,null)):_&&_.isTexture&&(l===void 0&&(l=new wt(new mn(2,2),new yn({name:"BackgroundMaterial",uniforms:Is(gn.background.uniforms),vertexShader:gn.background.vertexShader,fragmentShader:gn.background.fragmentShader,side:Ri,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(l)),l.material.uniforms.t2D.value=_,_.matrixAutoUpdate===!0&&_.updateMatrix(),l.material.uniforms.uvTransform.value.copy(_.matrix),(h!==_||p!==_.version||f!==r.toneMapping)&&(l.material.needsUpdate=!0,h=_,p=_.version,f=r.toneMapping),x.unshift(l,l.geometry,l.material,0,0,null))}function v(x,b){e.buffers.color.setClear(x.r,x.g,x.b,b,i)}return{getClearColor:function(){return s},setClearColor:function(x,b=1){s.set(x),a=b,v(s,a)},getClearAlpha:function(){return a},setClearAlpha:function(x){a=x,v(s,a)},render:m}}function Vy(r,t,e,n){const i=r.getParameter(34921),s=n.isWebGL2?null:t.get("OES_vertex_array_object"),a=n.isWebGL2||s!==null,l={},u=b(null);let h=u;function p(D,V,G,B,j){let ot=!1;if(a){const Q=x(B,G,V);h!==Q&&(h=Q,m(h.object)),ot=w(B,j),ot&&_(B,j)}else{const Q=V.wireframe===!0;(h.geometry!==B.id||h.program!==G.id||h.wireframe!==Q)&&(h.geometry=B.id,h.program=G.id,h.wireframe=Q,ot=!0)}D.isInstancedMesh===!0&&(ot=!0),j!==null&&e.update(j,34963),ot&&(P(D,V,G,B),j!==null&&r.bindBuffer(34963,e.get(j).buffer))}function f(){return n.isWebGL2?r.createVertexArray():s.createVertexArrayOES()}function m(D){return n.isWebGL2?r.bindVertexArray(D):s.bindVertexArrayOES(D)}function v(D){return n.isWebGL2?r.deleteVertexArray(D):s.deleteVertexArrayOES(D)}function x(D,V,G){const B=G.wireframe===!0;let j=l[D.id];j===void 0&&(j={},l[D.id]=j);let ot=j[V.id];ot===void 0&&(ot={},j[V.id]=ot);let Q=ot[B];return Q===void 0&&(Q=b(f()),ot[B]=Q),Q}function b(D){const V=[],G=[],B=[];for(let j=0;j<i;j++)V[j]=0,G[j]=0,B[j]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:V,enabledAttributes:G,attributeDivisors:B,object:D,attributes:{},index:null}}function w(D,V){const G=h.attributes,B=D.attributes;let j=0;for(const ot in B){const Q=G[ot],ut=B[ot];if(Q===void 0||Q.attribute!==ut||Q.data!==ut.data)return!0;j++}return h.attributesNum!==j||h.index!==V}function _(D,V){const G={},B=D.attributes;let j=0;for(const ot in B){const Q=B[ot],ut={};ut.attribute=Q,Q.data&&(ut.data=Q.data),G[ot]=ut,j++}h.attributes=G,h.attributesNum=j,h.index=V}function y(){const D=h.newAttributes;for(let V=0,G=D.length;V<G;V++)D[V]=0}function M(D){T(D,0)}function T(D,V){const G=h.newAttributes,B=h.enabledAttributes,j=h.attributeDivisors;G[D]=1,B[D]===0&&(r.enableVertexAttribArray(D),B[D]=1),j[D]!==V&&((n.isWebGL2?r:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](D,V),j[D]=V)}function A(){const D=h.newAttributes,V=h.enabledAttributes;for(let G=0,B=V.length;G<B;G++)V[G]!==D[G]&&(r.disableVertexAttribArray(G),V[G]=0)}function E(D,V,G,B,j,ot){n.isWebGL2===!0&&(G===5124||G===5125)?r.vertexAttribIPointer(D,V,G,j,ot):r.vertexAttribPointer(D,V,G,B,j,ot)}function P(D,V,G,B){if(n.isWebGL2===!1&&(D.isInstancedMesh||B.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;y();const j=B.attributes,ot=G.getAttributes(),Q=V.defaultAttributeValues;for(const ut in ot){const rt=ot[ut];if(rt>=0){const Tt=j[ut];if(Tt!==void 0){const ct=Tt.normalized,ft=Tt.itemSize,Ft=e.get(Tt);if(Ft===void 0)continue;const K=Ft.buffer,Ot=Ft.type,Dt=Ft.bytesPerElement;if(Tt.isInterleavedBufferAttribute){const Mt=Tt.data,bt=Mt.stride,Nt=Tt.offset;Mt&&Mt.isInstancedInterleavedBuffer?(T(rt,Mt.meshPerAttribute),B._maxInstanceCount===void 0&&(B._maxInstanceCount=Mt.meshPerAttribute*Mt.count)):M(rt),r.bindBuffer(34962,K),E(rt,ft,Ot,ct,bt*Dt,Nt*Dt)}else Tt.isInstancedBufferAttribute?(T(rt,Tt.meshPerAttribute),B._maxInstanceCount===void 0&&(B._maxInstanceCount=Tt.meshPerAttribute*Tt.count)):M(rt),r.bindBuffer(34962,K),E(rt,ft,Ot,ct,0,0)}else if(ut==="instanceMatrix"){const ct=e.get(D.instanceMatrix);if(ct===void 0)continue;const ft=ct.buffer,Ft=ct.type;T(rt+0,1),T(rt+1,1),T(rt+2,1),T(rt+3,1),r.bindBuffer(34962,ft),r.vertexAttribPointer(rt+0,4,Ft,!1,64,0),r.vertexAttribPointer(rt+1,4,Ft,!1,64,16),r.vertexAttribPointer(rt+2,4,Ft,!1,64,32),r.vertexAttribPointer(rt+3,4,Ft,!1,64,48)}else if(ut==="instanceColor"){const ct=e.get(D.instanceColor);if(ct===void 0)continue;const ft=ct.buffer,Ft=ct.type;T(rt,1),r.bindBuffer(34962,ft),r.vertexAttribPointer(rt,3,Ft,!1,12,0)}else if(Q!==void 0){const ct=Q[ut];if(ct!==void 0)switch(ct.length){case 2:r.vertexAttrib2fv(rt,ct);break;case 3:r.vertexAttrib3fv(rt,ct);break;case 4:r.vertexAttrib4fv(rt,ct);break;default:r.vertexAttrib1fv(rt,ct)}}}}A()}function I(){W();for(const D in l){const V=l[D];for(const G in V){const B=V[G];for(const j in B)v(B[j].object),delete B[j];delete V[G]}delete l[D]}}function N(D){if(l[D.id]===void 0)return;const V=l[D.id];for(const G in V){const B=V[G];for(const j in B)v(B[j].object),delete B[j];delete V[G]}delete l[D.id]}function z(D){for(const V in l){const G=l[V];if(G[D.id]===void 0)continue;const B=G[D.id];for(const j in B)v(B[j].object),delete B[j];delete G[D.id]}}function W(){H(),h!==u&&(h=u,m(h.object))}function H(){u.geometry=null,u.program=null,u.wireframe=!1}return{setup:p,reset:W,resetDefaultState:H,dispose:I,releaseStatesOfGeometry:N,releaseStatesOfProgram:z,initAttributes:y,enableAttribute:M,disableUnusedAttributes:A}}function zy(r,t,e,n){const i=n.isWebGL2;let s;function a(h){s=h}function l(h,p){r.drawArrays(s,h,p),e.update(p,s,1)}function u(h,p,f){if(f===0)return;let m,v;if(i)m=r,v="drawArraysInstanced";else if(m=t.get("ANGLE_instanced_arrays"),v="drawArraysInstancedANGLE",m===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[v](s,h,p,f),e.update(p,s,f)}this.setMode=a,this.render=l,this.renderInstances=u}function Uy(r,t,e){let n;function i(){if(n!==void 0)return n;if(t.has("EXT_texture_filter_anisotropic")===!0){const P=t.get("EXT_texture_filter_anisotropic");n=r.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(P){if(P==="highp"){if(r.getShaderPrecisionFormat(35633,36338).precision>0&&r.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";P="mediump"}return P==="mediump"&&r.getShaderPrecisionFormat(35633,36337).precision>0&&r.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext!="undefined"&&r instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&r instanceof WebGL2ComputeRenderingContext;let l=e.precision!==void 0?e.precision:"highp";const u=s(l);u!==l&&(console.warn("THREE.WebGLRenderer:",l,"not supported, using",u,"instead."),l=u);const h=a||t.has("WEBGL_draw_buffers"),p=e.logarithmicDepthBuffer===!0,f=r.getParameter(34930),m=r.getParameter(35660),v=r.getParameter(3379),x=r.getParameter(34076),b=r.getParameter(34921),w=r.getParameter(36347),_=r.getParameter(36348),y=r.getParameter(36349),M=m>0,T=a||t.has("OES_texture_float"),A=M&&T,E=a?r.getParameter(36183):0;return{isWebGL2:a,drawBuffers:h,getMaxAnisotropy:i,getMaxPrecision:s,precision:l,logarithmicDepthBuffer:p,maxTextures:f,maxVertexTextures:m,maxTextureSize:v,maxCubemapSize:x,maxAttributes:b,maxVertexUniforms:w,maxVaryings:_,maxFragmentUniforms:y,vertexTextures:M,floatFragmentTextures:T,floatVertexTextures:A,maxSamples:E}}function Hy(r){const t=this;let e=null,n=0,i=!1,s=!1;const a=new qe,l=new Ae,u={value:null,needsUpdate:!1};this.uniform=u,this.numPlanes=0,this.numIntersection=0,this.init=function(f,m,v){const x=f.length!==0||m||n!==0||i;return i=m,e=p(f,v,0),n=f.length,x},this.beginShadows=function(){s=!0,p(null)},this.endShadows=function(){s=!1,h()},this.setState=function(f,m,v){const x=f.clippingPlanes,b=f.clipIntersection,w=f.clipShadows,_=r.get(f);if(!i||x===null||x.length===0||s&&!w)s?p(null):h();else{const y=s?0:n,M=y*4;let T=_.clippingState||null;u.value=T,T=p(x,m,M,v);for(let A=0;A!==M;++A)T[A]=e[A];_.clippingState=T,this.numIntersection=b?this.numPlanes:0,this.numPlanes+=y}};function h(){u.value!==e&&(u.value=e,u.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function p(f,m,v,x){const b=f!==null?f.length:0;let w=null;if(b!==0){if(w=u.value,x!==!0||w===null){const _=v+b*4,y=m.matrixWorldInverse;l.getNormalMatrix(y),(w===null||w.length<_)&&(w=new Float32Array(_));for(let M=0,T=v;M!==b;++M,T+=4)a.copy(f[M]).applyMatrix4(y,l),a.normal.toArray(w,T),w[T+3]=a.constant}u.value=w,u.needsUpdate=!0}return t.numPlanes=b,t.numIntersection=0,w}}function Gy(r){let t=new WeakMap;function e(a,l){return l===Ku?a.mapping=oc:l===$u&&(a.mapping=ac),a}function n(a){if(a&&a.isTexture){const l=a.mapping;if(l===Ku||l===$u)if(t.has(a)){const u=t.get(a).texture;return e(u,a.mapping)}else{const u=a.image;if(u&&u.height>0){const h=r.getRenderTarget(),p=new rp(u.height/2);return p.fromEquirectangularTexture(r,a),t.set(a,p),r.setRenderTarget(h),a.addEventListener("dispose",i),e(p.texture,a.mapping)}else return null}}return a}function i(a){const l=a.target;l.removeEventListener("dispose",i);const u=t.get(l);u!==void 0&&(t.delete(l),u.dispose())}function s(){t=new WeakMap}return{get:n,dispose:s}}function Wy(r){const t={};function e(n){if(t[n]!==void 0)return t[n];let i;switch(n){case"WEBGL_depth_texture":i=r.getExtension("WEBGL_depth_texture")||r.getExtension("MOZ_WEBGL_depth_texture")||r.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=r.getExtension("EXT_texture_filter_anisotropic")||r.getExtension("MOZ_EXT_texture_filter_anisotropic")||r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=r.getExtension("WEBGL_compressed_texture_s3tc")||r.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=r.getExtension("WEBGL_compressed_texture_pvrtc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=r.getExtension(n)}return t[n]=i,i}return{has:function(n){return e(n)!==null},init:function(n){n.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float")},get:function(n){const i=e(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function jy(r,t,e,n){const i={},s=new WeakMap;function a(f){const m=f.target;m.index!==null&&t.remove(m.index);for(const x in m.attributes)t.remove(m.attributes[x]);m.removeEventListener("dispose",a),delete i[m.id];const v=s.get(m);v&&(t.remove(v),s.delete(m)),n.releaseStatesOfGeometry(m),m.isInstancedBufferGeometry===!0&&delete m._maxInstanceCount,e.memory.geometries--}function l(f,m){return i[m.id]===!0||(m.addEventListener("dispose",a),i[m.id]=!0,e.memory.geometries++),m}function u(f){const m=f.attributes;for(const x in m)t.update(m[x],34962);const v=f.morphAttributes;for(const x in v){const b=v[x];for(let w=0,_=b.length;w<_;w++)t.update(b[w],34962)}}function h(f){const m=[],v=f.index,x=f.attributes.position;let b=0;if(v!==null){const y=v.array;b=v.version;for(let M=0,T=y.length;M<T;M+=3){const A=y[M+0],E=y[M+1],P=y[M+2];m.push(A,E,E,P,P,A)}}else{const y=x.array;b=x.version;for(let M=0,T=y.length/3-1;M<T;M+=3){const A=M+0,E=M+1,P=M+2;m.push(A,E,E,P,P,A)}}const w=new(sp(m)>65535?ip:np)(m,1);w.version=b;const _=s.get(f);_&&t.remove(_),s.set(f,w)}function p(f){const m=s.get(f);if(m){const v=f.index;v!==null&&m.version<v.version&&h(f)}else h(f);return s.get(f)}return{get:l,update:u,getWireframeAttribute:p}}function Xy(r,t,e,n){const i=n.isWebGL2;let s;function a(m){s=m}let l,u;function h(m){l=m.type,u=m.bytesPerElement}function p(m,v){r.drawElements(s,v,l,m*u),e.update(v,s,1)}function f(m,v,x){if(x===0)return;let b,w;if(i)b=r,w="drawElementsInstanced";else if(b=t.get("ANGLE_instanced_arrays"),w="drawElementsInstancedANGLE",b===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}b[w](s,v,l,m*u,x),e.update(v,s,x)}this.setMode=a,this.setIndex=h,this.render=p,this.renderInstances=f}function qy(r){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,a,l){switch(e.calls++,a){case 4:e.triangles+=l*(s/3);break;case 1:e.lines+=l*(s/2);break;case 3:e.lines+=l*(s-1);break;case 2:e.lines+=l*s;break;case 0:e.points+=l*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:i,update:n}}function Yy(r,t){return r[0]-t[0]}function Zy(r,t){return Math.abs(t[1])-Math.abs(r[1])}function Ky(r){const t={},e=new Float32Array(8),n=[];for(let s=0;s<8;s++)n[s]=[s,0];function i(s,a,l,u){const h=s.morphTargetInfluences,p=h===void 0?0:h.length;let f=t[a.id];if(f===void 0){f=[];for(let w=0;w<p;w++)f[w]=[w,0];t[a.id]=f}for(let w=0;w<p;w++){const _=f[w];_[0]=w,_[1]=h[w]}f.sort(Zy);for(let w=0;w<8;w++)w<p&&f[w][1]?(n[w][0]=f[w][0],n[w][1]=f[w][1]):(n[w][0]=Number.MAX_SAFE_INTEGER,n[w][1]=0);n.sort(Yy);const m=l.morphTargets&&a.morphAttributes.position,v=l.morphNormals&&a.morphAttributes.normal;let x=0;for(let w=0;w<8;w++){const _=n[w],y=_[0],M=_[1];y!==Number.MAX_SAFE_INTEGER&&M?(m&&a.getAttribute("morphTarget"+w)!==m[y]&&a.setAttribute("morphTarget"+w,m[y]),v&&a.getAttribute("morphNormal"+w)!==v[y]&&a.setAttribute("morphNormal"+w,v[y]),e[w]=M,x+=M):(m&&a.hasAttribute("morphTarget"+w)===!0&&a.deleteAttribute("morphTarget"+w),v&&a.hasAttribute("morphNormal"+w)===!0&&a.deleteAttribute("morphNormal"+w),e[w]=0)}const b=a.morphTargetsRelative?1:1-x;u.getUniforms().setValue(r,"morphTargetBaseInfluence",b),u.getUniforms().setValue(r,"morphTargetInfluences",e)}return{update:i}}function $y(r,t,e,n){let i=new WeakMap;function s(u){const h=n.render.frame,p=u.geometry,f=t.get(u,p);return i.get(f)!==h&&(t.update(f),i.set(f,h)),u.isInstancedMesh&&(u.hasEventListener("dispose",l)===!1&&u.addEventListener("dispose",l),e.update(u.instanceMatrix,34962),u.instanceColor!==null&&e.update(u.instanceColor,34962)),f}function a(){i=new WeakMap}function l(u){const h=u.target;h.removeEventListener("dispose",l),e.remove(h.instanceMatrix),h.instanceColor!==null&&e.remove(h.instanceColor)}return{update:s,dispose:a}}class ap extends Ce{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=oe,this.minFilter=oe,this.wrapR=Ve,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}ap.prototype.isDataTexture2DArray=!0;class lp extends Ce{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=oe,this.minFilter=oe,this.wrapR=Ve,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}lp.prototype.isDataTexture3D=!0;const cp=new Ce,Jy=new ap,Qy=new lp,up=new da,yh=[],bh=[],wh=new Float32Array(16),Mh=new Float32Array(9),Eh=new Float32Array(4);function Vs(r,t,e){const n=r[0];if(n<=0||n>0)return r;const i=t*e;let s=yh[i];if(s===void 0&&(s=new Float32Array(i),yh[i]=s),t!==0){n.toArray(s,0);for(let a=1,l=0;a!==t;++a)l+=e,r[a].toArray(s,l)}return s}function ke(r,t){if(r.length!==t.length)return!1;for(let e=0,n=r.length;e<n;e++)if(r[e]!==t[e])return!1;return!0}function Ie(r,t){for(let e=0,n=t.length;e<n;e++)r[e]=t[e]}function hp(r,t){let e=bh[t];e===void 0&&(e=new Int32Array(t),bh[t]=e);for(let n=0;n!==t;++n)e[n]=r.allocateTextureUnit();return e}function tb(r,t){const e=this.cache;e[0]!==t&&(r.uniform1f(this.addr,t),e[0]=t)}function eb(r,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(r.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(ke(e,t))return;r.uniform2fv(this.addr,t),Ie(e,t)}}function nb(r,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(r.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(r.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(ke(e,t))return;r.uniform3fv(this.addr,t),Ie(e,t)}}function ib(r,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(r.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(ke(e,t))return;r.uniform4fv(this.addr,t),Ie(e,t)}}function sb(r,t){const e=this.cache,n=t.elements;if(n===void 0){if(ke(e,t))return;r.uniformMatrix2fv(this.addr,!1,t),Ie(e,t)}else{if(ke(e,n))return;Eh.set(n),r.uniformMatrix2fv(this.addr,!1,Eh),Ie(e,n)}}function rb(r,t){const e=this.cache,n=t.elements;if(n===void 0){if(ke(e,t))return;r.uniformMatrix3fv(this.addr,!1,t),Ie(e,t)}else{if(ke(e,n))return;Mh.set(n),r.uniformMatrix3fv(this.addr,!1,Mh),Ie(e,n)}}function ob(r,t){const e=this.cache,n=t.elements;if(n===void 0){if(ke(e,t))return;r.uniformMatrix4fv(this.addr,!1,t),Ie(e,t)}else{if(ke(e,n))return;wh.set(n),r.uniformMatrix4fv(this.addr,!1,wh),Ie(e,n)}}function ab(r,t){const e=this.cache;e[0]!==t&&(r.uniform1i(this.addr,t),e[0]=t)}function lb(r,t){const e=this.cache;ke(e,t)||(r.uniform2iv(this.addr,t),Ie(e,t))}function cb(r,t){const e=this.cache;ke(e,t)||(r.uniform3iv(this.addr,t),Ie(e,t))}function ub(r,t){const e=this.cache;ke(e,t)||(r.uniform4iv(this.addr,t),Ie(e,t))}function hb(r,t){const e=this.cache;e[0]!==t&&(r.uniform1ui(this.addr,t),e[0]=t)}function db(r,t){const e=this.cache;ke(e,t)||(r.uniform2uiv(this.addr,t),Ie(e,t))}function pb(r,t){const e=this.cache;ke(e,t)||(r.uniform3uiv(this.addr,t),Ie(e,t))}function fb(r,t){const e=this.cache;ke(e,t)||(r.uniform4uiv(this.addr,t),Ie(e,t))}function mb(r,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),e.safeSetTexture2D(t||cp,i)}function gb(r,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),e.setTexture3D(t||Qy,i)}function vb(r,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),e.safeSetTextureCube(t||up,i)}function _b(r,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),e.setTexture2DArray(t||Jy,i)}function xb(r){switch(r){case 5126:return tb;case 35664:return eb;case 35665:return nb;case 35666:return ib;case 35674:return sb;case 35675:return rb;case 35676:return ob;case 5124:case 35670:return ab;case 35667:case 35671:return lb;case 35668:case 35672:return cb;case 35669:case 35673:return ub;case 5125:return hb;case 36294:return db;case 36295:return pb;case 36296:return fb;case 35678:case 36198:case 36298:case 36306:case 35682:return mb;case 35679:case 36299:case 36307:return gb;case 35680:case 36300:case 36308:case 36293:return vb;case 36289:case 36303:case 36311:case 36292:return _b}}function yb(r,t){r.uniform1fv(this.addr,t)}function bb(r,t){const e=Vs(t,this.size,2);r.uniform2fv(this.addr,e)}function wb(r,t){const e=Vs(t,this.size,3);r.uniform3fv(this.addr,e)}function Mb(r,t){const e=Vs(t,this.size,4);r.uniform4fv(this.addr,e)}function Eb(r,t){const e=Vs(t,this.size,4);r.uniformMatrix2fv(this.addr,!1,e)}function Sb(r,t){const e=Vs(t,this.size,9);r.uniformMatrix3fv(this.addr,!1,e)}function Tb(r,t){const e=Vs(t,this.size,16);r.uniformMatrix4fv(this.addr,!1,e)}function Ab(r,t){r.uniform1iv(this.addr,t)}function Cb(r,t){r.uniform2iv(this.addr,t)}function Pb(r,t){r.uniform3iv(this.addr,t)}function Lb(r,t){r.uniform4iv(this.addr,t)}function Rb(r,t){r.uniform1uiv(this.addr,t)}function Ib(r,t){r.uniform2uiv(this.addr,t)}function Db(r,t){r.uniform3uiv(this.addr,t)}function Nb(r,t){r.uniform4uiv(this.addr,t)}function Fb(r,t,e){const n=t.length,i=hp(e,n);r.uniform1iv(this.addr,i);for(let s=0;s!==n;++s)e.safeSetTexture2D(t[s]||cp,i[s])}function kb(r,t,e){const n=t.length,i=hp(e,n);r.uniform1iv(this.addr,i);for(let s=0;s!==n;++s)e.safeSetTextureCube(t[s]||up,i[s])}function Bb(r){switch(r){case 5126:return yb;case 35664:return bb;case 35665:return wb;case 35666:return Mb;case 35674:return Eb;case 35675:return Sb;case 35676:return Tb;case 5124:case 35670:return Ab;case 35667:case 35671:return Cb;case 35668:case 35672:return Pb;case 35669:case 35673:return Lb;case 5125:return Rb;case 36294:return Ib;case 36295:return Db;case 36296:return Nb;case 35678:case 36198:case 36298:case 36306:case 35682:return Fb;case 35680:case 36300:case 36308:case 36293:return kb}}function Ob(r,t,e){this.id=r,this.addr=e,this.cache=[],this.setValue=xb(t.type)}function dp(r,t,e){this.id=r,this.addr=e,this.cache=[],this.size=t.size,this.setValue=Bb(t.type)}dp.prototype.updateCache=function(r){const t=this.cache;r instanceof Float32Array&&t.length!==r.length&&(this.cache=new Float32Array(r.length)),Ie(t,r)};function pp(r){this.id=r,this.seq=[],this.map={}}pp.prototype.setValue=function(r,t,e){const n=this.seq;for(let i=0,s=n.length;i!==s;++i){const a=n[i];a.setValue(r,t[a.id],e)}};const _l=/(\w+)(\])?(\[|\.)?/g;function Sh(r,t){r.seq.push(t),r.map[t.id]=t}function Vb(r,t,e){const n=r.name,i=n.length;for(_l.lastIndex=0;;){const s=_l.exec(n),a=_l.lastIndex;let l=s[1];const u=s[2]==="]",h=s[3];if(u&&(l=l|0),h===void 0||h==="["&&a+2===i){Sh(e,h===void 0?new Ob(l,r,t):new dp(l,r,t));break}else{let f=e.map[l];f===void 0&&(f=new pp(l),Sh(e,f)),e=f}}}function ci(r,t){this.seq=[],this.map={};const e=r.getProgramParameter(t,35718);for(let n=0;n<e;++n){const i=r.getActiveUniform(t,n),s=r.getUniformLocation(t,i.name);Vb(i,s,this)}}ci.prototype.setValue=function(r,t,e,n){const i=this.map[t];i!==void 0&&i.setValue(r,e,n)};ci.prototype.setOptional=function(r,t,e){const n=t[e];n!==void 0&&this.setValue(r,e,n)};ci.upload=function(r,t,e,n){for(let i=0,s=t.length;i!==s;++i){const a=t[i],l=e[a.id];l.needsUpdate!==!1&&a.setValue(r,l.value,n)}};ci.seqWithValue=function(r,t){const e=[];for(let n=0,i=r.length;n!==i;++n){const s=r[n];s.id in t&&e.push(s)}return e};function Th(r,t,e){const n=r.createShader(t);return r.shaderSource(n,e),r.compileShader(n),n}let zb=0;function Ub(r){const t=r.split(`
`);for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join(`
`)}function fp(r){switch(r){case Yr:return["Linear","( value )"];case Br:return["sRGB","( value )"];case C_:return["RGBE","( value )"];case L_:return["RGBM","( value, 7.0 )"];case R_:return["RGBM","( value, 16.0 )"];case I_:return["RGBD","( value, 256.0 )"];case A_:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case P_:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",r),["Linear","( value )"]}}function Ah(r,t,e){const n=r.getShaderParameter(t,35713),i=r.getShaderInfoLog(t).trim();if(n&&i==="")return"";const s=r.getShaderSource(t);return"THREE.WebGLShader: gl.getShaderInfoLog() "+e+`
`+i+Ub(s)}function lr(r,t){const e=fp(t);return"vec4 "+r+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function Hb(r,t){const e=fp(t);return"vec4 "+r+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function Gb(r,t){let e;switch(t){case Fv:e="Linear";break;case kv:e="Reinhard";break;case Bv:e="OptimizedCineon";break;case Ov:e="ACESFilmic";break;case Vv:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+r+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function Wb(r){return[r.extensionDerivatives||r.envMapCubeUV||r.bumpMap||r.tangentSpaceNormalMap||r.clearcoatNormalMap||r.flatShading||r.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(r.extensionFragDepth||r.logarithmicDepthBuffer)&&r.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",r.extensionDrawBuffers&&r.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(r.extensionShaderTextureLOD||r.envMap||r.transmission>0)&&r.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(wr).join(`
`)}function jb(r){const t=[];for(const e in r){const n=r[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function Xb(r,t){const e={},n=r.getProgramParameter(t,35721);for(let i=0;i<n;i++){const a=r.getActiveAttrib(t,i).name;e[a]=r.getAttribLocation(t,a)}return e}function wr(r){return r!==""}function Ch(r,t){return r.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Ph(r,t){return r.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const qb=/^[ \t]*#include +<([\w\d./]+)>/gm;function Hl(r){return r.replace(qb,Yb)}function Yb(r,t){const e=Ut[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return Hl(e)}const Zb=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Kb=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Lh(r){return r.replace(Kb,mp).replace(Zb,$b)}function $b(r,t,e,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),mp(r,t,e,n)}function mp(r,t,e,n){let i="";for(let s=parseInt(t);s<parseInt(e);s++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function Rh(r){let t="precision "+r.precision+` float;
precision `+r.precision+" int;";return r.precision==="highp"?t+=`
#define HIGH_PRECISION`:r.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:r.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function Jb(r){let t="SHADOWMAP_TYPE_BASIC";return r.shadowMapType===Vd?t="SHADOWMAP_TYPE_PCF":r.shadowMapType===pv?t="SHADOWMAP_TYPE_PCF_SOFT":r.shadowMapType===br&&(t="SHADOWMAP_TYPE_VSM"),t}function Qb(r){let t="ENVMAP_TYPE_CUBE";if(r.envMap)switch(r.envMapMode){case oc:case ac:t="ENVMAP_TYPE_CUBE";break;case lc:case cc:t="ENVMAP_TYPE_CUBE_UV";break}return t}function tw(r){let t="ENVMAP_MODE_REFLECTION";if(r.envMap)switch(r.envMapMode){case ac:case cc:t="ENVMAP_MODE_REFRACTION";break}return t}function ew(r){let t="ENVMAP_BLENDING_NONE";if(r.envMap)switch(r.combine){case ha:t="ENVMAP_BLENDING_MULTIPLY";break;case Dv:t="ENVMAP_BLENDING_MIX";break;case Nv:t="ENVMAP_BLENDING_ADD";break}return t}function nw(r,t,e,n){const i=r.getContext(),s=e.defines;let a=e.vertexShader,l=e.fragmentShader;const u=Jb(e),h=Qb(e),p=tw(e),f=ew(e),m=r.gammaFactor>0?r.gammaFactor:1,v=e.isWebGL2?"":Wb(e),x=jb(s),b=i.createProgram();let w,_,y=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(w=[x].filter(wr).join(`
`),w.length>0&&(w+=`
`),_=[v,x].filter(wr).join(`
`),_.length>0&&(_+=`
`)):(w=[Rh(e),"#define SHADER_NAME "+e.shaderName,x,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+m,"#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+p:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+u:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(wr).join(`
`),_=[v,Rh(e),"#define SHADER_NAME "+e.shaderName,x,e.alphaTest?"#define ALPHATEST "+e.alphaTest+(e.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+m,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+h:"",e.envMap?"#define "+p:"",e.envMap?"#define "+f:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.sheen?"#define USE_SHEEN":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+u:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==Tr?"#define TONE_MAPPING":"",e.toneMapping!==Tr?Ut.tonemapping_pars_fragment:"",e.toneMapping!==Tr?Gb("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",Ut.encodings_pars_fragment,e.map?lr("mapTexelToLinear",e.mapEncoding):"",e.matcap?lr("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?lr("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?lr("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.lightMap?lr("lightMapTexelToLinear",e.lightMapEncoding):"",Hb("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(wr).join(`
`)),a=Hl(a),a=Ch(a,e),a=Ph(a,e),l=Hl(l),l=Ch(l,e),l=Ph(l,e),a=Lh(a),l=Lh(l),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(y=`#version 300 es
`,w=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+w,_=["#define varying in",e.glslVersion===lh?"":"out highp vec4 pc_fragColor;",e.glslVersion===lh?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+_);const M=y+w+a,T=y+_+l,A=Th(i,35633,M),E=Th(i,35632,T);if(i.attachShader(b,A),i.attachShader(b,E),e.index0AttributeName!==void 0?i.bindAttribLocation(b,0,e.index0AttributeName):e.morphTargets===!0&&i.bindAttribLocation(b,0,"position"),i.linkProgram(b),r.debug.checkShaderErrors){const N=i.getProgramInfoLog(b).trim(),z=i.getShaderInfoLog(A).trim(),W=i.getShaderInfoLog(E).trim();let H=!0,D=!0;if(i.getProgramParameter(b,35714)===!1){H=!1;const V=Ah(i,A,"vertex"),G=Ah(i,E,"fragment");console.error("THREE.WebGLProgram: shader error: ",i.getError(),"35715",i.getProgramParameter(b,35715),"gl.getProgramInfoLog",N,V,G)}else N!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",N):(z===""||W==="")&&(D=!1);D&&(this.diagnostics={runnable:H,programLog:N,vertexShader:{log:z,prefix:w},fragmentShader:{log:W,prefix:_}})}i.deleteShader(A),i.deleteShader(E);let P;this.getUniforms=function(){return P===void 0&&(P=new ci(i,b)),P};let I;return this.getAttributes=function(){return I===void 0&&(I=Xb(i,b)),I},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(b),this.program=void 0},this.name=e.shaderName,this.id=zb++,this.cacheKey=t,this.usedTimes=1,this.program=b,this.vertexShader=A,this.fragmentShader=E,this}function iw(r,t,e,n,i,s){const a=[],l=n.isWebGL2,u=n.logarithmicDepthBuffer,h=n.floatVertexTextures,p=n.maxVertexUniforms,f=n.vertexTextures;let m=n.precision;const v={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},x=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmission","transmissionMap","thicknessMap"];function b(E){const I=E.skeleton.bones;if(h)return 1024;{const z=Math.floor((p-20)/4),W=Math.min(z,I.length);return W<I.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+I.length+" bones. This GPU supports "+W+"."),0):W}}function w(E){let P;return E&&E.isTexture?P=E.encoding:E&&E.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),P=E.texture.encoding):P=Yr,P}function _(E,P,I,N,z){const W=N.fog,H=E.isMeshStandardMaterial?N.environment:null,D=t.get(E.envMap||H),V=v[E.type],G=z.isSkinnedMesh?b(z):0;E.precision!==null&&(m=n.getMaxPrecision(E.precision),m!==E.precision&&console.warn("THREE.WebGLProgram.getParameters:",E.precision,"not supported, using",m,"instead."));let B,j;if(V){const ut=gn[V];B=ut.vertexShader,j=ut.fragmentShader}else B=E.vertexShader,j=E.fragmentShader;const ot=r.getRenderTarget();return{isWebGL2:l,shaderID:V,shaderName:E.type,vertexShader:B,fragmentShader:j,defines:E.defines,isRawShaderMaterial:E.isRawShaderMaterial===!0,glslVersion:E.glslVersion,precision:m,instancing:z.isInstancedMesh===!0,instancingColor:z.isInstancedMesh===!0&&z.instanceColor!==null,supportsVertexTextures:f,outputEncoding:ot!==null?w(ot.texture):r.outputEncoding,map:!!E.map,mapEncoding:w(E.map),matcap:!!E.matcap,matcapEncoding:w(E.matcap),envMap:!!D,envMapMode:D&&D.mapping,envMapEncoding:w(D),envMapCubeUV:!!D&&(D.mapping===lc||D.mapping===cc),lightMap:!!E.lightMap,lightMapEncoding:w(E.lightMap),aoMap:!!E.aoMap,emissiveMap:!!E.emissiveMap,emissiveMapEncoding:w(E.emissiveMap),bumpMap:!!E.bumpMap,normalMap:!!E.normalMap,objectSpaceNormalMap:E.normalMapType===F_,tangentSpaceNormalMap:E.normalMapType===Di,clearcoatMap:!!E.clearcoatMap,clearcoatRoughnessMap:!!E.clearcoatRoughnessMap,clearcoatNormalMap:!!E.clearcoatNormalMap,displacementMap:!!E.displacementMap,roughnessMap:!!E.roughnessMap,metalnessMap:!!E.metalnessMap,specularMap:!!E.specularMap,alphaMap:!!E.alphaMap,gradientMap:!!E.gradientMap,sheen:!!E.sheen,transmission:!!E.transmission,transmissionMap:!!E.transmissionMap,thicknessMap:!!E.thicknessMap,combine:E.combine,vertexTangents:E.normalMap&&E.vertexTangents,vertexColors:E.vertexColors,vertexAlphas:E.vertexColors===!0&&z.geometry&&z.geometry.attributes.color&&z.geometry.attributes.color.itemSize===4,vertexUvs:!!E.map||!!E.bumpMap||!!E.normalMap||!!E.specularMap||!!E.alphaMap||!!E.emissiveMap||!!E.roughnessMap||!!E.metalnessMap||!!E.clearcoatMap||!!E.clearcoatRoughnessMap||!!E.clearcoatNormalMap||!!E.displacementMap||!!E.transmission||!!E.transmissionMap||!!E.thicknessMap,uvsVertexOnly:!(!!E.map||!!E.bumpMap||!!E.normalMap||!!E.specularMap||!!E.alphaMap||!!E.emissiveMap||!!E.roughnessMap||!!E.metalnessMap||!!E.clearcoatNormalMap||!!E.transmission||!!E.transmissionMap||!!E.thicknessMap)&&!!E.displacementMap,fog:!!W,useFog:E.fog,fogExp2:W&&W.isFogExp2,flatShading:!!E.flatShading,sizeAttenuation:E.sizeAttenuation,logarithmicDepthBuffer:u,skinning:z.isSkinnedMesh===!0&&G>0,maxBones:G,useVertexTexture:h,morphTargets:E.morphTargets,morphNormals:E.morphNormals,numDirLights:P.directional.length,numPointLights:P.point.length,numSpotLights:P.spot.length,numRectAreaLights:P.rectArea.length,numHemiLights:P.hemi.length,numDirLightShadows:P.directionalShadowMap.length,numPointLightShadows:P.pointShadowMap.length,numSpotLightShadows:P.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:E.dithering,shadowMapEnabled:r.shadowMap.enabled&&I.length>0,shadowMapType:r.shadowMap.type,toneMapping:E.toneMapped?r.toneMapping:Tr,physicallyCorrectLights:r.physicallyCorrectLights,premultipliedAlpha:E.premultipliedAlpha,alphaTest:E.alphaTest,doubleSided:E.side===on,flipSided:E.side===ye,depthPacking:E.depthPacking!==void 0?E.depthPacking:!1,index0AttributeName:E.index0AttributeName,extensionDerivatives:E.extensions&&E.extensions.derivatives,extensionFragDepth:E.extensions&&E.extensions.fragDepth,extensionDrawBuffers:E.extensions&&E.extensions.drawBuffers,extensionShaderTextureLOD:E.extensions&&E.extensions.shaderTextureLOD,rendererExtensionFragDepth:l||e.has("EXT_frag_depth"),rendererExtensionDrawBuffers:l||e.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:l||e.has("EXT_shader_texture_lod"),customProgramCacheKey:E.customProgramCacheKey()}}function y(E){const P=[];if(E.shaderID?P.push(E.shaderID):(P.push(E.fragmentShader),P.push(E.vertexShader)),E.defines!==void 0)for(const I in E.defines)P.push(I),P.push(E.defines[I]);if(E.isRawShaderMaterial===!1){for(let I=0;I<x.length;I++)P.push(E[x[I]]);P.push(r.outputEncoding),P.push(r.gammaFactor)}return P.push(E.customProgramCacheKey),P.join()}function M(E){const P=v[E.type];let I;if(P){const N=gn[P];I=p0.clone(N.uniforms)}else I=E.uniforms;return I}function T(E,P){let I;for(let N=0,z=a.length;N<z;N++){const W=a[N];if(W.cacheKey===P){I=W,++I.usedTimes;break}}return I===void 0&&(I=new nw(r,P,E,i),a.push(I)),I}function A(E){if(--E.usedTimes===0){const P=a.indexOf(E);a[P]=a[a.length-1],a.pop(),E.destroy()}}return{getParameters:_,getProgramCacheKey:y,getUniforms:M,acquireProgram:T,releaseProgram:A,programs:a}}function sw(){let r=new WeakMap;function t(s){let a=r.get(s);return a===void 0&&(a={},r.set(s,a)),a}function e(s){r.delete(s)}function n(s,a,l){r.get(s)[a]=l}function i(){r=new WeakMap}return{get:t,remove:e,update:n,dispose:i}}function rw(r,t){return r.groupOrder!==t.groupOrder?r.groupOrder-t.groupOrder:r.renderOrder!==t.renderOrder?r.renderOrder-t.renderOrder:r.program!==t.program?r.program.id-t.program.id:r.material.id!==t.material.id?r.material.id-t.material.id:r.z!==t.z?r.z-t.z:r.id-t.id}function Ih(r,t){return r.groupOrder!==t.groupOrder?r.groupOrder-t.groupOrder:r.renderOrder!==t.renderOrder?r.renderOrder-t.renderOrder:r.z!==t.z?t.z-r.z:r.id-t.id}function Dh(r){const t=[];let e=0;const n=[],i=[],s=[],a={id:-1};function l(){e=0,n.length=0,i.length=0,s.length=0}function u(v,x,b,w,_,y){let M=t[e];const T=r.get(b);return M===void 0?(M={id:v.id,object:v,geometry:x,material:b,program:T.program||a,groupOrder:w,renderOrder:v.renderOrder,z:_,group:y},t[e]=M):(M.id=v.id,M.object=v,M.geometry=x,M.material=b,M.program=T.program||a,M.groupOrder=w,M.renderOrder=v.renderOrder,M.z=_,M.group=y),e++,M}function h(v,x,b,w,_,y){const M=u(v,x,b,w,_,y);b.transmission>0?i.push(M):b.transparent===!0?s.push(M):n.push(M)}function p(v,x,b,w,_,y){const M=u(v,x,b,w,_,y);b.transmission>0?i.unshift(M):b.transparent===!0?s.unshift(M):n.unshift(M)}function f(v,x){n.length>1&&n.sort(v||rw),i.length>1&&i.sort(x||Ih),s.length>1&&s.sort(x||Ih)}function m(){for(let v=e,x=t.length;v<x;v++){const b=t[v];if(b.id===null)break;b.id=null,b.object=null,b.geometry=null,b.material=null,b.program=null,b.group=null}}return{opaque:n,transmissive:i,transparent:s,init:l,push:h,unshift:p,finish:m,sort:f}}function ow(r){let t=new WeakMap;function e(i,s){let a;return t.has(i)===!1?(a=new Dh(r),t.set(i,[a])):s>=t.get(i).length?(a=new Dh(r),t.get(i).push(a)):a=t.get(i)[s],a}function n(){t=new WeakMap}return{get:e,dispose:n}}function aw(){const r={};return{get:function(t){if(r[t.id]!==void 0)return r[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new C,color:new yt};break;case"SpotLight":e={position:new C,direction:new C,color:new yt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new C,color:new yt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new C,skyColor:new yt,groundColor:new yt};break;case"RectAreaLight":e={color:new yt,position:new C,halfWidth:new C,halfHeight:new C};break}return r[t.id]=e,e}}}function lw(){const r={};return{get:function(t){if(r[t.id]!==void 0)return r[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new nt};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new nt};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new nt,shadowCameraNear:1,shadowCameraFar:1e3};break}return r[t.id]=e,e}}}let cw=0;function uw(r,t){return(t.castShadow?1:0)-(r.castShadow?1:0)}function hw(r,t){const e=new aw,n=lw(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let p=0;p<9;p++)i.probe.push(new C);const s=new C,a=new Et,l=new Et;function u(p){let f=0,m=0,v=0;for(let P=0;P<9;P++)i.probe[P].set(0,0,0);let x=0,b=0,w=0,_=0,y=0,M=0,T=0,A=0;p.sort(uw);for(let P=0,I=p.length;P<I;P++){const N=p[P],z=N.color,W=N.intensity,H=N.distance,D=N.shadow&&N.shadow.map?N.shadow.map.texture:null;if(N.isAmbientLight)f+=z.r*W,m+=z.g*W,v+=z.b*W;else if(N.isLightProbe)for(let V=0;V<9;V++)i.probe[V].addScaledVector(N.sh.coefficients[V],W);else if(N.isDirectionalLight){const V=e.get(N);if(V.color.copy(N.color).multiplyScalar(N.intensity),N.castShadow){const G=N.shadow,B=n.get(N);B.shadowBias=G.bias,B.shadowNormalBias=G.normalBias,B.shadowRadius=G.radius,B.shadowMapSize=G.mapSize,i.directionalShadow[x]=B,i.directionalShadowMap[x]=D,i.directionalShadowMatrix[x]=N.shadow.matrix,M++}i.directional[x]=V,x++}else if(N.isSpotLight){const V=e.get(N);if(V.position.setFromMatrixPosition(N.matrixWorld),V.color.copy(z).multiplyScalar(W),V.distance=H,V.coneCos=Math.cos(N.angle),V.penumbraCos=Math.cos(N.angle*(1-N.penumbra)),V.decay=N.decay,N.castShadow){const G=N.shadow,B=n.get(N);B.shadowBias=G.bias,B.shadowNormalBias=G.normalBias,B.shadowRadius=G.radius,B.shadowMapSize=G.mapSize,i.spotShadow[w]=B,i.spotShadowMap[w]=D,i.spotShadowMatrix[w]=N.shadow.matrix,A++}i.spot[w]=V,w++}else if(N.isRectAreaLight){const V=e.get(N);V.color.copy(z).multiplyScalar(W),V.halfWidth.set(N.width*.5,0,0),V.halfHeight.set(0,N.height*.5,0),i.rectArea[_]=V,_++}else if(N.isPointLight){const V=e.get(N);if(V.color.copy(N.color).multiplyScalar(N.intensity),V.distance=N.distance,V.decay=N.decay,N.castShadow){const G=N.shadow,B=n.get(N);B.shadowBias=G.bias,B.shadowNormalBias=G.normalBias,B.shadowRadius=G.radius,B.shadowMapSize=G.mapSize,B.shadowCameraNear=G.camera.near,B.shadowCameraFar=G.camera.far,i.pointShadow[b]=B,i.pointShadowMap[b]=D,i.pointShadowMatrix[b]=N.shadow.matrix,T++}i.point[b]=V,b++}else if(N.isHemisphereLight){const V=e.get(N);V.skyColor.copy(N.color).multiplyScalar(W),V.groundColor.copy(N.groundColor).multiplyScalar(W),i.hemi[y]=V,y++}}_>0&&(t.isWebGL2||r.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=vt.LTC_FLOAT_1,i.rectAreaLTC2=vt.LTC_FLOAT_2):r.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=vt.LTC_HALF_1,i.rectAreaLTC2=vt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=f,i.ambient[1]=m,i.ambient[2]=v;const E=i.hash;(E.directionalLength!==x||E.pointLength!==b||E.spotLength!==w||E.rectAreaLength!==_||E.hemiLength!==y||E.numDirectionalShadows!==M||E.numPointShadows!==T||E.numSpotShadows!==A)&&(i.directional.length=x,i.spot.length=w,i.rectArea.length=_,i.point.length=b,i.hemi.length=y,i.directionalShadow.length=M,i.directionalShadowMap.length=M,i.pointShadow.length=T,i.pointShadowMap.length=T,i.spotShadow.length=A,i.spotShadowMap.length=A,i.directionalShadowMatrix.length=M,i.pointShadowMatrix.length=T,i.spotShadowMatrix.length=A,E.directionalLength=x,E.pointLength=b,E.spotLength=w,E.rectAreaLength=_,E.hemiLength=y,E.numDirectionalShadows=M,E.numPointShadows=T,E.numSpotShadows=A,i.version=cw++)}function h(p,f){let m=0,v=0,x=0,b=0,w=0;const _=f.matrixWorldInverse;for(let y=0,M=p.length;y<M;y++){const T=p[y];if(T.isDirectionalLight){const A=i.directional[m];A.direction.setFromMatrixPosition(T.matrixWorld),s.setFromMatrixPosition(T.target.matrixWorld),A.direction.sub(s),A.direction.transformDirection(_),m++}else if(T.isSpotLight){const A=i.spot[x];A.position.setFromMatrixPosition(T.matrixWorld),A.position.applyMatrix4(_),A.direction.setFromMatrixPosition(T.matrixWorld),s.setFromMatrixPosition(T.target.matrixWorld),A.direction.sub(s),A.direction.transformDirection(_),x++}else if(T.isRectAreaLight){const A=i.rectArea[b];A.position.setFromMatrixPosition(T.matrixWorld),A.position.applyMatrix4(_),l.identity(),a.copy(T.matrixWorld),a.premultiply(_),l.extractRotation(a),A.halfWidth.set(T.width*.5,0,0),A.halfHeight.set(0,T.height*.5,0),A.halfWidth.applyMatrix4(l),A.halfHeight.applyMatrix4(l),b++}else if(T.isPointLight){const A=i.point[v];A.position.setFromMatrixPosition(T.matrixWorld),A.position.applyMatrix4(_),v++}else if(T.isHemisphereLight){const A=i.hemi[w];A.direction.setFromMatrixPosition(T.matrixWorld),A.direction.transformDirection(_),A.direction.normalize(),w++}}}return{setup:u,setupView:h,state:i}}function Nh(r,t){const e=new hw(r,t),n=[],i=[];function s(){n.length=0,i.length=0}function a(f){n.push(f)}function l(f){i.push(f)}function u(){e.setup(n)}function h(f){e.setupView(n,f)}return{init:s,state:{lightsArray:n,shadowsArray:i,lights:e},setupLights:u,setupLightsView:h,pushLight:a,pushShadow:l}}function dw(r,t){let e=new WeakMap;function n(s,a=0){let l;return e.has(s)===!1?(l=new Nh(r,t),e.set(s,[l])):a>=e.get(s).length?(l=new Nh(r,t),e.get(s).push(l)):l=e.get(s)[a],l}function i(){e=new WeakMap}return{get:n,dispose:i}}class gp extends Me{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=D_,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}gp.prototype.isMeshDepthMaterial=!0;class vp extends Me{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new C,this.nearDistance=1,this.farDistance=1e3,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}vp.prototype.isMeshDistanceMaterial=!0;var pw=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,fw=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function _p(r,t,e){let n=new pa;const i=new nt,s=new nt,a=new ne,l=[],u=[],h={},p=e.maxTextureSize,f={0:ye,1:Ri,2:on},m=new yn({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new nt},radius:{value:4}},vertexShader:fw,fragmentShader:pw}),v=m.clone();v.defines.HORIZONTAL_PASS=1;const x=new Yt;x.setAttribute("position",new ae(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const b=new wt(x,m),w=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Vd,this.render=function(E,P,I){if(w.enabled===!1||w.autoUpdate===!1&&w.needsUpdate===!1||E.length===0)return;const N=r.getRenderTarget(),z=r.getActiveCubeFace(),W=r.getActiveMipmapLevel(),H=r.state;H.setBlending(Er),H.buffers.color.setClear(1,1,1,1),H.buffers.depth.setTest(!0),H.setScissorTest(!1);for(let D=0,V=E.length;D<V;D++){const G=E[D],B=G.shadow;if(B===void 0){console.warn("THREE.WebGLShadowMap:",G,"has no shadow.");continue}if(B.autoUpdate===!1&&B.needsUpdate===!1)continue;i.copy(B.mapSize);const j=B.getFrameExtents();if(i.multiply(j),s.copy(B.mapSize),(i.x>p||i.y>p)&&(i.x>p&&(s.x=Math.floor(p/j.x),i.x=s.x*j.x,B.mapSize.x=s.x),i.y>p&&(s.y=Math.floor(p/j.y),i.y=s.y*j.y,B.mapSize.y=s.y)),B.map===null&&!B.isPointLightShadow&&this.type===br){const Q={minFilter:Re,magFilter:Re,format:Fe};B.map=new rn(i.x,i.y,Q),B.map.texture.name=G.name+".shadowMap",B.mapPass=new rn(i.x,i.y,Q),B.camera.updateProjectionMatrix()}if(B.map===null){const Q={minFilter:oe,magFilter:oe,format:Fe};B.map=new rn(i.x,i.y,Q),B.map.texture.name=G.name+".shadowMap",B.camera.updateProjectionMatrix()}r.setRenderTarget(B.map),r.clear();const ot=B.getViewportCount();for(let Q=0;Q<ot;Q++){const ut=B.getViewport(Q);a.set(s.x*ut.x,s.y*ut.y,s.x*ut.z,s.y*ut.w),H.viewport(a),B.updateMatrices(G,Q),n=B.getFrustum(),A(P,I,B.camera,G,this.type)}!B.isPointLightShadow&&this.type===br&&_(B,I),B.needsUpdate=!1}w.needsUpdate=!1,r.setRenderTarget(N,z,W)};function _(E,P){const I=t.update(b);m.uniforms.shadow_pass.value=E.map.texture,m.uniforms.resolution.value=E.mapSize,m.uniforms.radius.value=E.radius,r.setRenderTarget(E.mapPass),r.clear(),r.renderBufferDirect(P,null,I,m,b,null),v.uniforms.shadow_pass.value=E.mapPass.texture,v.uniforms.resolution.value=E.mapSize,v.uniforms.radius.value=E.radius,r.setRenderTarget(E.map),r.clear(),r.renderBufferDirect(P,null,I,v,b,null)}function y(E){const P=E<<0;let I=l[P];return I===void 0&&(I=new gp({depthPacking:N_,morphTargets:E}),l[P]=I),I}function M(E){const P=E<<0;let I=u[P];return I===void 0&&(I=new vp({morphTargets:E}),u[P]=I),I}function T(E,P,I,N,z,W,H){let D=null,V=y,G=E.customDepthMaterial;if(N.isPointLight===!0&&(V=M,G=E.customDistanceMaterial),G===void 0){let B=!1;I.morphTargets===!0&&(B=P.morphAttributes&&P.morphAttributes.position&&P.morphAttributes.position.length>0),D=V(B)}else D=G;if(r.localClippingEnabled&&I.clipShadows===!0&&I.clippingPlanes.length!==0){const B=D.uuid,j=I.uuid;let ot=h[B];ot===void 0&&(ot={},h[B]=ot);let Q=ot[j];Q===void 0&&(Q=D.clone(),ot[j]=Q),D=Q}return D.visible=I.visible,D.wireframe=I.wireframe,H===br?D.side=I.shadowSide!==null?I.shadowSide:I.side:D.side=I.shadowSide!==null?I.shadowSide:f[I.side],D.clipShadows=I.clipShadows,D.clippingPlanes=I.clippingPlanes,D.clipIntersection=I.clipIntersection,D.wireframeLinewidth=I.wireframeLinewidth,D.linewidth=I.linewidth,N.isPointLight===!0&&D.isMeshDistanceMaterial===!0&&(D.referencePosition.setFromMatrixPosition(N.matrixWorld),D.nearDistance=z,D.farDistance=W),D}function A(E,P,I,N,z){if(E.visible===!1)return;if(E.layers.test(P.layers)&&(E.isMesh||E.isLine||E.isPoints)&&(E.castShadow||E.receiveShadow&&z===br)&&(!E.frustumCulled||n.intersectsObject(E))){E.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse,E.matrixWorld);const D=t.update(E),V=E.material;if(Array.isArray(V)){const G=D.groups;for(let B=0,j=G.length;B<j;B++){const ot=G[B],Q=V[ot.materialIndex];if(Q&&Q.visible){const ut=T(E,D,Q,N,I.near,I.far,z);r.renderBufferDirect(I,null,D,ut,E,ot)}}}else if(V.visible){const G=T(E,D,V,N,I.near,I.far,z);r.renderBufferDirect(I,null,D,G,E,null)}}const H=E.children;for(let D=0,V=H.length;D<V;D++)A(H[D],P,I,N,z)}}function mw(r,t,e){const n=e.isWebGL2;function i(){let U=!1;const at=new ne;let $=null;const St=new ne(0,0,0,0);return{setMask:function(dt){$!==dt&&!U&&(r.colorMask(dt,dt,dt,dt),$=dt)},setLocked:function(dt){U=dt},setClear:function(dt,Ht,ee,ge,Ke){Ke===!0&&(dt*=ge,Ht*=ge,ee*=ge),at.set(dt,Ht,ee,ge),St.equals(at)===!1&&(r.clearColor(dt,Ht,ee,ge),St.copy(at))},reset:function(){U=!1,$=null,St.set(-1,0,0,0)}}}function s(){let U=!1,at=null,$=null,St=null;return{setTest:function(dt){dt?ft(2929):Ft(2929)},setMask:function(dt){at!==dt&&!U&&(r.depthMask(dt),at=dt)},setFunc:function(dt){if($!==dt){if(dt)switch(dt){case Tv:r.depthFunc(512);break;case Av:r.depthFunc(519);break;case Cv:r.depthFunc(513);break;case Bl:r.depthFunc(515);break;case Pv:r.depthFunc(514);break;case Lv:r.depthFunc(518);break;case Rv:r.depthFunc(516);break;case Iv:r.depthFunc(517);break;default:r.depthFunc(515)}else r.depthFunc(515);$=dt}},setLocked:function(dt){U=dt},setClear:function(dt){St!==dt&&(r.clearDepth(dt),St=dt)},reset:function(){U=!1,at=null,$=null,St=null}}}function a(){let U=!1,at=null,$=null,St=null,dt=null,Ht=null,ee=null,ge=null,Ke=null;return{setTest:function(he){U||(he?ft(2960):Ft(2960))},setMask:function(he){at!==he&&!U&&(r.stencilMask(he),at=he)},setFunc:function(he,$e,ze){($!==he||St!==$e||dt!==ze)&&(r.stencilFunc(he,$e,ze),$=he,St=$e,dt=ze)},setOp:function(he,$e,ze){(Ht!==he||ee!==$e||ge!==ze)&&(r.stencilOp(he,$e,ze),Ht=he,ee=$e,ge=ze)},setLocked:function(he){U=he},setClear:function(he){Ke!==he&&(r.clearStencil(he),Ke=he)},reset:function(){U=!1,at=null,$=null,St=null,dt=null,Ht=null,ee=null,ge=null,Ke=null}}}const l=new i,u=new s,h=new a;let p={},f=null,m={},v=null,x=!1,b=null,w=null,_=null,y=null,M=null,T=null,A=null,E=!1,P=null,I=null,N=null,z=null,W=null;const H=r.getParameter(35661);let D=!1,V=0;const G=r.getParameter(7938);G.indexOf("WebGL")!==-1?(V=parseFloat(/^WebGL (\d)/.exec(G)[1]),D=V>=1):G.indexOf("OpenGL ES")!==-1&&(V=parseFloat(/^OpenGL ES (\d)/.exec(G)[1]),D=V>=2);let B=null,j={};const ot=r.getParameter(3088),Q=r.getParameter(2978),ut=new ne().fromArray(ot),rt=new ne().fromArray(Q);function Tt(U,at,$){const St=new Uint8Array(4),dt=r.createTexture();r.bindTexture(U,dt),r.texParameteri(U,10241,9728),r.texParameteri(U,10240,9728);for(let Ht=0;Ht<$;Ht++)r.texImage2D(at+Ht,0,6408,1,1,0,6408,5121,St);return dt}const ct={};ct[3553]=Tt(3553,3553,1),ct[34067]=Tt(34067,34069,6),l.setClear(0,0,0,1),u.setClear(1),h.setClear(0),ft(2929),u.setFunc(Bl),et(!1),lt(Wu),ft(2884),Nt(Er);function ft(U){p[U]!==!0&&(r.enable(U),p[U]=!0)}function Ft(U){p[U]!==!1&&(r.disable(U),p[U]=!1)}function K(U){U!==f&&(r.bindFramebuffer(36160,U),f=U)}function Ot(U,at){return at===null&&f!==null&&(at=f),m[U]!==at?(r.bindFramebuffer(U,at),m[U]=at,n&&(U===36009&&(m[36160]=at),U===36160&&(m[36009]=at)),!0):!1}function Dt(U){return v!==U?(r.useProgram(U),v=U,!0):!1}const Mt={[bs]:32774,[mv]:32778,[gv]:32779};if(n)Mt[Yu]=32775,Mt[Zu]=32776;else{const U=t.get("EXT_blend_minmax");U!==null&&(Mt[Yu]=U.MIN_EXT,Mt[Zu]=U.MAX_EXT)}const bt={[vv]:0,[_v]:1,[xv]:768,[Ud]:770,[Sv]:776,[Mv]:774,[bv]:772,[yv]:769,[Hd]:771,[Ev]:775,[wv]:773};function Nt(U,at,$,St,dt,Ht,ee,ge){if(U===Er){x===!0&&(Ft(3042),x=!1);return}if(x===!1&&(ft(3042),x=!0),U!==fv){if(U!==b||ge!==E){if((w!==bs||M!==bs)&&(r.blendEquation(32774),w=bs,M=bs),ge)switch(U){case Sr:r.blendFuncSeparate(1,771,1,771);break;case ju:r.blendFunc(1,1);break;case Xu:r.blendFuncSeparate(0,0,769,771);break;case qu:r.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",U);break}else switch(U){case Sr:r.blendFuncSeparate(770,771,1,771);break;case ju:r.blendFunc(770,1);break;case Xu:r.blendFunc(0,769);break;case qu:r.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",U);break}_=null,y=null,T=null,A=null,b=U,E=ge}return}dt=dt||at,Ht=Ht||$,ee=ee||St,(at!==w||dt!==M)&&(r.blendEquationSeparate(Mt[at],Mt[dt]),w=at,M=dt),($!==_||St!==y||Ht!==T||ee!==A)&&(r.blendFuncSeparate(bt[$],bt[St],bt[Ht],bt[ee]),_=$,y=St,T=Ht,A=ee),b=U,E=null}function tt(U,at){U.side===on?Ft(2884):ft(2884);let $=U.side===ye;at&&($=!$),et($),U.blending===Sr&&U.transparent===!1?Nt(Er):Nt(U.blending,U.blendEquation,U.blendSrc,U.blendDst,U.blendEquationAlpha,U.blendSrcAlpha,U.blendDstAlpha,U.premultipliedAlpha),u.setFunc(U.depthFunc),u.setTest(U.depthTest),u.setMask(U.depthWrite),l.setMask(U.colorWrite);const St=U.stencilWrite;h.setTest(St),St&&(h.setMask(U.stencilWriteMask),h.setFunc(U.stencilFunc,U.stencilRef,U.stencilFuncMask),h.setOp(U.stencilFail,U.stencilZFail,U.stencilZPass)),_t(U.polygonOffset,U.polygonOffsetFactor,U.polygonOffsetUnits),U.alphaToCoverage===!0?ft(32926):Ft(32926)}function et(U){P!==U&&(U?r.frontFace(2304):r.frontFace(2305),P=U)}function lt(U){U!==hv?(ft(2884),U!==I&&(U===Wu?r.cullFace(1029):U===dv?r.cullFace(1028):r.cullFace(1032))):Ft(2884),I=U}function At(U){U!==N&&(D&&r.lineWidth(U),N=U)}function _t(U,at,$){U?(ft(32823),(z!==at||W!==$)&&(r.polygonOffset(at,$),z=at,W=$)):Ft(32823)}function F(U){U?ft(3089):Ft(3089)}function R(U){U===void 0&&(U=33984+H-1),B!==U&&(r.activeTexture(U),B=U)}function J(U,at){B===null&&R();let $=j[B];$===void 0&&($={type:void 0,texture:void 0},j[B]=$),($.type!==U||$.texture!==at)&&(r.bindTexture(U,at||ct[U]),$.type=U,$.texture=at)}function it(){const U=j[B];U!==void 0&&U.type!==void 0&&(r.bindTexture(U.type,null),U.type=void 0,U.texture=void 0)}function gt(){try{r.compressedTexImage2D.apply(r,arguments)}catch(U){console.error("THREE.WebGLState:",U)}}function xt(){try{r.texImage2D.apply(r,arguments)}catch(U){console.error("THREE.WebGLState:",U)}}function Pt(){try{r.texImage3D.apply(r,arguments)}catch(U){console.error("THREE.WebGLState:",U)}}function O(U){ut.equals(U)===!1&&(r.scissor(U.x,U.y,U.z,U.w),ut.copy(U))}function mt(U){rt.equals(U)===!1&&(r.viewport(U.x,U.y,U.z,U.w),rt.copy(U))}function ht(){r.disable(3042),r.disable(2884),r.disable(2929),r.disable(32823),r.disable(3089),r.disable(2960),r.disable(32926),r.blendEquation(32774),r.blendFunc(1,0),r.blendFuncSeparate(1,0,1,0),r.colorMask(!0,!0,!0,!0),r.clearColor(0,0,0,0),r.depthMask(!0),r.depthFunc(513),r.clearDepth(1),r.stencilMask(4294967295),r.stencilFunc(519,0,4294967295),r.stencilOp(7680,7680,7680),r.clearStencil(0),r.cullFace(1029),r.frontFace(2305),r.polygonOffset(0,0),r.activeTexture(33984),r.bindFramebuffer(36160,null),n===!0&&(r.bindFramebuffer(36009,null),r.bindFramebuffer(36008,null)),r.useProgram(null),r.lineWidth(1),r.scissor(0,0,r.canvas.width,r.canvas.height),r.viewport(0,0,r.canvas.width,r.canvas.height),p={},B=null,j={},f=null,m={},v=null,x=!1,b=null,w=null,_=null,y=null,M=null,T=null,A=null,E=!1,P=null,I=null,N=null,z=null,W=null,ut.set(0,0,r.canvas.width,r.canvas.height),rt.set(0,0,r.canvas.width,r.canvas.height),l.reset(),u.reset(),h.reset()}return{buffers:{color:l,depth:u,stencil:h},enable:ft,disable:Ft,bindFramebuffer:Ot,bindXRFramebuffer:K,useProgram:Dt,setBlending:Nt,setMaterial:tt,setFlipSided:et,setCullFace:lt,setLineWidth:At,setPolygonOffset:_t,setScissorTest:F,activeTexture:R,bindTexture:J,unbindTexture:it,compressedTexImage2D:gt,texImage2D:xt,texImage3D:Pt,scissor:O,viewport:mt,reset:ht}}function gw(r,t,e,n,i,s,a){const l=i.isWebGL2,u=i.maxTextures,h=i.maxCubemapSize,p=i.maxTextureSize,f=i.maxSamples,m=new WeakMap;let v,x=!1;try{x=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function b(F,R){return x?new OffscreenCanvas(F,R):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function w(F,R,J,it){let gt=1;if((F.width>it||F.height>it)&&(gt=it/Math.max(F.width,F.height)),gt<1||R===!0)if(typeof HTMLImageElement!="undefined"&&F instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&F instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&F instanceof ImageBitmap){const xt=R?Qd:Math.floor,Pt=xt(gt*F.width),O=xt(gt*F.height);v===void 0&&(v=b(Pt,O));const mt=J?b(Pt,O):v;return mt.width=Pt,mt.height=O,mt.getContext("2d").drawImage(F,0,0,Pt,O),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+F.width+"x"+F.height+") to ("+Pt+"x"+O+")."),mt}else return"data"in F&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+F.width+"x"+F.height+")."),F;return F}function _(F){return Ul(F.width)&&Ul(F.height)}function y(F){return l?!1:F.wrapS!==Ve||F.wrapT!==Ve||F.minFilter!==oe&&F.minFilter!==Re}function M(F,R){return F.generateMipmaps&&R&&F.minFilter!==oe&&F.minFilter!==Re}function T(F,R,J,it){r.generateMipmap(F);const gt=n.get(R);gt.__maxMipLevel=Math.log2(Math.max(J,it))}function A(F,R,J){if(l===!1)return R;if(F!==null){if(r[F]!==void 0)return r[F];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+F+"'")}let it=R;return R===6403&&(J===5126&&(it=33326),J===5131&&(it=33325),J===5121&&(it=33321)),R===6407&&(J===5126&&(it=34837),J===5131&&(it=34843),J===5121&&(it=32849)),R===6408&&(J===5126&&(it=34836),J===5131&&(it=34842),J===5121&&(it=32856)),(it===33325||it===33326||it===34842||it===34836)&&t.get("EXT_color_buffer_float"),it}function E(F){return F===oe||F===Ol||F===Vl?9728:9729}function P(F){const R=F.target;R.removeEventListener("dispose",P),N(R),R.isVideoTexture&&m.delete(R),a.memory.textures--}function I(F){const R=F.target;R.removeEventListener("dispose",I),z(R)}function N(F){const R=n.get(F);R.__webglInit!==void 0&&(r.deleteTexture(R.__webglTexture),n.remove(F))}function z(F){const R=F.texture,J=n.get(F),it=n.get(R);if(!!F){if(it.__webglTexture!==void 0&&(r.deleteTexture(it.__webglTexture),a.memory.textures--),F.depthTexture&&F.depthTexture.dispose(),F.isWebGLCubeRenderTarget)for(let gt=0;gt<6;gt++)r.deleteFramebuffer(J.__webglFramebuffer[gt]),J.__webglDepthbuffer&&r.deleteRenderbuffer(J.__webglDepthbuffer[gt]);else r.deleteFramebuffer(J.__webglFramebuffer),J.__webglDepthbuffer&&r.deleteRenderbuffer(J.__webglDepthbuffer),J.__webglMultisampledFramebuffer&&r.deleteFramebuffer(J.__webglMultisampledFramebuffer),J.__webglColorRenderbuffer&&r.deleteRenderbuffer(J.__webglColorRenderbuffer),J.__webglDepthRenderbuffer&&r.deleteRenderbuffer(J.__webglDepthRenderbuffer);if(F.isWebGLMultipleRenderTargets)for(let gt=0,xt=R.length;gt<xt;gt++){const Pt=n.get(R[gt]);Pt.__webglTexture&&(r.deleteTexture(Pt.__webglTexture),a.memory.textures--),n.remove(R[gt])}n.remove(R),n.remove(F)}}let W=0;function H(){W=0}function D(){const F=W;return F>=u&&console.warn("THREE.WebGLTextures: Trying to use "+F+" texture units while this GPU supports only "+u),W+=1,F}function V(F,R){const J=n.get(F);if(F.isVideoTexture&&tt(F),F.version>0&&J.__version!==F.version){const it=F.image;if(it===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(it.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Tt(J,F,R);return}}e.activeTexture(33984+R),e.bindTexture(3553,J.__webglTexture)}function G(F,R){const J=n.get(F);if(F.version>0&&J.__version!==F.version){Tt(J,F,R);return}e.activeTexture(33984+R),e.bindTexture(35866,J.__webglTexture)}function B(F,R){const J=n.get(F);if(F.version>0&&J.__version!==F.version){Tt(J,F,R);return}e.activeTexture(33984+R),e.bindTexture(32879,J.__webglTexture)}function j(F,R){const J=n.get(F);if(F.version>0&&J.__version!==F.version){ct(J,F,R);return}e.activeTexture(33984+R),e.bindTexture(34067,J.__webglTexture)}const ot={[Ls]:10497,[Ve]:33071,[ia]:33648},Q={[oe]:9728,[Ol]:9984,[Vl]:9986,[Re]:9729,[Wd]:9985,[Bs]:9987};function ut(F,R,J){if(J?(r.texParameteri(F,10242,ot[R.wrapS]),r.texParameteri(F,10243,ot[R.wrapT]),(F===32879||F===35866)&&r.texParameteri(F,32882,ot[R.wrapR]),r.texParameteri(F,10240,Q[R.magFilter]),r.texParameteri(F,10241,Q[R.minFilter])):(r.texParameteri(F,10242,33071),r.texParameteri(F,10243,33071),(F===32879||F===35866)&&r.texParameteri(F,32882,33071),(R.wrapS!==Ve||R.wrapT!==Ve)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),r.texParameteri(F,10240,E(R.magFilter)),r.texParameteri(F,10241,E(R.minFilter)),R.minFilter!==oe&&R.minFilter!==Re&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const it=t.get("EXT_texture_filter_anisotropic");if(R.type===Ne&&t.has("OES_texture_float_linear")===!1||l===!1&&R.type===sa&&t.has("OES_texture_half_float_linear")===!1)return;(R.anisotropy>1||n.get(R).__currentAnisotropy)&&(r.texParameterf(F,it.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(R.anisotropy,i.getMaxAnisotropy())),n.get(R).__currentAnisotropy=R.anisotropy)}}function rt(F,R){F.__webglInit===void 0&&(F.__webglInit=!0,R.addEventListener("dispose",P),F.__webglTexture=r.createTexture(),a.memory.textures++)}function Tt(F,R,J){let it=3553;R.isDataTexture2DArray&&(it=35866),R.isDataTexture3D&&(it=32879),rt(F,R),e.activeTexture(33984+J),e.bindTexture(it,F.__webglTexture),r.pixelStorei(37440,R.flipY),r.pixelStorei(37441,R.premultiplyAlpha),r.pixelStorei(3317,R.unpackAlignment),r.pixelStorei(37443,0);const gt=y(R)&&_(R.image)===!1,xt=w(R.image,gt,!1,p),Pt=_(xt)||l,O=s.convert(R.format);let mt=s.convert(R.type),ht=A(R.internalFormat,O,mt);ut(it,R,Pt);let U;const at=R.mipmaps;if(R.isDepthTexture)ht=6402,l?R.type===Ne?ht=36012:R.type===On?ht=33190:R.type===Ar?ht=35056:ht=33189:R.type===Ne&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),R.format===Cs&&ht===6402&&R.type!==Nr&&R.type!==On&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),R.type=Nr,mt=s.convert(R.type)),R.format===Fr&&ht===6402&&(ht=34041,R.type!==Ar&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),R.type=Ar,mt=s.convert(R.type))),e.texImage2D(3553,0,ht,xt.width,xt.height,0,O,mt,null);else if(R.isDataTexture)if(at.length>0&&Pt){for(let $=0,St=at.length;$<St;$++)U=at[$],e.texImage2D(3553,$,ht,U.width,U.height,0,O,mt,U.data);R.generateMipmaps=!1,F.__maxMipLevel=at.length-1}else e.texImage2D(3553,0,ht,xt.width,xt.height,0,O,mt,xt.data),F.__maxMipLevel=0;else if(R.isCompressedTexture){for(let $=0,St=at.length;$<St;$++)U=at[$],R.format!==Fe&&R.format!==li?O!==null?e.compressedTexImage2D(3553,$,ht,U.width,U.height,0,U.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):e.texImage2D(3553,$,ht,U.width,U.height,0,O,mt,U.data);F.__maxMipLevel=at.length-1}else if(R.isDataTexture2DArray)e.texImage3D(35866,0,ht,xt.width,xt.height,xt.depth,0,O,mt,xt.data),F.__maxMipLevel=0;else if(R.isDataTexture3D)e.texImage3D(32879,0,ht,xt.width,xt.height,xt.depth,0,O,mt,xt.data),F.__maxMipLevel=0;else if(at.length>0&&Pt){for(let $=0,St=at.length;$<St;$++)U=at[$],e.texImage2D(3553,$,ht,O,mt,U);R.generateMipmaps=!1,F.__maxMipLevel=at.length-1}else e.texImage2D(3553,0,ht,O,mt,xt),F.__maxMipLevel=0;M(R,Pt)&&T(it,R,xt.width,xt.height),F.__version=R.version,R.onUpdate&&R.onUpdate(R)}function ct(F,R,J){if(R.image.length!==6)return;rt(F,R),e.activeTexture(33984+J),e.bindTexture(34067,F.__webglTexture),r.pixelStorei(37440,R.flipY),r.pixelStorei(37441,R.premultiplyAlpha),r.pixelStorei(3317,R.unpackAlignment),r.pixelStorei(37443,0);const it=R&&(R.isCompressedTexture||R.image[0].isCompressedTexture),gt=R.image[0]&&R.image[0].isDataTexture,xt=[];for(let $=0;$<6;$++)!it&&!gt?xt[$]=w(R.image[$],!1,!0,h):xt[$]=gt?R.image[$].image:R.image[$];const Pt=xt[0],O=_(Pt)||l,mt=s.convert(R.format),ht=s.convert(R.type),U=A(R.internalFormat,mt,ht);ut(34067,R,O);let at;if(it){for(let $=0;$<6;$++){at=xt[$].mipmaps;for(let St=0;St<at.length;St++){const dt=at[St];R.format!==Fe&&R.format!==li?mt!==null?e.compressedTexImage2D(34069+$,St,U,dt.width,dt.height,0,dt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):e.texImage2D(34069+$,St,U,dt.width,dt.height,0,mt,ht,dt.data)}}F.__maxMipLevel=at.length-1}else{at=R.mipmaps;for(let $=0;$<6;$++)if(gt){e.texImage2D(34069+$,0,U,xt[$].width,xt[$].height,0,mt,ht,xt[$].data);for(let St=0;St<at.length;St++){const Ht=at[St].image[$].image;e.texImage2D(34069+$,St+1,U,Ht.width,Ht.height,0,mt,ht,Ht.data)}}else{e.texImage2D(34069+$,0,U,mt,ht,xt[$]);for(let St=0;St<at.length;St++){const dt=at[St];e.texImage2D(34069+$,St+1,U,mt,ht,dt.image[$])}}F.__maxMipLevel=at.length}M(R,O)&&T(34067,R,Pt.width,Pt.height),F.__version=R.version,R.onUpdate&&R.onUpdate(R)}function ft(F,R,J,it,gt){const xt=s.convert(J.format),Pt=s.convert(J.type),O=A(J.internalFormat,xt,Pt);gt===32879||gt===35866?e.texImage3D(gt,0,O,R.width,R.height,R.depth,0,xt,Pt,null):e.texImage2D(gt,0,O,R.width,R.height,0,xt,Pt,null),e.bindFramebuffer(36160,F),r.framebufferTexture2D(36160,it,gt,n.get(J).__webglTexture,0),e.bindFramebuffer(36160,null)}function Ft(F,R,J){if(r.bindRenderbuffer(36161,F),R.depthBuffer&&!R.stencilBuffer){let it=33189;if(J){const gt=R.depthTexture;gt&&gt.isDepthTexture&&(gt.type===Ne?it=36012:gt.type===On&&(it=33190));const xt=Nt(R);r.renderbufferStorageMultisample(36161,xt,it,R.width,R.height)}else r.renderbufferStorage(36161,it,R.width,R.height);r.framebufferRenderbuffer(36160,36096,36161,F)}else if(R.depthBuffer&&R.stencilBuffer){if(J){const it=Nt(R);r.renderbufferStorageMultisample(36161,it,35056,R.width,R.height)}else r.renderbufferStorage(36161,34041,R.width,R.height);r.framebufferRenderbuffer(36160,33306,36161,F)}else{const it=R.isWebGLMultipleRenderTargets===!0?R.texture[0]:R.texture,gt=s.convert(it.format),xt=s.convert(it.type),Pt=A(it.internalFormat,gt,xt);if(J){const O=Nt(R);r.renderbufferStorageMultisample(36161,O,Pt,R.width,R.height)}else r.renderbufferStorage(36161,Pt,R.width,R.height)}r.bindRenderbuffer(36161,null)}function K(F,R){if(R&&R.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,F),!(R.depthTexture&&R.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(R.depthTexture).__webglTexture||R.depthTexture.image.width!==R.width||R.depthTexture.image.height!==R.height)&&(R.depthTexture.image.width=R.width,R.depthTexture.image.height=R.height,R.depthTexture.needsUpdate=!0),V(R.depthTexture,0);const it=n.get(R.depthTexture).__webglTexture;if(R.depthTexture.format===Cs)r.framebufferTexture2D(36160,36096,3553,it,0);else if(R.depthTexture.format===Fr)r.framebufferTexture2D(36160,33306,3553,it,0);else throw new Error("Unknown depthTexture format")}function Ot(F){const R=n.get(F),J=F.isWebGLCubeRenderTarget===!0;if(F.depthTexture){if(J)throw new Error("target.depthTexture not supported in Cube render targets");K(R.__webglFramebuffer,F)}else if(J){R.__webglDepthbuffer=[];for(let it=0;it<6;it++)e.bindFramebuffer(36160,R.__webglFramebuffer[it]),R.__webglDepthbuffer[it]=r.createRenderbuffer(),Ft(R.__webglDepthbuffer[it],F,!1)}else e.bindFramebuffer(36160,R.__webglFramebuffer),R.__webglDepthbuffer=r.createRenderbuffer(),Ft(R.__webglDepthbuffer,F,!1);e.bindFramebuffer(36160,null)}function Dt(F){const R=F.texture,J=n.get(F),it=n.get(R);F.addEventListener("dispose",I),F.isWebGLMultipleRenderTargets!==!0&&(it.__webglTexture=r.createTexture(),it.__version=R.version,a.memory.textures++);const gt=F.isWebGLCubeRenderTarget===!0,xt=F.isWebGLMultipleRenderTargets===!0,Pt=F.isWebGLMultisampleRenderTarget===!0,O=R.isDataTexture3D||R.isDataTexture2DArray,mt=_(F)||l;if(l&&R.format===li&&(R.type===Ne||R.type===sa)&&(R.format=Fe,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),gt){J.__webglFramebuffer=[];for(let ht=0;ht<6;ht++)J.__webglFramebuffer[ht]=r.createFramebuffer()}else if(J.__webglFramebuffer=r.createFramebuffer(),xt)if(i.drawBuffers){const ht=F.texture;for(let U=0,at=ht.length;U<at;U++){const $=n.get(ht[U]);$.__webglTexture===void 0&&($.__webglTexture=r.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(Pt)if(l){J.__webglMultisampledFramebuffer=r.createFramebuffer(),J.__webglColorRenderbuffer=r.createRenderbuffer(),r.bindRenderbuffer(36161,J.__webglColorRenderbuffer);const ht=s.convert(R.format),U=s.convert(R.type),at=A(R.internalFormat,ht,U),$=Nt(F);r.renderbufferStorageMultisample(36161,$,at,F.width,F.height),e.bindFramebuffer(36160,J.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(36160,36064,36161,J.__webglColorRenderbuffer),r.bindRenderbuffer(36161,null),F.depthBuffer&&(J.__webglDepthRenderbuffer=r.createRenderbuffer(),Ft(J.__webglDepthRenderbuffer,F,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(gt){e.bindTexture(34067,it.__webglTexture),ut(34067,R,mt);for(let ht=0;ht<6;ht++)ft(J.__webglFramebuffer[ht],F,R,36064,34069+ht);M(R,mt)&&T(34067,R,F.width,F.height),e.bindTexture(34067,null)}else if(xt){const ht=F.texture;for(let U=0,at=ht.length;U<at;U++){const $=ht[U],St=n.get($);e.bindTexture(3553,St.__webglTexture),ut(3553,$,mt),ft(J.__webglFramebuffer,F,$,36064+U,3553),M($,mt)&&T(3553,$,F.width,F.height)}e.bindTexture(3553,null)}else{let ht=3553;O&&(l?ht=R.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),e.bindTexture(ht,it.__webglTexture),ut(ht,R,mt),ft(J.__webglFramebuffer,F,R,36064,ht),M(R,mt)&&T(3553,R,F.width,F.height),e.bindTexture(3553,null)}F.depthBuffer&&Ot(F)}function Mt(F){const R=_(F)||l,J=F.isWebGLMultipleRenderTargets===!0?F.texture:[F.texture];for(let it=0,gt=J.length;it<gt;it++){const xt=J[it];if(M(xt,R)){const Pt=F.isWebGLCubeRenderTarget?34067:3553,O=n.get(xt).__webglTexture;e.bindTexture(Pt,O),T(Pt,xt,F.width,F.height),e.bindTexture(Pt,null)}}}function bt(F){if(F.isWebGLMultisampleRenderTarget)if(l){const R=F.width,J=F.height;let it=16384;F.depthBuffer&&(it|=256),F.stencilBuffer&&(it|=1024);const gt=n.get(F);e.bindFramebuffer(36008,gt.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,gt.__webglFramebuffer),r.blitFramebuffer(0,0,R,J,0,0,R,J,it,9728),e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,gt.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function Nt(F){return l&&F.isWebGLMultisampleRenderTarget?Math.min(f,F.samples):0}function tt(F){const R=a.render.frame;m.get(F)!==R&&(m.set(F,R),F.update())}let et=!1,lt=!1;function At(F,R){F&&F.isWebGLRenderTarget&&(et===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),et=!0),F=F.texture),V(F,R)}function _t(F,R){F&&F.isWebGLCubeRenderTarget&&(lt===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),lt=!0),F=F.texture),j(F,R)}this.allocateTextureUnit=D,this.resetTextureUnits=H,this.setTexture2D=V,this.setTexture2DArray=G,this.setTexture3D=B,this.setTextureCube=j,this.setupRenderTarget=Dt,this.updateRenderTargetMipmap=Mt,this.updateMultisampleRenderTarget=bt,this.safeSetTexture2D=At,this.safeSetTextureCube=_t}function vw(r,t,e){const n=e.isWebGL2;function i(s){let a;if(s===Dr)return 5121;if(s===Uv)return 32819;if(s===Hv)return 32820;if(s===Gv)return 33635;if(s===zl)return 5120;if(s===jd)return 5122;if(s===Nr)return 5123;if(s===Qo)return 5124;if(s===On)return 5125;if(s===Ne)return 5126;if(s===sa)return n?5131:(a=t.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===Wv)return 6406;if(s===li)return 6407;if(s===Fe)return 6408;if(s===jv)return 6409;if(s===Xv)return 6410;if(s===Cs)return 6402;if(s===Fr)return 34041;if(s===Xd)return 6403;if(s===qd)return 36244;if(s===Yd)return 33319;if(s===uc)return 33320;if(s===qv)return 36248;if(s===ra)return 36249;if(s===Ju||s===Qu||s===th||s===eh)if(a=t.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===Ju)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Qu)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===th)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===eh)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===nh||s===ih||s===sh||s===rh)if(a=t.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===nh)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===ih)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===sh)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===rh)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===Yv)return a=t.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===oh||s===ah)&&(a=t.get("WEBGL_compressed_texture_etc"),a!==null)){if(s===oh)return a.COMPRESSED_RGB8_ETC2;if(s===ah)return a.COMPRESSED_RGBA8_ETC2_EAC}if(s===Zv||s===Kv||s===$v||s===Jv||s===Qv||s===t_||s===e_||s===n_||s===i_||s===s_||s===r_||s===o_||s===a_||s===l_||s===u_||s===h_||s===d_||s===p_||s===f_||s===m_||s===g_||s===v_||s===__||s===x_||s===y_||s===b_||s===w_||s===M_)return a=t.get("WEBGL_compressed_texture_astc"),a!==null?s:null;if(s===c_)return a=t.get("EXT_texture_compression_bptc"),a!==null?s:null;if(s===Ar)return n?34042:(a=t.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:i}}class xp extends De{constructor(t=[]){super(),this.cameras=t}}xp.prototype.isArrayCamera=!0;class ai extends Wt{constructor(){super(),this.type="Group"}}ai.prototype.isGroup=!0;const _w={type:"move"};class xl{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new ai,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new ai,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new C,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new C),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new ai,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new C,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new C),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let i=null,s=null,a=null;const l=this._targetRay,u=this._grip,h=this._hand;if(t&&e.session.visibilityState!=="visible-blurred")if(l!==null&&(i=e.getPose(t.targetRaySpace,n),i!==null&&(l.matrix.fromArray(i.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),i.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(i.linearVelocity)):l.hasLinearVelocity=!1,i.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(i.angularVelocity)):l.hasAngularVelocity=!1,this.dispatchEvent(_w))),h&&t.hand){a=!0;for(const b of t.hand.values()){const w=e.getJointPose(b,n);if(h.joints[b.jointName]===void 0){const y=new ai;y.matrixAutoUpdate=!1,y.visible=!1,h.joints[b.jointName]=y,h.add(y)}const _=h.joints[b.jointName];w!==null&&(_.matrix.fromArray(w.transform.matrix),_.matrix.decompose(_.position,_.rotation,_.scale),_.jointRadius=w.radius),_.visible=w!==null}const p=h.joints["index-finger-tip"],f=h.joints["thumb-tip"],m=p.position.distanceTo(f.position),v=.02,x=.005;h.inputState.pinching&&m>v+x?(h.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!h.inputState.pinching&&m<=v-x&&(h.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else u!==null&&t.gripSpace&&(s=e.getPose(t.gripSpace,n),s!==null&&(u.matrix.fromArray(s.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),s.linearVelocity?(u.hasLinearVelocity=!0,u.linearVelocity.copy(s.linearVelocity)):u.hasLinearVelocity=!1,s.angularVelocity?(u.hasAngularVelocity=!0,u.angularVelocity.copy(s.angularVelocity)):u.hasAngularVelocity=!1));return l!==null&&(l.visible=i!==null),u!==null&&(u.visible=s!==null),h!==null&&(h.visible=a!==null),this}}class xw extends fi{constructor(t,e){super();const n=this,i=t.state;let s=null,a=1,l=null,u="local-floor",h=null;const p=[],f=new Map,m=new De;m.layers.enable(1),m.viewport=new ne;const v=new De;v.layers.enable(2),v.viewport=new ne;const x=[m,v],b=new xp;b.layers.enable(1),b.layers.enable(2);let w=null,_=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(H){let D=p[H];return D===void 0&&(D=new xl,p[H]=D),D.getTargetRaySpace()},this.getControllerGrip=function(H){let D=p[H];return D===void 0&&(D=new xl,p[H]=D),D.getGripSpace()},this.getHand=function(H){let D=p[H];return D===void 0&&(D=new xl,p[H]=D),D.getHandSpace()};function y(H){const D=f.get(H.inputSource);D&&D.dispatchEvent({type:H.type,data:H.inputSource})}function M(){f.forEach(function(H,D){H.disconnect(D)}),f.clear(),w=null,_=null,i.bindXRFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),W.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(H){a=H,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(H){u=H,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l},this.getSession=function(){return s},this.setSession=async function(H){if(s=H,s!==null){s.addEventListener("select",y),s.addEventListener("selectstart",y),s.addEventListener("selectend",y),s.addEventListener("squeeze",y),s.addEventListener("squeezestart",y),s.addEventListener("squeezeend",y),s.addEventListener("end",M),s.addEventListener("inputsourceschange",T);const D=e.getContextAttributes();D.xrCompatible!==!0&&await e.makeXRCompatible();const V={antialias:D.antialias,alpha:D.alpha,depth:D.depth,stencil:D.stencil,framebufferScaleFactor:a},G=new XRWebGLLayer(s,e,V);s.updateRenderState({baseLayer:G}),l=await s.requestReferenceSpace(u),W.setContext(s),W.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function T(H){const D=s.inputSources;for(let V=0;V<p.length;V++)f.set(D[V],p[V]);for(let V=0;V<H.removed.length;V++){const G=H.removed[V],B=f.get(G);B&&(B.dispatchEvent({type:"disconnected",data:G}),f.delete(G))}for(let V=0;V<H.added.length;V++){const G=H.added[V],B=f.get(G);B&&B.dispatchEvent({type:"connected",data:G})}}const A=new C,E=new C;function P(H,D,V){A.setFromMatrixPosition(D.matrixWorld),E.setFromMatrixPosition(V.matrixWorld);const G=A.distanceTo(E),B=D.projectionMatrix.elements,j=V.projectionMatrix.elements,ot=B[14]/(B[10]-1),Q=B[14]/(B[10]+1),ut=(B[9]+1)/B[5],rt=(B[9]-1)/B[5],Tt=(B[8]-1)/B[0],ct=(j[8]+1)/j[0],ft=ot*Tt,Ft=ot*ct,K=G/(-Tt+ct),Ot=K*-Tt;D.matrixWorld.decompose(H.position,H.quaternion,H.scale),H.translateX(Ot),H.translateZ(K),H.matrixWorld.compose(H.position,H.quaternion,H.scale),H.matrixWorldInverse.copy(H.matrixWorld).invert();const Dt=ot+K,Mt=Q+K,bt=ft-Ot,Nt=Ft+(G-Ot),tt=ut*Q/Mt*Dt,et=rt*Q/Mt*Dt;H.projectionMatrix.makePerspective(bt,Nt,tt,et,Dt,Mt)}function I(H,D){D===null?H.matrixWorld.copy(H.matrix):H.matrixWorld.multiplyMatrices(D.matrixWorld,H.matrix),H.matrixWorldInverse.copy(H.matrixWorld).invert()}this.updateCamera=function(H){if(s===null)return;b.near=v.near=m.near=H.near,b.far=v.far=m.far=H.far,(w!==b.near||_!==b.far)&&(s.updateRenderState({depthNear:b.near,depthFar:b.far}),w=b.near,_=b.far);const D=H.parent,V=b.cameras;I(b,D);for(let B=0;B<V.length;B++)I(V[B],D);H.matrixWorld.copy(b.matrixWorld),H.matrix.copy(b.matrix),H.matrix.decompose(H.position,H.quaternion,H.scale);const G=H.children;for(let B=0,j=G.length;B<j;B++)G[B].updateMatrixWorld(!0);V.length===2?P(b,m,v):b.projectionMatrix.copy(m.projectionMatrix)},this.getCamera=function(){return b};let N=null;function z(H,D){if(h=D.getViewerPose(l),h!==null){const G=h.views,B=s.renderState.baseLayer;i.bindXRFramebuffer(B.framebuffer);let j=!1;G.length!==b.cameras.length&&(b.cameras.length=0,j=!0);for(let ot=0;ot<G.length;ot++){const Q=G[ot],ut=B.getViewport(Q),rt=x[ot];rt.matrix.fromArray(Q.transform.matrix),rt.projectionMatrix.fromArray(Q.projectionMatrix),rt.viewport.set(ut.x,ut.y,ut.width,ut.height),ot===0&&b.matrix.copy(rt.matrix),j===!0&&b.cameras.push(rt)}}const V=s.inputSources;for(let G=0;G<p.length;G++){const B=p[G],j=V[G];B.update(j,D,l)}N&&N(H,D)}const W=new op;W.setAnimationLoop(z),this.setAnimationLoop=function(H){N=H},this.dispose=function(){}}}function yw(r){function t(_,y){_.fogColor.value.copy(y.color),y.isFog?(_.fogNear.value=y.near,_.fogFar.value=y.far):y.isFogExp2&&(_.fogDensity.value=y.density)}function e(_,y,M,T,A){y.isMeshBasicMaterial?n(_,y):y.isMeshLambertMaterial?(n(_,y),u(_,y)):y.isMeshToonMaterial?(n(_,y),p(_,y)):y.isMeshPhongMaterial?(n(_,y),h(_,y)):y.isMeshStandardMaterial?(n(_,y),y.isMeshPhysicalMaterial?m(_,y,A):f(_,y)):y.isMeshMatcapMaterial?(n(_,y),v(_,y)):y.isMeshDepthMaterial?(n(_,y),x(_,y)):y.isMeshDistanceMaterial?(n(_,y),b(_,y)):y.isMeshNormalMaterial?(n(_,y),w(_,y)):y.isLineBasicMaterial?(i(_,y),y.isLineDashedMaterial&&s(_,y)):y.isPointsMaterial?a(_,y,M,T):y.isSpriteMaterial?l(_,y):y.isShadowMaterial?(_.color.value.copy(y.color),_.opacity.value=y.opacity):y.isShaderMaterial&&(y.uniformsNeedUpdate=!1)}function n(_,y){_.opacity.value=y.opacity,y.color&&_.diffuse.value.copy(y.color),y.emissive&&_.emissive.value.copy(y.emissive).multiplyScalar(y.emissiveIntensity),y.map&&(_.map.value=y.map),y.alphaMap&&(_.alphaMap.value=y.alphaMap),y.specularMap&&(_.specularMap.value=y.specularMap);const M=r.get(y).envMap;if(M){_.envMap.value=M,_.flipEnvMap.value=M.isCubeTexture&&M._needsFlipEnvMap?-1:1,_.reflectivity.value=y.reflectivity,_.refractionRatio.value=y.refractionRatio;const E=r.get(M).__maxMipLevel;E!==void 0&&(_.maxMipLevel.value=E)}y.lightMap&&(_.lightMap.value=y.lightMap,_.lightMapIntensity.value=y.lightMapIntensity),y.aoMap&&(_.aoMap.value=y.aoMap,_.aoMapIntensity.value=y.aoMapIntensity);let T;y.map?T=y.map:y.specularMap?T=y.specularMap:y.displacementMap?T=y.displacementMap:y.normalMap?T=y.normalMap:y.bumpMap?T=y.bumpMap:y.roughnessMap?T=y.roughnessMap:y.metalnessMap?T=y.metalnessMap:y.alphaMap?T=y.alphaMap:y.emissiveMap?T=y.emissiveMap:y.clearcoatMap?T=y.clearcoatMap:y.clearcoatNormalMap?T=y.clearcoatNormalMap:y.clearcoatRoughnessMap&&(T=y.clearcoatRoughnessMap),T!==void 0&&(T.isWebGLRenderTarget&&(T=T.texture),T.matrixAutoUpdate===!0&&T.updateMatrix(),_.uvTransform.value.copy(T.matrix));let A;y.aoMap?A=y.aoMap:y.lightMap&&(A=y.lightMap),A!==void 0&&(A.isWebGLRenderTarget&&(A=A.texture),A.matrixAutoUpdate===!0&&A.updateMatrix(),_.uv2Transform.value.copy(A.matrix))}function i(_,y){_.diffuse.value.copy(y.color),_.opacity.value=y.opacity}function s(_,y){_.dashSize.value=y.dashSize,_.totalSize.value=y.dashSize+y.gapSize,_.scale.value=y.scale}function a(_,y,M,T){_.diffuse.value.copy(y.color),_.opacity.value=y.opacity,_.size.value=y.size*M,_.scale.value=T*.5,y.map&&(_.map.value=y.map),y.alphaMap&&(_.alphaMap.value=y.alphaMap);let A;y.map?A=y.map:y.alphaMap&&(A=y.alphaMap),A!==void 0&&(A.matrixAutoUpdate===!0&&A.updateMatrix(),_.uvTransform.value.copy(A.matrix))}function l(_,y){_.diffuse.value.copy(y.color),_.opacity.value=y.opacity,_.rotation.value=y.rotation,y.map&&(_.map.value=y.map),y.alphaMap&&(_.alphaMap.value=y.alphaMap);let M;y.map?M=y.map:y.alphaMap&&(M=y.alphaMap),M!==void 0&&(M.matrixAutoUpdate===!0&&M.updateMatrix(),_.uvTransform.value.copy(M.matrix))}function u(_,y){y.emissiveMap&&(_.emissiveMap.value=y.emissiveMap)}function h(_,y){_.specular.value.copy(y.specular),_.shininess.value=Math.max(y.shininess,1e-4),y.emissiveMap&&(_.emissiveMap.value=y.emissiveMap),y.bumpMap&&(_.bumpMap.value=y.bumpMap,_.bumpScale.value=y.bumpScale,y.side===ye&&(_.bumpScale.value*=-1)),y.normalMap&&(_.normalMap.value=y.normalMap,_.normalScale.value.copy(y.normalScale),y.side===ye&&_.normalScale.value.negate()),y.displacementMap&&(_.displacementMap.value=y.displacementMap,_.displacementScale.value=y.displacementScale,_.displacementBias.value=y.displacementBias)}function p(_,y){y.gradientMap&&(_.gradientMap.value=y.gradientMap),y.emissiveMap&&(_.emissiveMap.value=y.emissiveMap),y.bumpMap&&(_.bumpMap.value=y.bumpMap,_.bumpScale.value=y.bumpScale,y.side===ye&&(_.bumpScale.value*=-1)),y.normalMap&&(_.normalMap.value=y.normalMap,_.normalScale.value.copy(y.normalScale),y.side===ye&&_.normalScale.value.negate()),y.displacementMap&&(_.displacementMap.value=y.displacementMap,_.displacementScale.value=y.displacementScale,_.displacementBias.value=y.displacementBias)}function f(_,y){_.roughness.value=y.roughness,_.metalness.value=y.metalness,y.roughnessMap&&(_.roughnessMap.value=y.roughnessMap),y.metalnessMap&&(_.metalnessMap.value=y.metalnessMap),y.emissiveMap&&(_.emissiveMap.value=y.emissiveMap),y.bumpMap&&(_.bumpMap.value=y.bumpMap,_.bumpScale.value=y.bumpScale,y.side===ye&&(_.bumpScale.value*=-1)),y.normalMap&&(_.normalMap.value=y.normalMap,_.normalScale.value.copy(y.normalScale),y.side===ye&&_.normalScale.value.negate()),y.displacementMap&&(_.displacementMap.value=y.displacementMap,_.displacementScale.value=y.displacementScale,_.displacementBias.value=y.displacementBias),r.get(y).envMap&&(_.envMapIntensity.value=y.envMapIntensity)}function m(_,y,M){f(_,y),_.reflectivity.value=y.reflectivity,_.clearcoat.value=y.clearcoat,_.clearcoatRoughness.value=y.clearcoatRoughness,y.sheen&&_.sheen.value.copy(y.sheen),y.clearcoatMap&&(_.clearcoatMap.value=y.clearcoatMap),y.clearcoatRoughnessMap&&(_.clearcoatRoughnessMap.value=y.clearcoatRoughnessMap),y.clearcoatNormalMap&&(_.clearcoatNormalScale.value.copy(y.clearcoatNormalScale),_.clearcoatNormalMap.value=y.clearcoatNormalMap,y.side===ye&&_.clearcoatNormalScale.value.negate()),_.transmission.value=y.transmission,y.transmissionMap&&(_.transmissionMap.value=y.transmissionMap),y.transmission>0&&(_.transmissionSamplerMap.value=M.texture,_.transmissionSamplerSize.value.set(M.width,M.height)),_.thickness.value=y.thickness,y.thicknessMap&&(_.thicknessMap.value=y.thicknessMap),_.attenuationDistance.value=y.attenuationDistance,_.attenuationColor.value.copy(y.attenuationColor)}function v(_,y){y.matcap&&(_.matcap.value=y.matcap),y.bumpMap&&(_.bumpMap.value=y.bumpMap,_.bumpScale.value=y.bumpScale,y.side===ye&&(_.bumpScale.value*=-1)),y.normalMap&&(_.normalMap.value=y.normalMap,_.normalScale.value.copy(y.normalScale),y.side===ye&&_.normalScale.value.negate()),y.displacementMap&&(_.displacementMap.value=y.displacementMap,_.displacementScale.value=y.displacementScale,_.displacementBias.value=y.displacementBias)}function x(_,y){y.displacementMap&&(_.displacementMap.value=y.displacementMap,_.displacementScale.value=y.displacementScale,_.displacementBias.value=y.displacementBias)}function b(_,y){y.displacementMap&&(_.displacementMap.value=y.displacementMap,_.displacementScale.value=y.displacementScale,_.displacementBias.value=y.displacementBias),_.referencePosition.value.copy(y.referencePosition),_.nearDistance.value=y.nearDistance,_.farDistance.value=y.farDistance}function w(_,y){y.bumpMap&&(_.bumpMap.value=y.bumpMap,_.bumpScale.value=y.bumpScale,y.side===ye&&(_.bumpScale.value*=-1)),y.normalMap&&(_.normalMap.value=y.normalMap,_.normalScale.value.copy(y.normalScale),y.side===ye&&_.normalScale.value.negate()),y.displacementMap&&(_.displacementMap.value=y.displacementMap,_.displacementScale.value=y.displacementScale,_.displacementBias.value=y.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function bw(){const r=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return r.style.display="block",r}function ie(r){r=r||{};const t=r.canvas!==void 0?r.canvas:bw(),e=r.context!==void 0?r.context:null,n=r.alpha!==void 0?r.alpha:!1,i=r.depth!==void 0?r.depth:!0,s=r.stencil!==void 0?r.stencil:!0,a=r.antialias!==void 0?r.antialias:!1,l=r.premultipliedAlpha!==void 0?r.premultipliedAlpha:!0,u=r.preserveDrawingBuffer!==void 0?r.preserveDrawingBuffer:!1,h=r.powerPreference!==void 0?r.powerPreference:"default",p=r.failIfMajorPerformanceCaveat!==void 0?r.failIfMajorPerformanceCaveat:!1;let f=null,m=null;const v=[],x=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Yr,this.physicallyCorrectLights=!1,this.toneMapping=Tr,this.toneMappingExposure=1;const b=this;let w=!1,_=0,y=0,M=null,T=-1,A=null;const E=new ne,P=new ne;let I=null,N=t.width,z=t.height,W=1,H=null,D=null;const V=new ne(0,0,N,z),G=new ne(0,0,N,z);let B=!1;const j=[],ot=new pa;let Q=!1,ut=!1,rt=null;const Tt=new Et,ct=new C,ft={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Ft(){return M===null?W:1}let K=e;function Ot(L,Y){for(let q=0;q<L.length;q++){const Z=L[q],pt=t.getContext(Z,Y);if(pt!==null)return pt}return null}try{const L={alpha:n,depth:i,stencil:s,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:u,powerPreference:h,failIfMajorPerformanceCaveat:p};if(t.addEventListener("webglcontextlost",Ht,!1),t.addEventListener("webglcontextrestored",ee,!1),K===null){const Y=["webgl2","webgl","experimental-webgl"];if(b.isWebGL1Renderer===!0&&Y.shift(),K=Ot(Y,L),K===null)throw Ot(Y)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}K.getShaderPrecisionFormat===void 0&&(K.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(L){throw console.error("THREE.WebGLRenderer: "+L.message),L}let Dt,Mt,bt,Nt,tt,et,lt,At,_t,F,R,J,it,gt,xt,Pt,O,mt,ht,U,at,$;function St(){Dt=new Wy(K),Mt=new Uy(K,Dt,r),Dt.init(Mt),at=new vw(K,Dt,Mt),bt=new mw(K,Dt,Mt),j[0]=1029,Nt=new qy,tt=new sw,et=new gw(K,Dt,bt,tt,Mt,at,Nt),lt=new Gy(b),At=new g0(K,Mt),$=new Vy(K,Dt,At,Mt),_t=new jy(K,At,Nt,$),F=new $y(K,_t,At,Nt),mt=new Ky(K),xt=new Hy(tt),R=new iw(b,lt,Dt,Mt,$,xt),J=new yw(tt),it=new ow(tt),gt=new dw(Dt,Mt),O=new Oy(b,lt,bt,F,l),Pt=new _p(b,F,Mt),ht=new zy(K,Dt,Nt,Mt),U=new Xy(K,Dt,Nt,Mt),Nt.programs=R.programs,b.capabilities=Mt,b.extensions=Dt,b.properties=tt,b.renderLists=it,b.shadowMap=Pt,b.state=bt,b.info=Nt}St();const dt=new xw(b,K);this.xr=dt,this.getContext=function(){return K},this.getContextAttributes=function(){return K.getContextAttributes()},this.forceContextLoss=function(){const L=Dt.get("WEBGL_lose_context");L&&L.loseContext()},this.forceContextRestore=function(){const L=Dt.get("WEBGL_lose_context");L&&L.restoreContext()},this.getPixelRatio=function(){return W},this.setPixelRatio=function(L){L!==void 0&&(W=L,this.setSize(N,z,!1))},this.getSize=function(L){return L===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),L=new nt),L.set(N,z)},this.setSize=function(L,Y,q){if(dt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}N=L,z=Y,t.width=Math.floor(L*W),t.height=Math.floor(Y*W),q!==!1&&(t.style.width=L+"px",t.style.height=Y+"px"),this.setViewport(0,0,L,Y)},this.getDrawingBufferSize=function(L){return L===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),L=new nt),L.set(N*W,z*W).floor()},this.setDrawingBufferSize=function(L,Y,q){N=L,z=Y,W=q,t.width=Math.floor(L*q),t.height=Math.floor(Y*q),this.setViewport(0,0,L,Y)},this.getCurrentViewport=function(L){return L===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),L=new ne),L.copy(E)},this.getViewport=function(L){return L.copy(V)},this.setViewport=function(L,Y,q,Z){L.isVector4?V.set(L.x,L.y,L.z,L.w):V.set(L,Y,q,Z),bt.viewport(E.copy(V).multiplyScalar(W).floor())},this.getScissor=function(L){return L.copy(G)},this.setScissor=function(L,Y,q,Z){L.isVector4?G.set(L.x,L.y,L.z,L.w):G.set(L,Y,q,Z),bt.scissor(P.copy(G).multiplyScalar(W).floor())},this.getScissorTest=function(){return B},this.setScissorTest=function(L){bt.setScissorTest(B=L)},this.setOpaqueSort=function(L){H=L},this.setTransparentSort=function(L){D=L},this.getClearColor=function(L){return L===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),L=new yt),L.copy(O.getClearColor())},this.setClearColor=function(){O.setClearColor.apply(O,arguments)},this.getClearAlpha=function(){return O.getClearAlpha()},this.setClearAlpha=function(){O.setClearAlpha.apply(O,arguments)},this.clear=function(L,Y,q){let Z=0;(L===void 0||L)&&(Z|=16384),(Y===void 0||Y)&&(Z|=256),(q===void 0||q)&&(Z|=1024),K.clear(Z)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Ht,!1),t.removeEventListener("webglcontextrestored",ee,!1),it.dispose(),gt.dispose(),tt.dispose(),lt.dispose(),F.dispose(),$.dispose(),dt.dispose(),dt.removeEventListener("sessionstart",Oi),dt.removeEventListener("sessionend",Vi),rt&&(rt.dispose(),rt=null),be.stop()};function Ht(L){L.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),w=!0}function ee(){console.log("THREE.WebGLRenderer: Context Restored."),w=!1;const L=Nt.autoReset,Y=Pt.enabled,q=Pt.autoUpdate,Z=Pt.needsUpdate,pt=Pt.type;St(),Nt.autoReset=L,Pt.enabled=Y,Pt.autoUpdate=q,Pt.needsUpdate=Z,Pt.type=pt}function ge(L){const Y=L.target;Y.removeEventListener("dispose",ge),Ke(Y)}function Ke(L){he(L),tt.remove(L)}function he(L){const Y=tt.get(L).programs;Y!==void 0&&Y.forEach(function(q){R.releaseProgram(q)})}function $e(L,Y){L.render(function(q){b.renderBufferImmediate(q,Y)})}this.renderBufferImmediate=function(L,Y){$.initAttributes();const q=tt.get(L);L.hasPositions&&!q.position&&(q.position=K.createBuffer()),L.hasNormals&&!q.normal&&(q.normal=K.createBuffer()),L.hasUvs&&!q.uv&&(q.uv=K.createBuffer()),L.hasColors&&!q.color&&(q.color=K.createBuffer());const Z=Y.getAttributes();L.hasPositions&&(K.bindBuffer(34962,q.position),K.bufferData(34962,L.positionArray,35048),$.enableAttribute(Z.position),K.vertexAttribPointer(Z.position,3,5126,!1,0,0)),L.hasNormals&&(K.bindBuffer(34962,q.normal),K.bufferData(34962,L.normalArray,35048),$.enableAttribute(Z.normal),K.vertexAttribPointer(Z.normal,3,5126,!1,0,0)),L.hasUvs&&(K.bindBuffer(34962,q.uv),K.bufferData(34962,L.uvArray,35048),$.enableAttribute(Z.uv),K.vertexAttribPointer(Z.uv,2,5126,!1,0,0)),L.hasColors&&(K.bindBuffer(34962,q.color),K.bufferData(34962,L.colorArray,35048),$.enableAttribute(Z.color),K.vertexAttribPointer(Z.color,3,5126,!1,0,0)),$.disableUnusedAttributes(),K.drawArrays(4,0,L.count),L.count=0},this.renderBufferDirect=function(L,Y,q,Z,pt,jt){Y===null&&(Y=ft);const kt=pt.isMesh&&pt.matrixWorld.determinant()<0,It=Gi(L,Y,Z,pt);bt.setMaterial(Z,kt);let Vt=q.index;const Lt=q.attributes.position;if(Vt===null){if(Lt===void 0||Lt.count===0)return}else if(Vt.count===0)return;let Gt=1;Z.wireframe===!0&&(Vt=_t.getWireframeAttribute(q),Gt=2),(Z.morphTargets||Z.morphNormals)&&mt.update(pt,q,Z,It),$.setup(pt,Z,It,q,Vt);let Rt,Zt=ht;Vt!==null&&(Rt=At.get(Vt),Zt=U,Zt.setIndex(Rt));const Ue=Vt!==null?Vt.count:Lt.count,Ee=q.drawRange.start*Gt,ln=q.drawRange.count*Gt,fe=jt!==null?jt.start*Gt:0,Sn=jt!==null?jt.count*Gt:1/0,_e=Math.max(Ee,fe),cn=Math.min(Ue,Ee+ln,fe+Sn)-1,un=Math.max(0,cn-_e+1);if(un!==0){if(pt.isMesh)Z.wireframe===!0?(bt.setLineWidth(Z.wireframeLinewidth*Ft()),Zt.setMode(1)):Zt.setMode(4);else if(pt.isLine){let vi=Z.linewidth;vi===void 0&&(vi=1),bt.setLineWidth(vi*Ft()),pt.isLineSegments?Zt.setMode(1):pt.isLineLoop?Zt.setMode(2):Zt.setMode(3)}else pt.isPoints?Zt.setMode(0):pt.isSprite&&Zt.setMode(4);if(pt.isInstancedMesh)Zt.renderInstances(_e,un,pt.count);else if(q.isInstancedBufferGeometry){const vi=Math.min(q.instanceCount,q._maxInstanceCount);Zt.renderInstances(_e,un,vi)}else Zt.render(_e,un)}},this.compile=function(L,Y){m=gt.get(L),m.init(),L.traverseVisible(function(q){q.isLight&&q.layers.test(Y.layers)&&(m.pushLight(q),q.castShadow&&m.pushShadow(q))}),m.setupLights(),L.traverse(function(q){const Z=q.material;if(Z)if(Array.isArray(Z))for(let pt=0;pt<Z.length;pt++){const jt=Z[pt];Hi(jt,L,q)}else Hi(Z,L,q)})};let ze=null;function xa(L){ze&&ze(L)}function Oi(){be.stop()}function Vi(){be.start()}const be=new op;be.setAnimationLoop(xa),typeof window!="undefined"&&be.setContext(window),this.setAnimationLoop=function(L){ze=L,dt.setAnimationLoop(L),L===null?be.stop():be.start()},dt.addEventListener("sessionstart",Oi),dt.addEventListener("sessionend",Vi),this.render=function(L,Y){if(Y!==void 0&&Y.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(w===!0)return;L.autoUpdate===!0&&L.updateMatrixWorld(),Y.parent===null&&Y.updateMatrixWorld(),dt.enabled===!0&&dt.isPresenting===!0&&(dt.cameraAutoUpdate===!0&&dt.updateCamera(Y),Y=dt.getCamera()),L.isScene===!0&&L.onBeforeRender(b,L,Y,M),m=gt.get(L,x.length),m.init(),x.push(m),Tt.multiplyMatrices(Y.projectionMatrix,Y.matrixWorldInverse),ot.setFromProjectionMatrix(Tt),ut=this.localClippingEnabled,Q=xt.init(this.clippingPlanes,ut,Y),f=it.get(L,v.length),f.init(),v.push(f),zi(L,Y,0,b.sortObjects),f.finish(),b.sortObjects===!0&&f.sort(H,D),Q===!0&&xt.beginShadows();const q=m.state.shadowsArray;Pt.render(q,L,Y),m.setupLights(),m.setupLightsView(Y),Q===!0&&xt.endShadows(),this.info.autoReset===!0&&this.info.reset(),O.render(f,L);const Z=f.opaque,pt=f.transmissive,jt=f.transparent;Z.length>0&&Ui(Z,L,Y),pt.length>0&&an(Z,pt,L,Y),jt.length>0&&Ui(jt,L,Y),M!==null&&(et.updateRenderTargetMipmap(M),et.updateMultisampleRenderTarget(M)),L.isScene===!0&&L.onAfterRender(b,L,Y),bt.buffers.depth.setTest(!0),bt.buffers.depth.setMask(!0),bt.buffers.color.setMask(!0),bt.setPolygonOffset(!1),$.resetDefaultState(),T=-1,A=null,x.pop(),x.length>0?m=x[x.length-1]:m=null,v.pop(),v.length>0?f=v[v.length-1]:f=null};function zi(L,Y,q,Z){if(L.visible===!1)return;if(L.layers.test(Y.layers)){if(L.isGroup)q=L.renderOrder;else if(L.isLOD)L.autoUpdate===!0&&L.update(Y);else if(L.isLight)m.pushLight(L),L.castShadow&&m.pushShadow(L);else if(L.isSprite){if(!L.frustumCulled||ot.intersectsSprite(L)){Z&&ct.setFromMatrixPosition(L.matrixWorld).applyMatrix4(Tt);const kt=F.update(L),It=L.material;It.visible&&f.push(L,kt,It,q,ct.z,null)}}else if(L.isImmediateRenderObject)Z&&ct.setFromMatrixPosition(L.matrixWorld).applyMatrix4(Tt),f.push(L,null,L.material,q,ct.z,null);else if((L.isMesh||L.isLine||L.isPoints)&&(L.isSkinnedMesh&&L.skeleton.frame!==Nt.render.frame&&(L.skeleton.update(),L.skeleton.frame=Nt.render.frame),!L.frustumCulled||ot.intersectsObject(L))){Z&&ct.setFromMatrixPosition(L.matrixWorld).applyMatrix4(Tt);const kt=F.update(L),It=L.material;if(Array.isArray(It)){const Vt=kt.groups;for(let Lt=0,Gt=Vt.length;Lt<Gt;Lt++){const Rt=Vt[Lt],Zt=It[Rt.materialIndex];Zt&&Zt.visible&&f.push(L,kt,Zt,q,ct.z,Rt)}}else It.visible&&f.push(L,kt,It,q,ct.z,null)}}const jt=L.children;for(let kt=0,It=jt.length;kt<It;kt++)zi(jt[kt],Y,q,Z)}function an(L,Y,q,Z){rt===null&&(rt=new rn(1024,1024,{generateMipmaps:!0,minFilter:Bs,magFilter:oe,wrapS:Ve,wrapT:Ve}));const pt=b.getRenderTarget();b.setRenderTarget(rt),b.clear(),Ui(L,q,Z),et.updateRenderTargetMipmap(rt),b.setRenderTarget(pt),Ui(Y,q,Z)}function Ui(L,Y,q){const Z=Y.isScene===!0?Y.overrideMaterial:null;for(let pt=0,jt=L.length;pt<jt;pt++){const kt=L[pt],It=kt.object,Vt=kt.geometry,Lt=Z===null?kt.material:Z,Gt=kt.group;if(q.isArrayCamera){const Rt=q.cameras;for(let Zt=0,Ue=Rt.length;Zt<Ue;Zt++){const Ee=Rt[Zt];It.layers.test(Ee.layers)&&(bt.viewport(E.copy(Ee.viewport)),m.setupLightsView(Ee),Hn(It,Y,Ee,Vt,Lt,Gt))}}else Hn(It,Y,q,Vt,Lt,Gt)}}function Hn(L,Y,q,Z,pt,jt){if(L.onBeforeRender(b,Y,q,Z,pt,jt),L.modelViewMatrix.multiplyMatrices(q.matrixWorldInverse,L.matrixWorld),L.normalMatrix.getNormalMatrix(L.modelViewMatrix),L.isImmediateRenderObject){const kt=Gi(q,Y,pt,L);bt.setMaterial(pt),$.reset(),$e(L,kt)}else b.renderBufferDirect(q,Y,Z,pt,L,jt);L.onAfterRender(b,Y,q,Z,pt,jt)}function Hi(L,Y,q){Y.isScene!==!0&&(Y=ft);const Z=tt.get(L),pt=m.state.lights,jt=m.state.shadowsArray,kt=pt.state.version,It=R.getParameters(L,pt.state,jt,Y,q),Vt=R.getProgramCacheKey(It);let Lt=Z.programs;Z.environment=L.isMeshStandardMaterial?Y.environment:null,Z.fog=Y.fog,Z.envMap=lt.get(L.envMap||Z.environment),Lt===void 0&&(L.addEventListener("dispose",ge),Lt=new Map,Z.programs=Lt);let Gt=Lt.get(Vt);if(Gt!==void 0){if(Z.currentProgram===Gt&&Z.lightsStateVersion===kt)return gi(L,It),Gt}else It.uniforms=R.getUniforms(L),L.onBuild(It,b),L.onBeforeCompile(It,b),Gt=R.acquireProgram(It,Vt),Lt.set(Vt,Gt),Z.uniforms=It.uniforms;const Rt=Z.uniforms;(!L.isShaderMaterial&&!L.isRawShaderMaterial||L.clipping===!0)&&(Rt.clippingPlanes=xt.uniform),gi(L,It),Z.needsLights=ya(L),Z.lightsStateVersion=kt,Z.needsLights&&(Rt.ambientLightColor.value=pt.state.ambient,Rt.lightProbe.value=pt.state.probe,Rt.directionalLights.value=pt.state.directional,Rt.directionalLightShadows.value=pt.state.directionalShadow,Rt.spotLights.value=pt.state.spot,Rt.spotLightShadows.value=pt.state.spotShadow,Rt.rectAreaLights.value=pt.state.rectArea,Rt.ltc_1.value=pt.state.rectAreaLTC1,Rt.ltc_2.value=pt.state.rectAreaLTC2,Rt.pointLights.value=pt.state.point,Rt.pointLightShadows.value=pt.state.pointShadow,Rt.hemisphereLights.value=pt.state.hemi,Rt.directionalShadowMap.value=pt.state.directionalShadowMap,Rt.directionalShadowMatrix.value=pt.state.directionalShadowMatrix,Rt.spotShadowMap.value=pt.state.spotShadowMap,Rt.spotShadowMatrix.value=pt.state.spotShadowMatrix,Rt.pointShadowMap.value=pt.state.pointShadowMap,Rt.pointShadowMatrix.value=pt.state.pointShadowMatrix);const Zt=Gt.getUniforms(),Ue=ci.seqWithValue(Zt.seq,Rt);return Z.currentProgram=Gt,Z.uniformsList=Ue,Gt}function gi(L,Y){const q=tt.get(L);q.outputEncoding=Y.outputEncoding,q.instancing=Y.instancing,q.skinning=Y.skinning,q.numClippingPlanes=Y.numClippingPlanes,q.numIntersection=Y.numClipIntersection,q.vertexAlphas=Y.vertexAlphas}function Gi(L,Y,q,Z){Y.isScene!==!0&&(Y=ft),et.resetTextureUnits();const pt=Y.fog,jt=q.isMeshStandardMaterial?Y.environment:null,kt=M===null?b.outputEncoding:M.texture.encoding,It=lt.get(q.envMap||jt),Vt=q.vertexColors===!0&&Z.geometry&&Z.geometry.attributes.color&&Z.geometry.attributes.color.itemSize===4,Lt=tt.get(q),Gt=m.state.lights;if(Q===!0&&(ut===!0||L!==A)){const _e=L===A&&q.id===T;xt.setState(q,L,_e)}let Rt=!1;q.version===Lt.__version?(Lt.needsLights&&Lt.lightsStateVersion!==Gt.state.version||Lt.outputEncoding!==kt||Z.isInstancedMesh&&Lt.instancing===!1||!Z.isInstancedMesh&&Lt.instancing===!0||Z.isSkinnedMesh&&Lt.skinning===!1||!Z.isSkinnedMesh&&Lt.skinning===!0||Lt.envMap!==It||q.fog&&Lt.fog!==pt||Lt.numClippingPlanes!==void 0&&(Lt.numClippingPlanes!==xt.numPlanes||Lt.numIntersection!==xt.numIntersection)||Lt.vertexAlphas!==Vt)&&(Rt=!0):(Rt=!0,Lt.__version=q.version);let Zt=Lt.currentProgram;Rt===!0&&(Zt=Hi(q,Y,Z));let Ue=!1,Ee=!1,ln=!1;const fe=Zt.getUniforms(),Sn=Lt.uniforms;if(bt.useProgram(Zt.program)&&(Ue=!0,Ee=!0,ln=!0),q.id!==T&&(T=q.id,Ee=!0),Ue||A!==L){if(fe.setValue(K,"projectionMatrix",L.projectionMatrix),Mt.logarithmicDepthBuffer&&fe.setValue(K,"logDepthBufFC",2/(Math.log(L.far+1)/Math.LN2)),A!==L&&(A=L,Ee=!0,ln=!0),q.isShaderMaterial||q.isMeshPhongMaterial||q.isMeshToonMaterial||q.isMeshStandardMaterial||q.envMap){const _e=fe.map.cameraPosition;_e!==void 0&&_e.setValue(K,ct.setFromMatrixPosition(L.matrixWorld))}(q.isMeshPhongMaterial||q.isMeshToonMaterial||q.isMeshLambertMaterial||q.isMeshBasicMaterial||q.isMeshStandardMaterial||q.isShaderMaterial)&&fe.setValue(K,"isOrthographic",L.isOrthographicCamera===!0),(q.isMeshPhongMaterial||q.isMeshToonMaterial||q.isMeshLambertMaterial||q.isMeshBasicMaterial||q.isMeshStandardMaterial||q.isShaderMaterial||q.isShadowMaterial||Z.isSkinnedMesh)&&fe.setValue(K,"viewMatrix",L.matrixWorldInverse)}if(Z.isSkinnedMesh){fe.setOptional(K,Z,"bindMatrix"),fe.setOptional(K,Z,"bindMatrixInverse");const _e=Z.skeleton;_e&&(Mt.floatVertexTextures?(_e.boneTexture===null&&_e.computeBoneTexture(),fe.setValue(K,"boneTexture",_e.boneTexture,et),fe.setValue(K,"boneTextureSize",_e.boneTextureSize)):fe.setOptional(K,_e,"boneMatrices"))}return(Ee||Lt.receiveShadow!==Z.receiveShadow)&&(Lt.receiveShadow=Z.receiveShadow,fe.setValue(K,"receiveShadow",Z.receiveShadow)),Ee&&(fe.setValue(K,"toneMappingExposure",b.toneMappingExposure),Lt.needsLights&&Ws(Sn,ln),pt&&q.fog&&J.refreshFogUniforms(Sn,pt),J.refreshMaterialUniforms(Sn,q,W,z,rt),ci.upload(K,Lt.uniformsList,Sn,et)),q.isShaderMaterial&&q.uniformsNeedUpdate===!0&&(ci.upload(K,Lt.uniformsList,Sn,et),q.uniformsNeedUpdate=!1),q.isSpriteMaterial&&fe.setValue(K,"center",Z.center),fe.setValue(K,"modelViewMatrix",Z.modelViewMatrix),fe.setValue(K,"normalMatrix",Z.normalMatrix),fe.setValue(K,"modelMatrix",Z.matrixWorld),Zt}function Ws(L,Y){L.ambientLightColor.needsUpdate=Y,L.lightProbe.needsUpdate=Y,L.directionalLights.needsUpdate=Y,L.directionalLightShadows.needsUpdate=Y,L.pointLights.needsUpdate=Y,L.pointLightShadows.needsUpdate=Y,L.spotLights.needsUpdate=Y,L.spotLightShadows.needsUpdate=Y,L.rectAreaLights.needsUpdate=Y,L.hemisphereLights.needsUpdate=Y}function ya(L){return L.isMeshLambertMaterial||L.isMeshToonMaterial||L.isMeshPhongMaterial||L.isMeshStandardMaterial||L.isShadowMaterial||L.isShaderMaterial&&L.lights===!0}this.getActiveCubeFace=function(){return _},this.getActiveMipmapLevel=function(){return y},this.getRenderTarget=function(){return M},this.setRenderTarget=function(L,Y=0,q=0){M=L,_=Y,y=q,L&&tt.get(L).__webglFramebuffer===void 0&&et.setupRenderTarget(L);let Z=null,pt=!1,jt=!1;if(L){const It=L.texture;(It.isDataTexture3D||It.isDataTexture2DArray)&&(jt=!0);const Vt=tt.get(L).__webglFramebuffer;L.isWebGLCubeRenderTarget?(Z=Vt[Y],pt=!0):L.isWebGLMultisampleRenderTarget?Z=tt.get(L).__webglMultisampledFramebuffer:Z=Vt,E.copy(L.viewport),P.copy(L.scissor),I=L.scissorTest}else E.copy(V).multiplyScalar(W).floor(),P.copy(G).multiplyScalar(W).floor(),I=B;if(bt.bindFramebuffer(36160,Z)&&Mt.drawBuffers){let It=!1;if(L)if(L.isWebGLMultipleRenderTargets){const Vt=L.texture;if(j.length!==Vt.length||j[0]!==36064){for(let Lt=0,Gt=Vt.length;Lt<Gt;Lt++)j[Lt]=36064+Lt;j.length=Vt.length,It=!0}}else(j.length!==1||j[0]!==36064)&&(j[0]=36064,j.length=1,It=!0);else(j.length!==1||j[0]!==1029)&&(j[0]=1029,j.length=1,It=!0);It&&(Mt.isWebGL2?K.drawBuffers(j):Dt.get("WEBGL_draw_buffers").drawBuffersWEBGL(j))}if(bt.viewport(E),bt.scissor(P),bt.setScissorTest(I),pt){const It=tt.get(L.texture);K.framebufferTexture2D(36160,36064,34069+Y,It.__webglTexture,q)}else if(jt){const It=tt.get(L.texture),Vt=Y||0;K.framebufferTextureLayer(36160,36064,It.__webglTexture,q||0,Vt)}},this.readRenderTargetPixels=function(L,Y,q,Z,pt,jt,kt){if(!(L&&L.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let It=tt.get(L).__webglFramebuffer;if(L.isWebGLCubeRenderTarget&&kt!==void 0&&(It=It[kt]),It){bt.bindFramebuffer(36160,It);try{const Vt=L.texture,Lt=Vt.format,Gt=Vt.type;if(Lt!==Fe&&at.convert(Lt)!==K.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Rt=Gt===sa&&(Dt.has("EXT_color_buffer_half_float")||Mt.isWebGL2&&Dt.has("EXT_color_buffer_float"));if(Gt!==Dr&&at.convert(Gt)!==K.getParameter(35738)&&!(Gt===Ne&&(Mt.isWebGL2||Dt.has("OES_texture_float")||Dt.has("WEBGL_color_buffer_float")))&&!Rt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}K.checkFramebufferStatus(36160)===36053?Y>=0&&Y<=L.width-Z&&q>=0&&q<=L.height-pt&&K.readPixels(Y,q,Z,pt,at.convert(Lt),at.convert(Gt),jt):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Vt=M!==null?tt.get(M).__webglFramebuffer:null;bt.bindFramebuffer(36160,Vt)}}},this.copyFramebufferToTexture=function(L,Y,q=0){const Z=Math.pow(2,-q),pt=Math.floor(Y.image.width*Z),jt=Math.floor(Y.image.height*Z);let kt=at.convert(Y.format);Mt.isWebGL2&&(kt===6407&&(kt=32849),kt===6408&&(kt=32856)),et.setTexture2D(Y,0),K.copyTexImage2D(3553,q,kt,L.x,L.y,pt,jt,0),bt.unbindTexture()},this.copyTextureToTexture=function(L,Y,q,Z=0){const pt=Y.image.width,jt=Y.image.height,kt=at.convert(q.format),It=at.convert(q.type);et.setTexture2D(q,0),K.pixelStorei(37440,q.flipY),K.pixelStorei(37441,q.premultiplyAlpha),K.pixelStorei(3317,q.unpackAlignment),Y.isDataTexture?K.texSubImage2D(3553,Z,L.x,L.y,pt,jt,kt,It,Y.image.data):Y.isCompressedTexture?K.compressedTexSubImage2D(3553,Z,L.x,L.y,Y.mipmaps[0].width,Y.mipmaps[0].height,kt,Y.mipmaps[0].data):K.texSubImage2D(3553,Z,L.x,L.y,kt,It,Y.image),Z===0&&q.generateMipmaps&&K.generateMipmap(3553),bt.unbindTexture()},this.copyTextureToTexture3D=function(L,Y,q,Z,pt=0){if(b.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const{width:jt,height:kt,data:It}=q.image,Vt=at.convert(Z.format),Lt=at.convert(Z.type);let Gt;if(Z.isDataTexture3D)et.setTexture3D(Z,0),Gt=32879;else if(Z.isDataTexture2DArray)et.setTexture2DArray(Z,0),Gt=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}K.pixelStorei(37440,Z.flipY),K.pixelStorei(37441,Z.premultiplyAlpha),K.pixelStorei(3317,Z.unpackAlignment);const Rt=K.getParameter(3314),Zt=K.getParameter(32878),Ue=K.getParameter(3316),Ee=K.getParameter(3315),ln=K.getParameter(32877);K.pixelStorei(3314,jt),K.pixelStorei(32878,kt),K.pixelStorei(3316,L.min.x),K.pixelStorei(3315,L.min.y),K.pixelStorei(32877,L.min.z),K.texSubImage3D(Gt,pt,Y.x,Y.y,Y.z,L.max.x-L.min.x+1,L.max.y-L.min.y+1,L.max.z-L.min.z+1,Vt,Lt,It),K.pixelStorei(3314,Rt),K.pixelStorei(32878,Zt),K.pixelStorei(3316,Ue),K.pixelStorei(3315,Ee),K.pixelStorei(32877,ln),pt===0&&Z.generateMipmaps&&K.generateMipmap(Gt),bt.unbindTexture()},this.initTexture=function(L){et.setTexture2D(L,0),bt.unbindTexture()},this.resetState=function(){_=0,y=0,M=null,bt.reset(),$.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class ww extends ie{}ww.prototype.isWebGL1Renderer=!0;class mc extends Wt{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.background!==null&&(e.object.background=this.background.toJSON(t)),this.environment!==null&&(e.object.environment=this.environment.toJSON(t)),this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}mc.prototype.isScene=!0;class ki{constructor(t,e){this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=Or,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Ye()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,s=this.stride;i<s;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ye()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ye()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}ki.prototype.isInterleavedBuffer=!0;const me=new C;class Ii{constructor(t,e,n,i){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=i===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)me.x=this.getX(e),me.y=this.getY(e),me.z=this.getZ(e),me.applyMatrix4(t),this.setXYZ(e,me.x,me.y,me.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)me.x=this.getX(e),me.y=this.getY(e),me.z=this.getZ(e),me.applyNormalMatrix(t),this.setXYZ(e,me.x,me.y,me.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)me.x=this.getX(e),me.y=this.getY(e),me.z=this.getZ(e),me.transformDirection(t),this.setXYZ(e,me.x,me.y,me.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,s){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=s,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[i+s])}return new ae(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Ii(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[i+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Ii.prototype.isInterleavedBufferAttribute=!0;class yp extends Me{constructor(t){super(),this.type="SpriteMaterial",this.color=new yt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}yp.prototype.isSpriteMaterial=!0;let ps;const cr=new C,fs=new C,ms=new C,gs=new nt,ur=new nt,bp=new Et,Ao=new C,hr=new C,Co=new C,Fh=new nt,yl=new nt,kh=new nt;class Mw extends Wt{constructor(t){if(super(),this.type="Sprite",ps===void 0){ps=new Yt;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new ki(e,5);ps.setIndex([0,1,2,0,2,3]),ps.setAttribute("position",new Ii(n,3,0,!1)),ps.setAttribute("uv",new Ii(n,2,3,!1))}this.geometry=ps,this.material=t!==void 0?t:new yp,this.center=new nt(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),fs.setFromMatrixScale(this.matrixWorld),bp.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),ms.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&fs.multiplyScalar(-ms.z);const n=this.material.rotation;let i,s;n!==0&&(s=Math.cos(n),i=Math.sin(n));const a=this.center;Po(Ao.set(-.5,-.5,0),ms,a,fs,i,s),Po(hr.set(.5,-.5,0),ms,a,fs,i,s),Po(Co.set(.5,.5,0),ms,a,fs,i,s),Fh.set(0,0),yl.set(1,0),kh.set(1,1);let l=t.ray.intersectTriangle(Ao,hr,Co,!1,cr);if(l===null&&(Po(hr.set(-.5,.5,0),ms,a,fs,i,s),yl.set(0,1),l=t.ray.intersectTriangle(Ao,Co,hr,!1,cr),l===null))return;const u=t.ray.origin.distanceTo(cr);u<t.near||u>t.far||e.push({distance:u,point:cr.clone(),uv:de.getUV(cr,Ao,hr,Co,Fh,yl,kh,new nt),face:null,object:this})}copy(t){return super.copy(t),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}Mw.prototype.isSprite=!0;function Po(r,t,e,n,i,s){gs.subVectors(r,e).addScalar(.5).multiply(n),i!==void 0?(ur.x=s*gs.x-i*gs.y,ur.y=i*gs.x+s*gs.y):ur.copy(gs),r.copy(t),r.x+=ur.x,r.y+=ur.y,r.applyMatrix4(bp)}const Bh=new C,Oh=new ne,Vh=new ne,Ew=new C,zh=new Et;class gc extends wt{constructor(t,e){super(t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Et,this.bindMatrixInverse=new Et}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new ne,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const s=1/t.manhattanLength();s!==1/0?t.multiplyScalar(s):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,i=this.geometry;Oh.fromBufferAttribute(i.attributes.skinIndex,t),Vh.fromBufferAttribute(i.attributes.skinWeight,t),Bh.fromBufferAttribute(i.attributes.position,t).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let s=0;s<4;s++){const a=Vh.getComponent(s);if(a!==0){const l=Oh.getComponent(s);zh.multiplyMatrices(n.bones[l].matrixWorld,n.boneInverses[l]),e.addScaledVector(Ew.copy(Bh).applyMatrix4(zh),a)}}return e.applyMatrix4(this.bindMatrixInverse)}}gc.prototype.isSkinnedMesh=!0;class vc extends Wt{constructor(){super(),this.type="Bone"}}vc.prototype.isBone=!0;class zr extends Ce{constructor(t,e,n,i,s,a,l,u,h,p,f,m){super(null,a,l,u,h,p,i,s,f,m),this.image={data:t||null,width:e||1,height:n||1},this.magFilter=h!==void 0?h:oe,this.minFilter=p!==void 0?p:oe,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}zr.prototype.isDataTexture=!0;const Uh=new Et,Sw=new Et;class _c{constructor(t=[],e=[]){this.uuid=Ye(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(t.length*16),e.length===0)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new Et)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const n=new Et;this.bones[t]&&n.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const n=this.bones[t];n&&n.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const n=this.bones[t];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let s=0,a=t.length;s<a;s++){const l=t[s]?t[s].matrixWorld:Sw;Uh.multiplyMatrices(l,e[s]),Uh.toArray(n,s*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new _c(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(this.bones.length*4);t=Jd(t),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const n=new zr(e,t,t,Fe,Ne);return this.boneMatrices=e,this.boneTexture=n,this.boneTextureSize=t,this}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const i=this.bones[e];if(i.name===t)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let n=0,i=t.bones.length;n<i;n++){const s=t.bones[n];let a=e[s];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),a=new vc),this.bones.push(a),this.boneInverses.push(new Et().fromArray(t.boneInverses[n]))}return this.init(),this}toJSON(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let i=0,s=e.length;i<s;i++){const a=e[i];t.bones.push(a.uuid);const l=n[i];t.boneInverses.push(l.toArray())}return t}}const Hh=new Et,Gh=new Et,Lo=[],dr=new wt;class Tw extends wt{constructor(t,e,n){super(t,e),this.instanceMatrix=new ae(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}raycast(t,e){const n=this.matrixWorld,i=this.count;if(dr.geometry=this.geometry,dr.material=this.material,dr.material!==void 0)for(let s=0;s<i;s++){this.getMatrixAt(s,Hh),Gh.multiplyMatrices(n,Hh),dr.matrixWorld=Gh,dr.raycast(t,Lo);for(let a=0,l=Lo.length;a<l;a++){const u=Lo[a];u.instanceId=s,u.object=this,e.push(u)}Lo.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new ae(new Float32Array(this.count*3),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}Tw.prototype.isInstancedMesh=!0;class Bi extends Me{constructor(t){super(),this.type="LineBasicMaterial",this.color=new yt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.morphTargets=t.morphTargets,this}}Bi.prototype.isLineBasicMaterial=!0;const Wh=new C,jh=new C,Xh=new Et,bl=new Ni,Ro=new mi;class Xt extends Wt{constructor(t=new Yt,e=new Bi){super(),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[0];for(let i=1,s=e.count;i<s;i++)Wh.fromBufferAttribute(e,i-1),jh.fromBufferAttribute(e,i),n[i]=n[i-1],n[i]+=Wh.distanceTo(jh);t.setAttribute("lineDistance",new qt(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,s=t.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Ro.copy(n.boundingSphere),Ro.applyMatrix4(i),Ro.radius+=s,t.ray.intersectsSphere(Ro)===!1)return;Xh.copy(i).invert(),bl.copy(t.ray).applyMatrix4(Xh);const l=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=l*l,h=new C,p=new C,f=new C,m=new C,v=this.isLineSegments?2:1;if(n.isBufferGeometry){const x=n.index,w=n.attributes.position;if(x!==null){const _=Math.max(0,a.start),y=Math.min(x.count,a.start+a.count);for(let M=_,T=y-1;M<T;M+=v){const A=x.getX(M),E=x.getX(M+1);if(h.fromBufferAttribute(w,A),p.fromBufferAttribute(w,E),bl.distanceSqToSegment(h,p,m,f)>u)continue;m.applyMatrix4(this.matrixWorld);const I=t.ray.origin.distanceTo(m);I<t.near||I>t.far||e.push({distance:I,point:f.clone().applyMatrix4(this.matrixWorld),index:M,face:null,faceIndex:null,object:this})}}else{const _=Math.max(0,a.start),y=Math.min(w.count,a.start+a.count);for(let M=_,T=y-1;M<T;M+=v){if(h.fromBufferAttribute(w,M),p.fromBufferAttribute(w,M+1),bl.distanceSqToSegment(h,p,m,f)>u)continue;m.applyMatrix4(this.matrixWorld);const E=t.ray.origin.distanceTo(m);E<t.near||E>t.far||e.push({distance:E,point:f.clone().applyMatrix4(this.matrixWorld),index:M,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const l=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Xt.prototype.isLine=!0;const qh=new C,Yh=new C;class fa extends Xt{constructor(t,e){super(t,e),this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[];for(let i=0,s=e.count;i<s;i+=2)qh.fromBufferAttribute(e,i),Yh.fromBufferAttribute(e,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+qh.distanceTo(Yh);t.setAttribute("lineDistance",new qt(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}fa.prototype.isLineSegments=!0;class wp extends Xt{constructor(t,e){super(t,e),this.type="LineLoop"}}wp.prototype.isLineLoop=!0;class xc extends Me{constructor(t){super(),this.type="PointsMaterial",this.color=new yt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.morphTargets=t.morphTargets,this}}xc.prototype.isPointsMaterial=!0;const Zh=new Et,Gl=new Ni,Io=new mi,Do=new C;class Mp extends Wt{constructor(t=new Yt,e=new xc){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,s=t.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Io.copy(n.boundingSphere),Io.applyMatrix4(i),Io.radius+=s,t.ray.intersectsSphere(Io)===!1)return;Zh.copy(i).invert(),Gl.copy(t.ray).applyMatrix4(Zh);const l=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=l*l;if(n.isBufferGeometry){const h=n.index,f=n.attributes.position;if(h!==null){const m=Math.max(0,a.start),v=Math.min(h.count,a.start+a.count);for(let x=m,b=v;x<b;x++){const w=h.getX(x);Do.fromBufferAttribute(f,w),Kh(Do,w,u,i,t,e,this)}}else{const m=Math.max(0,a.start),v=Math.min(f.count,a.start+a.count);for(let x=m,b=v;x<b;x++)Do.fromBufferAttribute(f,x),Kh(Do,x,u,i,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const l=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Mp.prototype.isPoints=!0;function Kh(r,t,e,n,i,s,a){const l=Gl.distanceSqToPoint(r);if(l<e){const u=new C;Gl.closestPointToPoint(r,u),u.applyMatrix4(n);const h=i.ray.origin.distanceTo(u);if(h<i.near||h>i.far)return;s.push({distance:h,distanceToRay:Math.sqrt(l),point:u,index:t,face:null,object:a})}}class Aw extends Ce{constructor(t,e,n,i,s,a,l,u,h){super(t,e,n,i,s,a,l,u,h),this.format=l!==void 0?l:li,this.minFilter=a!==void 0?a:Re,this.magFilter=s!==void 0?s:Re,this.generateMipmaps=!1;const p=this;function f(){p.needsUpdate=!0,t.requestVideoFrameCallback(f)}"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(f)}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}Aw.prototype.isVideoTexture=!0;class Cw extends Ce{constructor(t,e,n,i,s,a,l,u,h,p,f,m){super(null,a,l,u,h,p,i,s,f,m),this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}Cw.prototype.isCompressedTexture=!0;class Ep extends Ce{constructor(t,e,n,i,s,a,l,u,h){super(t,e,n,i,s,a,l,u,h),this.needsUpdate=!0}}Ep.prototype.isCanvasTexture=!0;class Pw extends Ce{constructor(t,e,n,i,s,a,l,u,h,p){if(p=p!==void 0?p:Cs,p!==Cs&&p!==Fr)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&p===Cs&&(n=Nr),n===void 0&&p===Fr&&(n=Ar),super(null,i,s,a,l,u,p,n,h),this.image={width:t,height:e},this.magFilter=l!==void 0?l:oe,this.minFilter=u!==void 0?u:oe,this.flipY=!1,this.generateMipmaps=!1}}Pw.prototype.isDepthTexture=!0;class en extends Yt{constructor(t=1,e=1,n=1,i=8,s=1,a=!1,l=0,u=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:i,heightSegments:s,openEnded:a,thetaStart:l,thetaLength:u};const h=this;i=Math.floor(i),s=Math.floor(s);const p=[],f=[],m=[],v=[];let x=0;const b=[],w=n/2;let _=0;y(),a===!1&&(t>0&&M(!0),e>0&&M(!1)),this.setIndex(p),this.setAttribute("position",new qt(f,3)),this.setAttribute("normal",new qt(m,3)),this.setAttribute("uv",new qt(v,2));function y(){const T=new C,A=new C;let E=0;const P=(e-t)/n;for(let I=0;I<=s;I++){const N=[],z=I/s,W=z*(e-t)+t;for(let H=0;H<=i;H++){const D=H/i,V=D*u+l,G=Math.sin(V),B=Math.cos(V);A.x=W*G,A.y=-z*n+w,A.z=W*B,f.push(A.x,A.y,A.z),T.set(G,P,B).normalize(),m.push(T.x,T.y,T.z),v.push(D,1-z),N.push(x++)}b.push(N)}for(let I=0;I<i;I++)for(let N=0;N<s;N++){const z=b[N][I],W=b[N+1][I],H=b[N+1][I+1],D=b[N][I+1];p.push(z,W,D),p.push(W,H,D),E+=6}h.addGroup(_,E,0),_+=E}function M(T){const A=x,E=new nt,P=new C;let I=0;const N=T===!0?t:e,z=T===!0?1:-1;for(let H=1;H<=i;H++)f.push(0,w*z,0),m.push(0,z,0),v.push(.5,.5),x++;const W=x;for(let H=0;H<=i;H++){const V=H/i*u+l,G=Math.cos(V),B=Math.sin(V);P.x=N*B,P.y=w*z,P.z=N*G,f.push(P.x,P.y,P.z),m.push(0,z,0),E.x=G*.5+.5,E.y=B*.5*z+.5,v.push(E.x,E.y),x++}for(let H=0;H<i;H++){const D=A+H,V=W+H;T===!0?p.push(V,V+1,D):p.push(V+1,V,D),I+=3}h.addGroup(_,I,T===!0?1:2),_+=I}}}class Lw extends Yt{constructor(t,e,n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:i};const s=[],a=[];l(i),h(n),p(),this.setAttribute("position",new qt(s,3)),this.setAttribute("normal",new qt(s.slice(),3)),this.setAttribute("uv",new qt(a,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function l(y){const M=new C,T=new C,A=new C;for(let E=0;E<e.length;E+=3)v(e[E+0],M),v(e[E+1],T),v(e[E+2],A),u(M,T,A,y)}function u(y,M,T,A){const E=A+1,P=[];for(let I=0;I<=E;I++){P[I]=[];const N=y.clone().lerp(T,I/E),z=M.clone().lerp(T,I/E),W=E-I;for(let H=0;H<=W;H++)H===0&&I===E?P[I][H]=N:P[I][H]=N.clone().lerp(z,H/W)}for(let I=0;I<E;I++)for(let N=0;N<2*(E-I)-1;N++){const z=Math.floor(N/2);N%2===0?(m(P[I][z+1]),m(P[I+1][z]),m(P[I][z])):(m(P[I][z+1]),m(P[I+1][z+1]),m(P[I+1][z]))}}function h(y){const M=new C;for(let T=0;T<s.length;T+=3)M.x=s[T+0],M.y=s[T+1],M.z=s[T+2],M.normalize().multiplyScalar(y),s[T+0]=M.x,s[T+1]=M.y,s[T+2]=M.z}function p(){const y=new C;for(let M=0;M<s.length;M+=3){y.x=s[M+0],y.y=s[M+1],y.z=s[M+2];const T=w(y)/2/Math.PI+.5,A=_(y)/Math.PI+.5;a.push(T,1-A)}x(),f()}function f(){for(let y=0;y<a.length;y+=6){const M=a[y+0],T=a[y+2],A=a[y+4],E=Math.max(M,T,A),P=Math.min(M,T,A);E>.9&&P<.1&&(M<.2&&(a[y+0]+=1),T<.2&&(a[y+2]+=1),A<.2&&(a[y+4]+=1))}}function m(y){s.push(y.x,y.y,y.z)}function v(y,M){const T=y*3;M.x=t[T+0],M.y=t[T+1],M.z=t[T+2]}function x(){const y=new C,M=new C,T=new C,A=new C,E=new nt,P=new nt,I=new nt;for(let N=0,z=0;N<s.length;N+=9,z+=6){y.set(s[N+0],s[N+1],s[N+2]),M.set(s[N+3],s[N+4],s[N+5]),T.set(s[N+6],s[N+7],s[N+8]),E.set(a[z+0],a[z+1]),P.set(a[z+2],a[z+3]),I.set(a[z+4],a[z+5]),A.copy(y).add(M).add(T).divideScalar(3);const W=w(A);b(E,z+0,y,W),b(P,z+2,M,W),b(I,z+4,T,W)}}function b(y,M,T,A){A<0&&y.x===1&&(a[M]=y.x-1),T.x===0&&T.z===0&&(a[M]=A/2/Math.PI+.5)}function w(y){return Math.atan2(y.z,-y.x)}function _(y){return Math.atan2(-y.y,Math.sqrt(y.x*y.x+y.z*y.z))}}}new C;new C;new C;new de;const Rw={triangulate:function(r,t,e){e=e||2;const n=t&&t.length,i=n?t[0]*e:r.length;let s=Sp(r,0,i,e,!0);const a=[];if(!s||s.next===s.prev)return a;let l,u,h,p,f,m,v;if(n&&(s=kw(r,t,s,e)),r.length>80*e){l=h=r[0],u=p=r[1];for(let x=e;x<i;x+=e)f=r[x],m=r[x+1],f<l&&(l=f),m<u&&(u=m),f>h&&(h=f),m>p&&(p=m);v=Math.max(h-l,p-u),v=v!==0?1/v:0}return Ur(s,a,e,l,u,v),a}};function Sp(r,t,e,n,i){let s,a;if(i===qw(r,t,e,n)>0)for(s=t;s<e;s+=n)a=$h(s,r[s],r[s+1],a);else for(s=e-n;s>=t;s-=n)a=$h(s,r[s],r[s+1],a);return a&&ma(a,a.next)&&(Gr(a),a=a.next),a}function pi(r,t){if(!r)return r;t||(t=r);let e=r,n;do if(n=!1,!e.steiner&&(ma(e,e.next)||pe(e.prev,e,e.next)===0)){if(Gr(e),e=t=e.prev,e===e.next)break;n=!0}else e=e.next;while(n||e!==t);return t}function Ur(r,t,e,n,i,s,a){if(!r)return;!a&&s&&Uw(r,n,i,s);let l=r,u,h;for(;r.prev!==r.next;){if(u=r.prev,h=r.next,s?Dw(r,n,i,s):Iw(r)){t.push(u.i/e),t.push(r.i/e),t.push(h.i/e),Gr(r),r=h.next,l=h.next;continue}if(r=h,r===l){a?a===1?(r=Nw(pi(r),t,e),Ur(r,t,e,n,i,s,2)):a===2&&Fw(r,t,e,n,i,s):Ur(pi(r),t,e,n,i,s,1);break}}}function Iw(r){const t=r.prev,e=r,n=r.next;if(pe(t,e,n)>=0)return!1;let i=r.next.next;for(;i!==r.prev;){if(Ts(t.x,t.y,e.x,e.y,n.x,n.y,i.x,i.y)&&pe(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Dw(r,t,e,n){const i=r.prev,s=r,a=r.next;if(pe(i,s,a)>=0)return!1;const l=i.x<s.x?i.x<a.x?i.x:a.x:s.x<a.x?s.x:a.x,u=i.y<s.y?i.y<a.y?i.y:a.y:s.y<a.y?s.y:a.y,h=i.x>s.x?i.x>a.x?i.x:a.x:s.x>a.x?s.x:a.x,p=i.y>s.y?i.y>a.y?i.y:a.y:s.y>a.y?s.y:a.y,f=Wl(l,u,t,e,n),m=Wl(h,p,t,e,n);let v=r.prevZ,x=r.nextZ;for(;v&&v.z>=f&&x&&x.z<=m;){if(v!==r.prev&&v!==r.next&&Ts(i.x,i.y,s.x,s.y,a.x,a.y,v.x,v.y)&&pe(v.prev,v,v.next)>=0||(v=v.prevZ,x!==r.prev&&x!==r.next&&Ts(i.x,i.y,s.x,s.y,a.x,a.y,x.x,x.y)&&pe(x.prev,x,x.next)>=0))return!1;x=x.nextZ}for(;v&&v.z>=f;){if(v!==r.prev&&v!==r.next&&Ts(i.x,i.y,s.x,s.y,a.x,a.y,v.x,v.y)&&pe(v.prev,v,v.next)>=0)return!1;v=v.prevZ}for(;x&&x.z<=m;){if(x!==r.prev&&x!==r.next&&Ts(i.x,i.y,s.x,s.y,a.x,a.y,x.x,x.y)&&pe(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function Nw(r,t,e){let n=r;do{const i=n.prev,s=n.next.next;!ma(i,s)&&Tp(i,n,n.next,s)&&Hr(i,s)&&Hr(s,i)&&(t.push(i.i/e),t.push(n.i/e),t.push(s.i/e),Gr(n),Gr(n.next),n=r=s),n=n.next}while(n!==r);return pi(n)}function Fw(r,t,e,n,i,s){let a=r;do{let l=a.next.next;for(;l!==a.prev;){if(a.i!==l.i&&Ww(a,l)){let u=Ap(a,l);a=pi(a,a.next),u=pi(u,u.next),Ur(a,t,e,n,i,s),Ur(u,t,e,n,i,s);return}l=l.next}a=a.next}while(a!==r)}function kw(r,t,e,n){const i=[];let s,a,l,u,h;for(s=0,a=t.length;s<a;s++)l=t[s]*n,u=s<a-1?t[s+1]*n:r.length,h=Sp(r,l,u,n,!1),h===h.next&&(h.steiner=!0),i.push(Gw(h));for(i.sort(Bw),s=0;s<i.length;s++)Ow(i[s],e),e=pi(e,e.next);return e}function Bw(r,t){return r.x-t.x}function Ow(r,t){if(t=Vw(r,t),t){const e=Ap(t,r);pi(t,t.next),pi(e,e.next)}}function Vw(r,t){let e=t;const n=r.x,i=r.y;let s=-1/0,a;do{if(i<=e.y&&i>=e.next.y&&e.next.y!==e.y){const m=e.x+(i-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(m<=n&&m>s){if(s=m,m===n){if(i===e.y)return e;if(i===e.next.y)return e.next}a=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!a)return null;if(n===s)return a;const l=a,u=a.x,h=a.y;let p=1/0,f;e=a;do n>=e.x&&e.x>=u&&n!==e.x&&Ts(i<h?n:s,i,u,h,i<h?s:n,i,e.x,e.y)&&(f=Math.abs(i-e.y)/(n-e.x),Hr(e,r)&&(f<p||f===p&&(e.x>a.x||e.x===a.x&&zw(a,e)))&&(a=e,p=f)),e=e.next;while(e!==l);return a}function zw(r,t){return pe(r.prev,r,t.prev)<0&&pe(t.next,r,r.next)<0}function Uw(r,t,e,n){let i=r;do i.z===null&&(i.z=Wl(i.x,i.y,t,e,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==r);i.prevZ.nextZ=null,i.prevZ=null,Hw(i)}function Hw(r){let t,e,n,i,s,a,l,u,h=1;do{for(e=r,r=null,s=null,a=0;e;){for(a++,n=e,l=0,t=0;t<h&&(l++,n=n.nextZ,!!n);t++);for(u=h;l>0||u>0&&n;)l!==0&&(u===0||!n||e.z<=n.z)?(i=e,e=e.nextZ,l--):(i=n,n=n.nextZ,u--),s?s.nextZ=i:r=i,i.prevZ=s,s=i;e=n}s.nextZ=null,h*=2}while(a>1);return r}function Wl(r,t,e,n,i){return r=32767*(r-e)*i,t=32767*(t-n)*i,r=(r|r<<8)&16711935,r=(r|r<<4)&252645135,r=(r|r<<2)&858993459,r=(r|r<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,r|t<<1}function Gw(r){let t=r,e=r;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==r);return e}function Ts(r,t,e,n,i,s,a,l){return(i-a)*(t-l)-(r-a)*(s-l)>=0&&(r-a)*(n-l)-(e-a)*(t-l)>=0&&(e-a)*(s-l)-(i-a)*(n-l)>=0}function Ww(r,t){return r.next.i!==t.i&&r.prev.i!==t.i&&!jw(r,t)&&(Hr(r,t)&&Hr(t,r)&&Xw(r,t)&&(pe(r.prev,r,t.prev)||pe(r,t.prev,t))||ma(r,t)&&pe(r.prev,r,r.next)>0&&pe(t.prev,t,t.next)>0)}function pe(r,t,e){return(t.y-r.y)*(e.x-t.x)-(t.x-r.x)*(e.y-t.y)}function ma(r,t){return r.x===t.x&&r.y===t.y}function Tp(r,t,e,n){const i=Fo(pe(r,t,e)),s=Fo(pe(r,t,n)),a=Fo(pe(e,n,r)),l=Fo(pe(e,n,t));return!!(i!==s&&a!==l||i===0&&No(r,e,t)||s===0&&No(r,n,t)||a===0&&No(e,r,n)||l===0&&No(e,t,n))}function No(r,t,e){return t.x<=Math.max(r.x,e.x)&&t.x>=Math.min(r.x,e.x)&&t.y<=Math.max(r.y,e.y)&&t.y>=Math.min(r.y,e.y)}function Fo(r){return r>0?1:r<0?-1:0}function jw(r,t){let e=r;do{if(e.i!==r.i&&e.next.i!==r.i&&e.i!==t.i&&e.next.i!==t.i&&Tp(e,e.next,r,t))return!0;e=e.next}while(e!==r);return!1}function Hr(r,t){return pe(r.prev,r,r.next)<0?pe(r,t,r.next)>=0&&pe(r,r.prev,t)>=0:pe(r,t,r.prev)<0||pe(r,r.next,t)<0}function Xw(r,t){let e=r,n=!1;const i=(r.x+t.x)/2,s=(r.y+t.y)/2;do e.y>s!=e.next.y>s&&e.next.y!==e.y&&i<(e.next.x-e.x)*(s-e.y)/(e.next.y-e.y)+e.x&&(n=!n),e=e.next;while(e!==r);return n}function Ap(r,t){const e=new jl(r.i,r.x,r.y),n=new jl(t.i,t.x,t.y),i=r.next,s=t.prev;return r.next=t,t.prev=r,e.next=i,i.prev=e,n.next=e,e.prev=n,s.next=n,n.prev=s,n}function $h(r,t,e,n){const i=new jl(r,t,e);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function Gr(r){r.next.prev=r.prev,r.prev.next=r.next,r.prevZ&&(r.prevZ.nextZ=r.nextZ),r.nextZ&&(r.nextZ.prevZ=r.prevZ)}function jl(r,t,e){this.i=r,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function qw(r,t,e,n){let i=0;for(let s=t,a=e-n;s<e;s+=n)i+=(r[a]-r[s])*(r[s+1]+r[a+1]),a=s;return i}class ui{static area(t){const e=t.length;let n=0;for(let i=e-1,s=0;s<e;i=s++)n+=t[i].x*t[s].y-t[s].x*t[i].y;return n*.5}static isClockWise(t){return ui.area(t)<0}static triangulateShape(t,e){const n=[],i=[],s=[];Jh(t),Qh(n,t);let a=t.length;e.forEach(Jh);for(let u=0;u<e.length;u++)i.push(a),a+=e[u].length,Qh(n,e[u]);const l=Rw.triangulate(n,i);for(let u=0;u<l.length;u+=3)s.push(l.slice(u,u+3));return s}}function Jh(r){const t=r.length;t>2&&r[t-1].equals(r[0])&&r.pop()}function Qh(r,t){for(let e=0;e<t.length;e++)r.push(t[e].x),r.push(t[e].y)}class ga extends Yt{constructor(t,e){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],s=[];for(let l=0,u=t.length;l<u;l++){const h=t[l];a(h)}this.setAttribute("position",new qt(i,3)),this.setAttribute("uv",new qt(s,2)),this.computeVertexNormals();function a(l){const u=[],h=e.curveSegments!==void 0?e.curveSegments:12,p=e.steps!==void 0?e.steps:1;let f=e.depth!==void 0?e.depth:100,m=e.bevelEnabled!==void 0?e.bevelEnabled:!0,v=e.bevelThickness!==void 0?e.bevelThickness:6,x=e.bevelSize!==void 0?e.bevelSize:v-2,b=e.bevelOffset!==void 0?e.bevelOffset:0,w=e.bevelSegments!==void 0?e.bevelSegments:3;const _=e.extrudePath,y=e.UVGenerator!==void 0?e.UVGenerator:Yw;e.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),f=e.amount);let M,T=!1,A,E,P,I;_&&(M=_.getSpacedPoints(p),T=!0,m=!1,A=_.computeFrenetFrames(p,!1),E=new C,P=new C,I=new C),m||(w=0,v=0,x=0,b=0);const N=l.extractPoints(h);let z=N.shape;const W=N.holes;if(!ui.isClockWise(z)){z=z.reverse();for(let tt=0,et=W.length;tt<et;tt++){const lt=W[tt];ui.isClockWise(lt)&&(W[tt]=lt.reverse())}}const D=ui.triangulateShape(z,W),V=z;for(let tt=0,et=W.length;tt<et;tt++){const lt=W[tt];z=z.concat(lt)}function G(tt,et,lt){return et||console.error("THREE.ExtrudeGeometry: vec does not exist"),et.clone().multiplyScalar(lt).add(tt)}const B=z.length,j=D.length;function ot(tt,et,lt){let At,_t,F;const R=tt.x-et.x,J=tt.y-et.y,it=lt.x-tt.x,gt=lt.y-tt.y,xt=R*R+J*J,Pt=R*gt-J*it;if(Math.abs(Pt)>Number.EPSILON){const O=Math.sqrt(xt),mt=Math.sqrt(it*it+gt*gt),ht=et.x-J/O,U=et.y+R/O,at=lt.x-gt/mt,$=lt.y+it/mt,St=((at-ht)*gt-($-U)*it)/(R*gt-J*it);At=ht+R*St-tt.x,_t=U+J*St-tt.y;const dt=At*At+_t*_t;if(dt<=2)return new nt(At,_t);F=Math.sqrt(dt/2)}else{let O=!1;R>Number.EPSILON?it>Number.EPSILON&&(O=!0):R<-Number.EPSILON?it<-Number.EPSILON&&(O=!0):Math.sign(J)===Math.sign(gt)&&(O=!0),O?(At=-J,_t=R,F=Math.sqrt(xt)):(At=R,_t=J,F=Math.sqrt(xt/2))}return new nt(At/F,_t/F)}const Q=[];for(let tt=0,et=V.length,lt=et-1,At=tt+1;tt<et;tt++,lt++,At++)lt===et&&(lt=0),At===et&&(At=0),Q[tt]=ot(V[tt],V[lt],V[At]);const ut=[];let rt,Tt=Q.concat();for(let tt=0,et=W.length;tt<et;tt++){const lt=W[tt];rt=[];for(let At=0,_t=lt.length,F=_t-1,R=At+1;At<_t;At++,F++,R++)F===_t&&(F=0),R===_t&&(R=0),rt[At]=ot(lt[At],lt[F],lt[R]);ut.push(rt),Tt=Tt.concat(rt)}for(let tt=0;tt<w;tt++){const et=tt/w,lt=v*Math.cos(et*Math.PI/2),At=x*Math.sin(et*Math.PI/2)+b;for(let _t=0,F=V.length;_t<F;_t++){const R=G(V[_t],Q[_t],At);Ot(R.x,R.y,-lt)}for(let _t=0,F=W.length;_t<F;_t++){const R=W[_t];rt=ut[_t];for(let J=0,it=R.length;J<it;J++){const gt=G(R[J],rt[J],At);Ot(gt.x,gt.y,-lt)}}}const ct=x+b;for(let tt=0;tt<B;tt++){const et=m?G(z[tt],Tt[tt],ct):z[tt];T?(P.copy(A.normals[0]).multiplyScalar(et.x),E.copy(A.binormals[0]).multiplyScalar(et.y),I.copy(M[0]).add(P).add(E),Ot(I.x,I.y,I.z)):Ot(et.x,et.y,0)}for(let tt=1;tt<=p;tt++)for(let et=0;et<B;et++){const lt=m?G(z[et],Tt[et],ct):z[et];T?(P.copy(A.normals[tt]).multiplyScalar(lt.x),E.copy(A.binormals[tt]).multiplyScalar(lt.y),I.copy(M[tt]).add(P).add(E),Ot(I.x,I.y,I.z)):Ot(lt.x,lt.y,f/p*tt)}for(let tt=w-1;tt>=0;tt--){const et=tt/w,lt=v*Math.cos(et*Math.PI/2),At=x*Math.sin(et*Math.PI/2)+b;for(let _t=0,F=V.length;_t<F;_t++){const R=G(V[_t],Q[_t],At);Ot(R.x,R.y,f+lt)}for(let _t=0,F=W.length;_t<F;_t++){const R=W[_t];rt=ut[_t];for(let J=0,it=R.length;J<it;J++){const gt=G(R[J],rt[J],At);T?Ot(gt.x,gt.y+M[p-1].y,M[p-1].x+lt):Ot(gt.x,gt.y,f+lt)}}}ft(),Ft();function ft(){const tt=i.length/3;if(m){let et=0,lt=B*et;for(let At=0;At<j;At++){const _t=D[At];Dt(_t[2]+lt,_t[1]+lt,_t[0]+lt)}et=p+w*2,lt=B*et;for(let At=0;At<j;At++){const _t=D[At];Dt(_t[0]+lt,_t[1]+lt,_t[2]+lt)}}else{for(let et=0;et<j;et++){const lt=D[et];Dt(lt[2],lt[1],lt[0])}for(let et=0;et<j;et++){const lt=D[et];Dt(lt[0]+B*p,lt[1]+B*p,lt[2]+B*p)}}n.addGroup(tt,i.length/3-tt,0)}function Ft(){const tt=i.length/3;let et=0;K(V,et),et+=V.length;for(let lt=0,At=W.length;lt<At;lt++){const _t=W[lt];K(_t,et),et+=_t.length}n.addGroup(tt,i.length/3-tt,1)}function K(tt,et){let lt=tt.length;for(;--lt>=0;){const At=lt;let _t=lt-1;_t<0&&(_t=tt.length-1);for(let F=0,R=p+w*2;F<R;F++){const J=B*F,it=B*(F+1),gt=et+At+J,xt=et+_t+J,Pt=et+_t+it,O=et+At+it;Mt(gt,xt,Pt,O)}}}function Ot(tt,et,lt){u.push(tt),u.push(et),u.push(lt)}function Dt(tt,et,lt){bt(tt),bt(et),bt(lt);const At=i.length/3,_t=y.generateTopUV(n,i,At-3,At-2,At-1);Nt(_t[0]),Nt(_t[1]),Nt(_t[2])}function Mt(tt,et,lt,At){bt(tt),bt(et),bt(At),bt(et),bt(lt),bt(At);const _t=i.length/3,F=y.generateSideWallUV(n,i,_t-6,_t-3,_t-2,_t-1);Nt(F[0]),Nt(F[1]),Nt(F[3]),Nt(F[1]),Nt(F[2]),Nt(F[3])}function bt(tt){i.push(u[tt*3+0]),i.push(u[tt*3+1]),i.push(u[tt*3+2])}function Nt(tt){s.push(tt.x),s.push(tt.y)}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,n=this.parameters.options;return Zw(e,n,t)}}const Yw={generateTopUV:function(r,t,e,n,i){const s=t[e*3],a=t[e*3+1],l=t[n*3],u=t[n*3+1],h=t[i*3],p=t[i*3+1];return[new nt(s,a),new nt(l,u),new nt(h,p)]},generateSideWallUV:function(r,t,e,n,i,s){const a=t[e*3],l=t[e*3+1],u=t[e*3+2],h=t[n*3],p=t[n*3+1],f=t[n*3+2],m=t[i*3],v=t[i*3+1],x=t[i*3+2],b=t[s*3],w=t[s*3+1],_=t[s*3+2];return Math.abs(l-p)<Math.abs(a-h)?[new nt(a,1-u),new nt(h,1-f),new nt(m,1-x),new nt(b,1-_)]:[new nt(l,1-u),new nt(p,1-f),new nt(v,1-x),new nt(w,1-_)]}};function Zw(r,t,e){if(e.shapes=[],Array.isArray(r))for(let n=0,i=r.length;n<i;n++){const s=r[n];e.shapes.push(s.uuid)}else e.shapes.push(r.uuid);return t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class Si extends Lw{constructor(t=1,e=0){const n=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(n,i,t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}}class Kw extends Yt{constructor(t,e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],s=[],a=[];let l=0,u=0;if(Array.isArray(t)===!1)h(t);else for(let p=0;p<t.length;p++)h(t[p]),this.addGroup(l,u,p),l+=u,u=0;this.setIndex(n),this.setAttribute("position",new qt(i,3)),this.setAttribute("normal",new qt(s,3)),this.setAttribute("uv",new qt(a,2));function h(p){const f=i.length/3,m=p.extractPoints(e);let v=m.shape;const x=m.holes;ui.isClockWise(v)===!1&&(v=v.reverse());for(let w=0,_=x.length;w<_;w++){const y=x[w];ui.isClockWise(y)===!0&&(x[w]=y.reverse())}const b=ui.triangulateShape(v,x);for(let w=0,_=x.length;w<_;w++){const y=x[w];v=v.concat(y)}for(let w=0,_=v.length;w<_;w++){const y=v[w];i.push(y.x,y.y,0),s.push(0,0,1),a.push(y.x,y.y)}for(let w=0,_=b.length;w<_;w++){const y=b[w],M=y[0]+f,T=y[1]+f,A=y[2]+f;n.push(M,T,A),u+=3}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return $w(e,t)}}function $w(r,t){if(t.shapes=[],Array.isArray(r))for(let e=0,n=r.length;e<n;e++){const i=r[e];t.shapes.push(i.uuid)}else t.shapes.push(r.uuid);return t}class Jw extends Yt{constructor(t=1,e=8,n=6,i=0,s=Math.PI*2,a=0,l=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:i,phiLength:s,thetaStart:a,thetaLength:l},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const u=Math.min(a+l,Math.PI);let h=0;const p=[],f=new C,m=new C,v=[],x=[],b=[],w=[];for(let _=0;_<=n;_++){const y=[],M=_/n;let T=0;_==0&&a==0?T=.5/e:_==n&&u==Math.PI&&(T=-.5/e);for(let A=0;A<=e;A++){const E=A/e;f.x=-t*Math.cos(i+E*s)*Math.sin(a+M*l),f.y=t*Math.cos(a+M*l),f.z=t*Math.sin(i+E*s)*Math.sin(a+M*l),x.push(f.x,f.y,f.z),m.copy(f).normalize(),b.push(m.x,m.y,m.z),w.push(E+T,1-M),y.push(h++)}p.push(y)}for(let _=0;_<n;_++)for(let y=0;y<e;y++){const M=p[_][y+1],T=p[_][y],A=p[_+1][y],E=p[_+1][y+1];(_!==0||a>0)&&v.push(M,T,E),(_!==n-1||u<Math.PI)&&v.push(T,A,E)}this.setIndex(v),this.setAttribute("position",new qt(x,3)),this.setAttribute("normal",new qt(b,3)),this.setAttribute("uv",new qt(w,2))}}class ko extends Yt{constructor(t=1,e=.4,n=8,i=6,s=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:i,arc:s},n=Math.floor(n),i=Math.floor(i);const a=[],l=[],u=[],h=[],p=new C,f=new C,m=new C;for(let v=0;v<=n;v++)for(let x=0;x<=i;x++){const b=x/i*s,w=v/n*Math.PI*2;f.x=(t+e*Math.cos(w))*Math.cos(b),f.y=(t+e*Math.cos(w))*Math.sin(b),f.z=e*Math.sin(w),l.push(f.x,f.y,f.z),p.x=t*Math.cos(b),p.y=t*Math.sin(b),m.subVectors(f,p).normalize(),u.push(m.x,m.y,m.z),h.push(x/i),h.push(v/n)}for(let v=1;v<=n;v++)for(let x=1;x<=i;x++){const b=(i+1)*v+x-1,w=(i+1)*(v-1)+x-1,_=(i+1)*(v-1)+x,y=(i+1)*v+x;a.push(b,w,y),a.push(w,_,y)}this.setIndex(a),this.setAttribute("position",new qt(l,3)),this.setAttribute("normal",new qt(u,3)),this.setAttribute("uv",new qt(h,2))}}class Qw extends Me{constructor(t){super(),this.type="ShadowMaterial",this.color=new yt(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}Qw.prototype.isShadowMaterial=!0;class tM extends yn{constructor(t){super(t),this.type="RawShaderMaterial"}}tM.prototype.isRawShaderMaterial=!0;class Zr extends Me{constructor(t){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new yt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new yt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Di,this.normalScale=new nt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.vertexTangents=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.flatShading=t.flatShading,this.vertexTangents=t.vertexTangents,this}}Zr.prototype.isMeshStandardMaterial=!0;class yc extends Zr{constructor(t){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new nt(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(e){this.reflectivity=Le(2.5*(e-1)/(e+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.thickness=.01,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new yt(1,1,1),this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.reflectivity=t.reflectivity,t.sheen?this.sheen=(this.sheen||new yt).copy(t.sheen):this.sheen=null,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this}}yc.prototype.isMeshPhysicalMaterial=!0;class eM extends Me{constructor(t){super(),this.type="MeshPhongMaterial",this.color=new yt(16777215),this.specular=new yt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new yt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Di,this.normalScale=new nt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ha,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.flatShading=t.flatShading,this}}eM.prototype.isMeshPhongMaterial=!0;class nM extends Me{constructor(t){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new yt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new yt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Di,this.normalScale=new nt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this}}nM.prototype.isMeshToonMaterial=!0;class iM extends Me{constructor(t){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Di,this.normalScale=new nt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.flatShading=t.flatShading,this}}iM.prototype.isMeshNormalMaterial=!0;class sM extends Me{constructor(t){super(),this.type="MeshLambertMaterial",this.color=new yt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new yt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ha,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this}}sM.prototype.isMeshLambertMaterial=!0;class rM extends Me{constructor(t){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new yt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Di,this.normalScale=new nt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.flatShading=t.flatShading,this}}rM.prototype.isMeshMatcapMaterial=!0;class oM extends Bi{constructor(t){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}oM.prototype.isLineDashedMaterial=!0;const ue={arraySlice:function(r,t,e){return ue.isTypedArray(r)?new r.constructor(r.subarray(t,e!==void 0?e:r.length)):r.slice(t,e)},convertArray:function(r,t,e){return!r||!e&&r.constructor===t?r:typeof t.BYTES_PER_ELEMENT=="number"?new t(r):Array.prototype.slice.call(r)},isTypedArray:function(r){return ArrayBuffer.isView(r)&&!(r instanceof DataView)},getKeyframeOrder:function(r){function t(i,s){return r[i]-r[s]}const e=r.length,n=new Array(e);for(let i=0;i!==e;++i)n[i]=i;return n.sort(t),n},sortedArray:function(r,t,e){const n=r.length,i=new r.constructor(n);for(let s=0,a=0;a!==n;++s){const l=e[s]*t;for(let u=0;u!==t;++u)i[a++]=r[l+u]}return i},flattenJSON:function(r,t,e,n){let i=1,s=r[0];for(;s!==void 0&&s[n]===void 0;)s=r[i++];if(s===void 0)return;let a=s[n];if(a!==void 0)if(Array.isArray(a))do a=s[n],a!==void 0&&(t.push(s.time),e.push.apply(e,a)),s=r[i++];while(s!==void 0);else if(a.toArray!==void 0)do a=s[n],a!==void 0&&(t.push(s.time),a.toArray(e,e.length)),s=r[i++];while(s!==void 0);else do a=s[n],a!==void 0&&(t.push(s.time),e.push(a)),s=r[i++];while(s!==void 0)},subclip:function(r,t,e,n,i=30){const s=r.clone();s.name=t;const a=[];for(let u=0;u<s.tracks.length;++u){const h=s.tracks[u],p=h.getValueSize(),f=[],m=[];for(let v=0;v<h.times.length;++v){const x=h.times[v]*i;if(!(x<e||x>=n)){f.push(h.times[v]);for(let b=0;b<p;++b)m.push(h.values[v*p+b])}}f.length!==0&&(h.times=ue.convertArray(f,h.times.constructor),h.values=ue.convertArray(m,h.values.constructor),a.push(h))}s.tracks=a;let l=1/0;for(let u=0;u<s.tracks.length;++u)l>s.tracks[u].times[0]&&(l=s.tracks[u].times[0]);for(let u=0;u<s.tracks.length;++u)s.tracks[u].shift(-1*l);return s.resetDuration(),s},makeClipAdditive:function(r,t=0,e=r,n=30){n<=0&&(n=30);const i=e.tracks.length,s=t/n;for(let a=0;a<i;++a){const l=e.tracks[a],u=l.ValueTypeName;if(u==="bool"||u==="string")continue;const h=r.tracks.find(function(_){return _.name===l.name&&_.ValueTypeName===u});if(h===void 0)continue;let p=0;const f=l.getValueSize();l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(p=f/3);let m=0;const v=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(m=v/3);const x=l.times.length-1;let b;if(s<=l.times[0]){const _=p,y=f-p;b=ue.arraySlice(l.values,_,y)}else if(s>=l.times[x]){const _=x*f+p,y=_+f-p;b=ue.arraySlice(l.values,_,y)}else{const _=l.createInterpolant(),y=p,M=f-p;_.evaluate(s),b=ue.arraySlice(_.resultBuffer,y,M)}u==="quaternion"&&new se().fromArray(b).normalize().conjugate().toArray(b);const w=h.times.length;for(let _=0;_<w;++_){const y=_*v+m;if(u==="quaternion")se.multiplyQuaternionsFlat(h.values,y,b,0,h.values,y);else{const M=v-m*2;for(let T=0;T<M;++T)h.values[y+T]-=b[T]}}}return r.blendMode=Zd,r}};class Vn{constructor(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],s=e[n-1];t:{e:{let a;n:{i:if(!(t<i)){for(let l=n+2;;){if(i===void 0){if(t<s)break i;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,s)}if(n===l)break;if(s=i,i=e[++n],t<i)break e}a=e.length;break n}if(!(t>=s)){const l=e[1];t<l&&(n=2,s=l);for(let u=n-2;;){if(s===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(n===u)break;if(i=s,s=e[--n-1],t>=s)break e}a=n,n=0;break n}break t}for(;n<a;){const l=n+a>>>1;t<e[l]?a=l:n=l+1}if(i=e[n],s=e[n-1],s===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(i===void 0)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,s,t)}this._cachedIndex=n,this.intervalChanged_(n,s,i)}return this.interpolate_(n,s,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=t*i;for(let a=0;a!==i;++a)e[a]=n[s+a];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Vn.prototype.beforeStart_=Vn.prototype.copySampleValue_;Vn.prototype.afterEnd_=Vn.prototype.copySampleValue_;class aM extends Vn{constructor(t,e,n,i){super(t,e,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Es,endingEnd:Es}}intervalChanged_(t,e,n){const i=this.parameterPositions;let s=t-2,a=t+1,l=i[s],u=i[a];if(l===void 0)switch(this.getSettings_().endingStart){case Ss:s=t,l=2*e-n;break;case oa:s=i.length-2,l=e+i[s]-i[s+1];break;default:s=t,l=n}if(u===void 0)switch(this.getSettings_().endingEnd){case Ss:a=t,u=2*n-e;break;case oa:a=1,u=n+i[1]-i[0];break;default:a=t-1,u=e}const h=(n-e)*.5,p=this.valueSize;this._weightPrev=h/(e-l),this._weightNext=h/(u-n),this._offsetPrev=s*p,this._offsetNext=a*p}interpolate_(t,e,n,i){const s=this.resultBuffer,a=this.sampleValues,l=this.valueSize,u=t*l,h=u-l,p=this._offsetPrev,f=this._offsetNext,m=this._weightPrev,v=this._weightNext,x=(n-e)/(i-e),b=x*x,w=b*x,_=-m*w+2*m*b-m*x,y=(1+m)*w+(-1.5-2*m)*b+(-.5+m)*x+1,M=(-1-v)*w+(1.5+v)*b+.5*x,T=v*w-v*b;for(let A=0;A!==l;++A)s[A]=_*a[p+A]+y*a[h+A]+M*a[u+A]+T*a[f+A];return s}}class Cp extends Vn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const s=this.resultBuffer,a=this.sampleValues,l=this.valueSize,u=t*l,h=u-l,p=(n-e)/(i-e),f=1-p;for(let m=0;m!==l;++m)s[m]=a[h+m]*f+a[u+m]*p;return s}}class lM extends Vn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class En{constructor(t,e,n,i){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=ue.convertArray(e,this.TimeBufferType),this.values=ue.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:ue.convertArray(t.times,Array),values:ue.convertArray(t.values,Array)};const i=t.getInterpolation();i!==t.DefaultInterpolation&&(n.interpolation=i)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new lM(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Cp(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new aM(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case kr:e=this.InterpolantFactoryMethodDiscrete;break;case Rs:e=this.InterpolantFactoryMethodLinear;break;case qa:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return kr;case this.InterpolantFactoryMethodLinear:return Rs;case this.InterpolantFactoryMethodSmooth:return qa}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this}trim(t,e){const n=this.times,i=n.length;let s=0,a=i-1;for(;s!==i&&n[s]<t;)++s;for(;a!==-1&&n[a]>e;)--a;if(++a,s!==0||a!==i){s>=a&&(a=Math.max(a,1),s=a-1);const l=this.getValueSize();this.times=ue.arraySlice(n,s,a),this.values=ue.arraySlice(this.values,s*l,a*l)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let a=null;for(let l=0;l!==s;l++){const u=n[l];if(typeof u=="number"&&isNaN(u)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,l,u),t=!1;break}if(a!==null&&a>u){console.error("THREE.KeyframeTrack: Out of order keys.",this,l,u,a),t=!1;break}a=u}if(i!==void 0&&ue.isTypedArray(i))for(let l=0,u=i.length;l!==u;++l){const h=i[l];if(isNaN(h)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,l,h),t=!1;break}}return t}optimize(){const t=ue.arraySlice(this.times),e=ue.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===qa,s=t.length-1;let a=1;for(let l=1;l<s;++l){let u=!1;const h=t[l],p=t[l+1];if(h!==p&&(l!==1||h!==t[0]))if(i)u=!0;else{const f=l*n,m=f-n,v=f+n;for(let x=0;x!==n;++x){const b=e[f+x];if(b!==e[m+x]||b!==e[v+x]){u=!0;break}}}if(u){if(l!==a){t[a]=t[l];const f=l*n,m=a*n;for(let v=0;v!==n;++v)e[m+v]=e[f+v]}++a}}if(s>0){t[a]=t[s];for(let l=s*n,u=a*n,h=0;h!==n;++h)e[u+h]=e[l+h];++a}return a!==t.length?(this.times=ue.arraySlice(t,0,a),this.values=ue.arraySlice(e,0,a*n)):(this.times=t,this.values=e),this}clone(){const t=ue.arraySlice(this.times,0),e=ue.arraySlice(this.values,0),n=this.constructor,i=new n(this.name,t,e);return i.createInterpolant=this.createInterpolant,i}}En.prototype.TimeBufferType=Float32Array;En.prototype.ValueBufferType=Float32Array;En.prototype.DefaultInterpolation=Rs;class zs extends En{}zs.prototype.ValueTypeName="bool";zs.prototype.ValueBufferType=Array;zs.prototype.DefaultInterpolation=kr;zs.prototype.InterpolantFactoryMethodLinear=void 0;zs.prototype.InterpolantFactoryMethodSmooth=void 0;class Pp extends En{}Pp.prototype.ValueTypeName="color";class Wr extends En{}Wr.prototype.ValueTypeName="number";class cM extends Vn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const s=this.resultBuffer,a=this.sampleValues,l=this.valueSize,u=(n-e)/(i-e);let h=t*l;for(let p=h+l;h!==p;h+=4)se.slerpFlat(s,0,a,h-l,a,h,u);return s}}class Us extends En{InterpolantFactoryMethodLinear(t){return new cM(this.times,this.values,this.getValueSize(),t)}}Us.prototype.ValueTypeName="quaternion";Us.prototype.DefaultInterpolation=Rs;Us.prototype.InterpolantFactoryMethodSmooth=void 0;class Hs extends En{}Hs.prototype.ValueTypeName="string";Hs.prototype.ValueBufferType=Array;Hs.prototype.DefaultInterpolation=kr;Hs.prototype.InterpolantFactoryMethodLinear=void 0;Hs.prototype.InterpolantFactoryMethodSmooth=void 0;class jr extends En{}jr.prototype.ValueTypeName="vector";class Xl{constructor(t,e=-1,n,i=hc){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=Ye(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let a=0,l=n.length;a!==l;++a)e.push(hM(n[a]).scale(i));const s=new this(t.name,t.duration,e,t.blendMode);return s.uuid=t.uuid,s}static toJSON(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let s=0,a=n.length;s!==a;++s)e.push(En.toJSON(n[s]));return i}static CreateFromMorphTargetSequence(t,e,n,i){const s=e.length,a=[];for(let l=0;l<s;l++){let u=[],h=[];u.push((l+s-1)%s,l,(l+1)%s),h.push(0,1,0);const p=ue.getKeyframeOrder(u);u=ue.sortedArray(u,1,p),h=ue.sortedArray(h,1,p),!i&&u[0]===0&&(u.push(s),h.push(h[0])),a.push(new Wr(".morphTargetInfluences["+e[l].name+"]",u,h).scale(1/n))}return new this(t,-1,a)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const i=t;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===e)return n[i];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const i={},s=/^([\w-]*?)([\d]+)$/;for(let l=0,u=t.length;l<u;l++){const h=t[l],p=h.name.match(s);if(p&&p.length>1){const f=p[1];let m=i[f];m||(i[f]=m=[]),m.push(h)}}const a=[];for(const l in i)a.push(this.CreateFromMorphTargetSequence(l,i[l],e,n));return a}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(f,m,v,x,b){if(v.length!==0){const w=[],_=[];ue.flattenJSON(v,w,_,x),w.length!==0&&b.push(new f(m,w,_))}},i=[],s=t.name||"default",a=t.fps||30,l=t.blendMode;let u=t.length||-1;const h=t.hierarchy||[];for(let f=0;f<h.length;f++){const m=h[f].keys;if(!(!m||m.length===0))if(m[0].morphTargets){const v={};let x;for(x=0;x<m.length;x++)if(m[x].morphTargets)for(let b=0;b<m[x].morphTargets.length;b++)v[m[x].morphTargets[b]]=-1;for(const b in v){const w=[],_=[];for(let y=0;y!==m[x].morphTargets.length;++y){const M=m[x];w.push(M.time),_.push(M.morphTarget===b?1:0)}i.push(new Wr(".morphTargetInfluence["+b+"]",w,_))}u=v.length*(a||1)}else{const v=".bones["+e[f].name+"]";n(jr,v+".position",m,"pos",i),n(Us,v+".quaternion",m,"rot",i),n(jr,v+".scale",m,"scl",i)}}return i.length===0?null:new this(s,u,i,l)}resetDuration(){const t=this.tracks;let e=0;for(let n=0,i=t.length;n!==i;++n){const s=this.tracks[n];e=Math.max(e,s.times[s.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function uM(r){switch(r.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Wr;case"vector":case"vector2":case"vector3":case"vector4":return jr;case"color":return Pp;case"quaternion":return Us;case"bool":case"boolean":return zs;case"string":return Hs}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+r)}function hM(r){if(r.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=uM(r.type);if(r.times===void 0){const e=[],n=[];ue.flattenJSON(r.keys,e,n,"value"),r.times=e,r.values=n}return t.parse!==void 0?t.parse(r):new t(r.name,r.times,r.values,r.interpolation)}const Ds={enabled:!1,files:{},add:function(r,t){this.enabled!==!1&&(this.files[r]=t)},get:function(r){if(this.enabled!==!1)return this.files[r]},remove:function(r){delete this.files[r]},clear:function(){this.files={}}};class dM{constructor(t,e,n){const i=this;let s=!1,a=0,l=0,u;const h=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(p){l++,s===!1&&i.onStart!==void 0&&i.onStart(p,a,l),s=!0},this.itemEnd=function(p){a++,i.onProgress!==void 0&&i.onProgress(p,a,l),a===l&&(s=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(p){i.onError!==void 0&&i.onError(p)},this.resolveURL=function(p){return u?u(p):p},this.setURLModifier=function(p){return u=p,this},this.addHandler=function(p,f){return h.push(p,f),this},this.removeHandler=function(p){const f=h.indexOf(p);return f!==-1&&h.splice(f,2),this},this.getHandler=function(p){for(let f=0,m=h.length;f<m;f+=2){const v=h[f],x=h[f+1];if(v.global&&(v.lastIndex=0),v.test(p))return x}return null}}}const pM=new dM;class Un{constructor(t){this.manager=t!==void 0?t:pM,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(i,s){n.load(t,i,e,s)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const nn={};class bc extends Un{constructor(t){super(t)}load(t,e,n,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,a=Ds.get(t);if(a!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(a),s.manager.itemEnd(t)},0),a;if(nn[t]!==void 0){nn[t].push({onLoad:e,onProgress:n,onError:i});return}const l=/^data:(.*?)(;base64)?,(.*)$/,u=t.match(l);let h;if(u){const p=u[1],f=!!u[2];let m=u[3];m=decodeURIComponent(m),f&&(m=atob(m));try{let v;const x=(this.responseType||"").toLowerCase();switch(x){case"arraybuffer":case"blob":const b=new Uint8Array(m.length);for(let _=0;_<m.length;_++)b[_]=m.charCodeAt(_);x==="blob"?v=new Blob([b.buffer],{type:p}):v=b.buffer;break;case"document":v=new DOMParser().parseFromString(m,p);break;case"json":v=JSON.parse(m);break;default:v=m;break}setTimeout(function(){e&&e(v),s.manager.itemEnd(t)},0)}catch(v){setTimeout(function(){i&&i(v),s.manager.itemError(t),s.manager.itemEnd(t)},0)}}else{nn[t]=[],nn[t].push({onLoad:e,onProgress:n,onError:i}),h=new XMLHttpRequest,h.open("GET",t,!0),h.addEventListener("load",function(p){const f=this.response,m=nn[t];if(delete nn[t],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Ds.add(t,f);for(let v=0,x=m.length;v<x;v++){const b=m[v];b.onLoad&&b.onLoad(f)}s.manager.itemEnd(t)}else{for(let v=0,x=m.length;v<x;v++){const b=m[v];b.onError&&b.onError(p)}s.manager.itemError(t),s.manager.itemEnd(t)}},!1),h.addEventListener("progress",function(p){const f=nn[t];for(let m=0,v=f.length;m<v;m++){const x=f[m];x.onProgress&&x.onProgress(p)}},!1),h.addEventListener("error",function(p){const f=nn[t];delete nn[t];for(let m=0,v=f.length;m<v;m++){const x=f[m];x.onError&&x.onError(p)}s.manager.itemError(t),s.manager.itemEnd(t)},!1),h.addEventListener("abort",function(p){const f=nn[t];delete nn[t];for(let m=0,v=f.length;m<v;m++){const x=f[m];x.onError&&x.onError(p)}s.manager.itemError(t),s.manager.itemEnd(t)},!1),this.responseType!==void 0&&(h.responseType=this.responseType),this.withCredentials!==void 0&&(h.withCredentials=this.withCredentials),h.overrideMimeType&&h.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const p in this.requestHeader)h.setRequestHeader(p,this.requestHeader[p]);h.send(null)}return s.manager.itemStart(t),h}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Lp extends Un{constructor(t){super(t)}load(t,e,n,i){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,a=Ds.get(t);if(a!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(a),s.manager.itemEnd(t)},0),a;const l=document.createElementNS("http://www.w3.org/1999/xhtml","img");function u(){l.removeEventListener("load",u,!1),l.removeEventListener("error",h,!1),Ds.add(t,this),e&&e(this),s.manager.itemEnd(t)}function h(p){l.removeEventListener("load",u,!1),l.removeEventListener("error",h,!1),i&&i(p),s.manager.itemError(t),s.manager.itemEnd(t)}return l.addEventListener("load",u,!1),l.addEventListener("error",h,!1),t.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(l.crossOrigin=this.crossOrigin),s.manager.itemStart(t),l.src=t,l}}class fM extends Un{constructor(t){super(t)}load(t,e,n,i){const s=new da,a=new Lp(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let l=0;function u(h){a.load(t[h],function(p){s.images[h]=p,l++,l===6&&(s.needsUpdate=!0,e&&e(s))},void 0,i)}for(let h=0;h<t.length;++h)u(h);return s}}class wc extends Un{constructor(t){super(t)}load(t,e,n,i){const s=new Ce,a=new Lp(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(t,function(l){s.image=l;const u=t.search(/\.jpe?g($|\?)/i)>0||t.search(/^data\:image\/jpeg/)===0;s.format=u?li:Fe,s.needsUpdate=!0,e!==void 0&&e(s)},n,i),s}}class Ze{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),s=0;e.push(0);for(let a=1;a<=t;a++)n=this.getPoint(a/t),s+=n.distanceTo(i),e.push(s),i=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let i=0;const s=n.length;let a;e?a=e:a=t*n[s-1];let l=0,u=s-1,h;for(;l<=u;)if(i=Math.floor(l+(u-l)/2),h=n[i]-a,h<0)l=i+1;else if(h>0)u=i-1;else{u=i;break}if(i=u,n[i]===a)return i/(s-1);const p=n[i],m=n[i+1]-p,v=(a-p)/m;return(i+v)/(s-1)}getTangent(t,e){let i=t-1e-4,s=t+1e-4;i<0&&(i=0),s>1&&(s=1);const a=this.getPoint(i),l=this.getPoint(s),u=e||(a.isVector2?new nt:new C);return u.copy(l).sub(a).normalize(),u}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new C,i=[],s=[],a=[],l=new C,u=new Et;for(let v=0;v<=t;v++){const x=v/t;i[v]=this.getTangentAt(x,new C),i[v].normalize()}s[0]=new C,a[0]=new C;let h=Number.MAX_VALUE;const p=Math.abs(i[0].x),f=Math.abs(i[0].y),m=Math.abs(i[0].z);p<=h&&(h=p,n.set(1,0,0)),f<=h&&(h=f,n.set(0,1,0)),m<=h&&n.set(0,0,1),l.crossVectors(i[0],n).normalize(),s[0].crossVectors(i[0],l),a[0].crossVectors(i[0],s[0]);for(let v=1;v<=t;v++){if(s[v]=s[v-1].clone(),a[v]=a[v-1].clone(),l.crossVectors(i[v-1],i[v]),l.length()>Number.EPSILON){l.normalize();const x=Math.acos(Le(i[v-1].dot(i[v]),-1,1));s[v].applyMatrix4(u.makeRotationAxis(l,x))}a[v].crossVectors(i[v],s[v])}if(e===!0){let v=Math.acos(Le(s[0].dot(s[t]),-1,1));v/=t,i[0].dot(l.crossVectors(s[0],s[t]))>0&&(v=-v);for(let x=1;x<=t;x++)s[x].applyMatrix4(u.makeRotationAxis(i[x],v*x)),a[x].crossVectors(i[x],s[x])}return{tangents:i,normals:s,binormals:a}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class va extends Ze{constructor(t=0,e=0,n=1,i=1,s=0,a=Math.PI*2,l=!1,u=0){super(),this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=i,this.aStartAngle=s,this.aEndAngle=a,this.aClockwise=l,this.aRotation=u}getPoint(t,e){const n=e||new nt,i=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const a=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=i;for(;s>i;)s-=i;s<Number.EPSILON&&(a?s=0:s=i),this.aClockwise===!0&&!a&&(s===i?s=-i:s=s-i);const l=this.aStartAngle+t*s;let u=this.aX+this.xRadius*Math.cos(l),h=this.aY+this.yRadius*Math.sin(l);if(this.aRotation!==0){const p=Math.cos(this.aRotation),f=Math.sin(this.aRotation),m=u-this.aX,v=h-this.aY;u=m*p-v*f+this.aX,h=m*f+v*p+this.aY}return n.set(u,h)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}va.prototype.isEllipseCurve=!0;class Rp extends va{constructor(t,e,n,i,s,a){super(t,e,n,n,i,s,a),this.type="ArcCurve"}}Rp.prototype.isArcCurve=!0;function Mc(){let r=0,t=0,e=0,n=0;function i(s,a,l,u){r=s,t=l,e=-3*s+3*a-2*l-u,n=2*s-2*a+l+u}return{initCatmullRom:function(s,a,l,u,h){i(a,l,h*(l-s),h*(u-a))},initNonuniformCatmullRom:function(s,a,l,u,h,p,f){let m=(a-s)/h-(l-s)/(h+p)+(l-a)/p,v=(l-a)/p-(u-a)/(p+f)+(u-l)/f;m*=p,v*=p,i(a,l,m,v)},calc:function(s){const a=s*s,l=a*s;return r+t*s+e*a+n*l}}}const Bo=new C,wl=new Mc,Ml=new Mc,El=new Mc;class Ip extends Ze{constructor(t=[],e=!1,n="centripetal",i=.5){super(),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}getPoint(t,e=new C){const n=e,i=this.points,s=i.length,a=(s-(this.closed?0:1))*t;let l=Math.floor(a),u=a-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/s)+1)*s:u===0&&l===s-1&&(l=s-2,u=1);let h,p;this.closed||l>0?h=i[(l-1)%s]:(Bo.subVectors(i[0],i[1]).add(i[0]),h=Bo);const f=i[l%s],m=i[(l+1)%s];if(this.closed||l+2<s?p=i[(l+2)%s]:(Bo.subVectors(i[s-1],i[s-2]).add(i[s-1]),p=Bo),this.curveType==="centripetal"||this.curveType==="chordal"){const v=this.curveType==="chordal"?.5:.25;let x=Math.pow(h.distanceToSquared(f),v),b=Math.pow(f.distanceToSquared(m),v),w=Math.pow(m.distanceToSquared(p),v);b<1e-4&&(b=1),x<1e-4&&(x=b),w<1e-4&&(w=b),wl.initNonuniformCatmullRom(h.x,f.x,m.x,p.x,x,b,w),Ml.initNonuniformCatmullRom(h.y,f.y,m.y,p.y,x,b,w),El.initNonuniformCatmullRom(h.z,f.z,m.z,p.z,x,b,w)}else this.curveType==="catmullrom"&&(wl.initCatmullRom(h.x,f.x,m.x,p.x,this.tension),Ml.initCatmullRom(h.y,f.y,m.y,p.y,this.tension),El.initCatmullRom(h.z,f.z,m.z,p.z,this.tension));return n.set(wl.calc(u),Ml.calc(u),El.calc(u)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(i.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const i=this.points[e];t.points.push(i.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(new C().fromArray(i))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}Ip.prototype.isCatmullRomCurve3=!0;function td(r,t,e,n,i){const s=(n-t)*.5,a=(i-e)*.5,l=r*r,u=r*l;return(2*e-2*n+s+a)*u+(-3*e+3*n-2*s-a)*l+s*r+e}function mM(r,t){const e=1-r;return e*e*t}function gM(r,t){return 2*(1-r)*r*t}function vM(r,t){return r*r*t}function Lr(r,t,e,n){return mM(r,t)+gM(r,e)+vM(r,n)}function _M(r,t){const e=1-r;return e*e*e*t}function xM(r,t){const e=1-r;return 3*e*e*r*t}function yM(r,t){return 3*(1-r)*r*r*t}function bM(r,t){return r*r*r*t}function Rr(r,t,e,n,i){return _M(r,t)+xM(r,e)+yM(r,n)+bM(r,i)}class Ec extends Ze{constructor(t=new nt,e=new nt,n=new nt,i=new nt){super(),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new nt){const n=e,i=this.v0,s=this.v1,a=this.v2,l=this.v3;return n.set(Rr(t,i.x,s.x,a.x,l.x),Rr(t,i.y,s.y,a.y,l.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Ec.prototype.isCubicBezierCurve=!0;class Dp extends Ze{constructor(t=new C,e=new C,n=new C,i=new C){super(),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new C){const n=e,i=this.v0,s=this.v1,a=this.v2,l=this.v3;return n.set(Rr(t,i.x,s.x,a.x,l.x),Rr(t,i.y,s.y,a.y,l.y),Rr(t,i.z,s.z,a.z,l.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Dp.prototype.isCubicBezierCurve3=!0;class _a extends Ze{constructor(t=new nt,e=new nt){super(),this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new nt){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new nt;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}_a.prototype.isLineCurve=!0;class wM extends Ze{constructor(t=new C,e=new C){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new C){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Sc extends Ze{constructor(t=new nt,e=new nt,n=new nt){super(),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new nt){const n=e,i=this.v0,s=this.v1,a=this.v2;return n.set(Lr(t,i.x,s.x,a.x),Lr(t,i.y,s.y,a.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Sc.prototype.isQuadraticBezierCurve=!0;class Np extends Ze{constructor(t=new C,e=new C,n=new C){super(),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new C){const n=e,i=this.v0,s=this.v1,a=this.v2;return n.set(Lr(t,i.x,s.x,a.x),Lr(t,i.y,s.y,a.y),Lr(t,i.z,s.z,a.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Np.prototype.isQuadraticBezierCurve3=!0;class Tc extends Ze{constructor(t=[]){super(),this.type="SplineCurve",this.points=t}getPoint(t,e=new nt){const n=e,i=this.points,s=(i.length-1)*t,a=Math.floor(s),l=s-a,u=i[a===0?a:a-1],h=i[a],p=i[a>i.length-2?i.length-1:a+1],f=i[a>i.length-3?i.length-1:a+2];return n.set(td(l,u.x,h.x,p.x,f.x),td(l,u.y,h.y,p.y,f.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const i=this.points[e];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(new nt().fromArray(i))}return this}}Tc.prototype.isSplineCurve=!0;var MM=Object.freeze({__proto__:null,ArcCurve:Rp,CatmullRomCurve3:Ip,CubicBezierCurve:Ec,CubicBezierCurve3:Dp,EllipseCurve:va,LineCurve:_a,LineCurve3:wM,QuadraticBezierCurve:Sc,QuadraticBezierCurve3:Np,SplineCurve:Tc});class EM extends Ze{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new _a(e,t))}getPoint(t){const e=t*this.getLength(),n=this.getCurveLengths();let i=0;for(;i<n.length;){if(n[i]>=e){const s=n[i]-e,a=this.curves[i],l=a.getLength(),u=l===0?0:1-s/l;return a.getPointAt(u)}i++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let i=0,s=this.curves;i<s.length;i++){const a=s[i],l=a&&a.isEllipseCurve?t*2:a&&(a.isLineCurve||a.isLineCurve3)?1:a&&a.isSplineCurve?t*a.points.length:t,u=a.getPoints(l);for(let h=0;h<u.length;h++){const p=u[h];n&&n.equals(p)||(e.push(p),n=p)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const i=t.curves[e];this.curves.push(i.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const i=this.curves[e];t.curves.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const i=t.curves[e];this.curves.push(new MM[i.type]().fromJSON(i))}return this}}class ql extends EM{constructor(t){super(),this.type="Path",this.currentPoint=new nt,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new _a(this.currentPoint.clone(),new nt(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,i){const s=new Sc(this.currentPoint.clone(),new nt(t,e),new nt(n,i));return this.curves.push(s),this.currentPoint.set(n,i),this}bezierCurveTo(t,e,n,i,s,a){const l=new Ec(this.currentPoint.clone(),new nt(t,e),new nt(n,i),new nt(s,a));return this.curves.push(l),this.currentPoint.set(s,a),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new Tc(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,i,s,a){const l=this.currentPoint.x,u=this.currentPoint.y;return this.absarc(t+l,e+u,n,i,s,a),this}absarc(t,e,n,i,s,a){return this.absellipse(t,e,n,n,i,s,a),this}ellipse(t,e,n,i,s,a,l,u){const h=this.currentPoint.x,p=this.currentPoint.y;return this.absellipse(t+h,e+p,n,i,s,a,l,u),this}absellipse(t,e,n,i,s,a,l,u){const h=new va(t,e,n,i,s,a,l,u);if(this.curves.length>0){const f=h.getPoint(0);f.equals(this.currentPoint)||this.lineTo(f.x,f.y)}this.curves.push(h);const p=h.getPoint(1);return this.currentPoint.copy(p),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class Ac extends ql{constructor(t){super(t),this.uuid=Ye(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const i=t.holes[e];this.holes.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const i=this.holes[e];t.holes.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const i=t.holes[e];this.holes.push(new ql().fromJSON(i))}return this}}class bn extends Wt{constructor(t,e=1){super(),this.type="Light",this.color=new yt(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}bn.prototype.isLight=!0;class SM extends bn{constructor(t,e,n){super(t,n),this.type="HemisphereLight",this.position.copy(Wt.DefaultUp),this.updateMatrix(),this.groundColor=new yt(e)}copy(t){return bn.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}SM.prototype.isHemisphereLight=!0;const ed=new Et,nd=new C,id=new C;class Cc{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new nt(512,512),this.map=null,this.mapPass=null,this.matrix=new Et,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new pa,this._frameExtents=new nt(1,1),this._viewportCount=1,this._viewports=[new ne(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;nd.setFromMatrixPosition(t.matrixWorld),e.position.copy(nd),id.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(id),e.updateMatrixWorld(),ed.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ed),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Fp extends Cc{constructor(){super(new De(50,1,.5,500)),this.focus=1}updateMatrices(t){const e=this.camera,n=Vr*2*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,s=t.distance||e.far;(n!==e.fov||i!==e.aspect||s!==e.far)&&(e.fov=n,e.aspect=i,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}Fp.prototype.isSpotLightShadow=!0;class kp extends bn{constructor(t,e,n=0,i=Math.PI/3,s=0,a=1){super(t,e),this.type="SpotLight",this.position.copy(Wt.DefaultUp),this.updateMatrix(),this.target=new Wt,this.distance=n,this.angle=i,this.penumbra=s,this.decay=a,this.shadow=new Fp}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}kp.prototype.isSpotLight=!0;const sd=new Et,pr=new C,Sl=new C;class Bp extends Cc{constructor(){super(new De(90,1,.5,500)),this._frameExtents=new nt(4,2),this._viewportCount=6,this._viewports=[new ne(2,1,1,1),new ne(0,1,1,1),new ne(3,1,1,1),new ne(1,1,1,1),new ne(3,0,1,1),new ne(1,0,1,1)],this._cubeDirections=[new C(1,0,0),new C(-1,0,0),new C(0,0,1),new C(0,0,-1),new C(0,1,0),new C(0,-1,0)],this._cubeUps=[new C(0,1,0),new C(0,1,0),new C(0,1,0),new C(0,1,0),new C(0,0,1),new C(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,s=t.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),pr.setFromMatrixPosition(t.matrixWorld),n.position.copy(pr),Sl.copy(n.position),Sl.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(Sl),n.updateMatrixWorld(),i.makeTranslation(-pr.x,-pr.y,-pr.z),sd.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(sd)}}Bp.prototype.isPointLightShadow=!0;class Op extends bn{constructor(t,e,n=0,i=1){super(t,e),this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new Bp}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}Op.prototype.isPointLight=!0;class Kr extends pc{constructor(t=-1,e=1,n=1,i=-1,s=.1,a=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,s,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=n-t,a=n+t,l=i+e,u=i-e;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,p=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=h*this.view.offsetX,a=s+h*this.view.width,l-=p*this.view.offsetY,u=l-p*this.view.height}this.projectionMatrix.makeOrthographic(s,a,l,u,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}Kr.prototype.isOrthographicCamera=!0;class Vp extends Cc{constructor(){super(new Kr(-5,5,5,-5,.5,500))}}Vp.prototype.isDirectionalLightShadow=!0;class Pc extends bn{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(Wt.DefaultUp),this.updateMatrix(),this.target=new Wt,this.shadow=new Vp}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Pc.prototype.isDirectionalLight=!0;class TM extends bn{constructor(t,e){super(t,e),this.type="AmbientLight"}}TM.prototype.isAmbientLight=!0;class AM extends bn{constructor(t,e,n=10,i=10){super(t,e),this.type="RectAreaLight",this.width=n,this.height=i}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}AM.prototype.isRectAreaLight=!0;class zp{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new C)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,s=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.282095),e.addScaledVector(a[1],.488603*i),e.addScaledVector(a[2],.488603*s),e.addScaledVector(a[3],.488603*n),e.addScaledVector(a[4],1.092548*(n*i)),e.addScaledVector(a[5],1.092548*(i*s)),e.addScaledVector(a[6],.315392*(3*s*s-1)),e.addScaledVector(a[7],1.092548*(n*s)),e.addScaledVector(a[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,s=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.886227),e.addScaledVector(a[1],2*.511664*i),e.addScaledVector(a[2],2*.511664*s),e.addScaledVector(a[3],2*.511664*n),e.addScaledVector(a[4],2*.429043*n*i),e.addScaledVector(a[5],2*.429043*i*s),e.addScaledVector(a[6],.743125*s*s-.247708),e.addScaledVector(a[7],2*.429043*n*s),e.addScaledVector(a[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+i*3);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+i*3);return t}static getBasisAt(t,e){const n=t.x,i=t.y,s=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*s,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*s,e[6]=.315392*(3*s*s-1),e[7]=1.092548*n*s,e[8]=.546274*(n*n-i*i)}}zp.prototype.isSphericalHarmonics3=!0;class Lc extends bn{constructor(t=new zp,e=1){super(void 0,e),this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}Lc.prototype.isLightProbe=!0;class Ps{static decodeText(t){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(t);let e="";for(let n=0,i=t.length;n<i;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.substr(0,e+1)}}class CM extends Yt{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}CM.prototype.isInstancedBufferGeometry=!0;class PM extends ae{constructor(t,e,n,i){typeof n=="number"&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,n),this.meshPerAttribute=i||1}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}PM.prototype.isInstancedBufferAttribute=!0;class Up extends Un{constructor(t){super(t),typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,a=Ds.get(t);if(a!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(a),s.manager.itemEnd(t)},0),a;const l={};l.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",l.headers=this.requestHeader,fetch(t,l).then(function(u){return u.blob()}).then(function(u){return createImageBitmap(u,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(u){Ds.add(t,u),e&&e(u),s.manager.itemEnd(t)}).catch(function(u){i&&i(u),s.manager.itemError(t),s.manager.itemEnd(t)}),s.manager.itemStart(t)}}Up.prototype.isImageBitmapLoader=!0;let Oo;const LM={getContext:function(){return Oo===void 0&&(Oo=new(window.AudioContext||window.webkitAudioContext)),Oo},setContext:function(r){Oo=r}};class RM extends Un{constructor(t){super(t)}load(t,e,n,i){const s=this,a=new bc(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(l){try{const u=l.slice(0);LM.getContext().decodeAudioData(u,function(p){e(p)})}catch(u){i?i(u):console.error(u),s.manager.itemError(t)}},n,i)}}class IM extends Lc{constructor(t,e,n=1){super(void 0,n);const i=new yt().set(t),s=new yt().set(e),a=new C(i.r,i.g,i.b),l=new C(s.r,s.g,s.b),u=Math.sqrt(Math.PI),h=u*Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(l).multiplyScalar(u),this.sh.coefficients[1].copy(a).sub(l).multiplyScalar(h)}}IM.prototype.isHemisphereLightProbe=!0;class DM extends Lc{constructor(t,e=1){super(void 0,e);const n=new yt().set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}DM.prototype.isAmbientLightProbe=!0;class NM extends Wt{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}class FM{constructor(t,e,n){this.binding=t,this.valueSize=n;let i,s,a;switch(e){case"quaternion":i=this._slerp,s=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,s=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,s=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=s,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,i=this.valueSize,s=t*i+i;let a=this.cumulativeWeight;if(a===0){for(let l=0;l!==i;++l)n[s+l]=n[l];a=e}else{a+=e;const l=e/a;this._mixBufferRegion(n,s,0,l,i)}this.cumulativeWeight=a}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,i=t*e+e,s=this.cumulativeWeight,a=this.cumulativeWeightAdditive,l=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const u=e*this._origIndex;this._mixBufferRegion(n,i,u,1-s,e)}a>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let u=e,h=e+e;u!==h;++u)if(n[u]!==n[u+e]){l.setValue(n,i);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,i=n*this._origIndex;t.getValue(e,i);for(let s=n,a=i;s!==a;++s)e[s]=e[i+s%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,i,s){if(i>=.5)for(let a=0;a!==s;++a)t[e+a]=t[n+a]}_slerp(t,e,n,i){se.slerpFlat(t,e,t,e,t,n,i)}_slerpAdditive(t,e,n,i,s){const a=this._workIndex*s;se.multiplyQuaternionsFlat(t,a,t,e,t,n),se.slerpFlat(t,e,t,e,t,a,i)}_lerp(t,e,n,i,s){const a=1-i;for(let l=0;l!==s;++l){const u=e+l;t[u]=t[u]*a+t[n+l]*i}}_lerpAdditive(t,e,n,i,s){for(let a=0;a!==s;++a){const l=e+a;t[l]=t[l]+t[n+a]*i}}}const Rc="\\[\\]\\.:\\/",kM=new RegExp("["+Rc+"]","g"),Ic="[^"+Rc+"]",BM="[^"+Rc.replace("\\.","")+"]",OM=/((?:WC+[\/:])*)/.source.replace("WC",Ic),VM=/(WCOD+)?/.source.replace("WCOD",BM),zM=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Ic),UM=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Ic),HM=new RegExp("^"+OM+VM+zM+UM+"$"),GM=["material","materials","bones"];class WM{constructor(t,e,n){const i=n||te.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=n.length;i!==s;++i)n[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}}class te{constructor(t,e,n){this.path=e,this.parsedPath=n||te.parseTrackName(e),this.node=te.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new te.Composite(t,e,n):new te(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(kM,"")}static parseTrackName(t){const e=HM.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const s=n.nodeName.substring(i+1);GM.indexOf(s)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=s)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(!e||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(n!==void 0)return n}if(t.children){const n=function(s){for(let a=0;a<s.length;a++){const l=s[a];if(l.name===e||l.uuid===e)return l;const u=n(l.children);if(u)return u}return null},i=n(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.node[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)t[e++]=n[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let s=e.propertyIndex;if(t||(t=te.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let h=e.objectIndex;switch(n){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let p=0;p<t.length;p++)if(t[p].name===h){h=p;break}break;default:if(t[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[n]}if(h!==void 0){if(t[h]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[h]}}const a=t[i];if(a===void 0){const h=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+h+"."+i+" but it wasn't found.",t);return}let l=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?l=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(l=this.Versioning.MatrixWorldNeedsUpdate);let u=this.BindingType.Direct;if(s!==void 0){if(i==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(t.geometry.isBufferGeometry){if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[s]!==void 0&&(s=t.morphTargetDictionary[s])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}u=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=s}else a.fromArray!==void 0&&a.toArray!==void 0?(u=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(u=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[u],this.setValue=this.SetterByBindingTypeAndVersioning[u][l]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}te.Composite=WM;te.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};te.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};te.prototype.GetterByBindingType=[te.prototype._getValue_direct,te.prototype._getValue_array,te.prototype._getValue_arrayElement,te.prototype._getValue_toArray];te.prototype.SetterByBindingTypeAndVersioning=[[te.prototype._setValue_direct,te.prototype._setValue_direct_setNeedsUpdate,te.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[te.prototype._setValue_array,te.prototype._setValue_array_setNeedsUpdate,te.prototype._setValue_array_setMatrixWorldNeedsUpdate],[te.prototype._setValue_arrayElement,te.prototype._setValue_arrayElement_setNeedsUpdate,te.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[te.prototype._setValue_fromArray,te.prototype._setValue_fromArray_setNeedsUpdate,te.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class jM{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const s=e.tracks,a=s.length,l=new Array(a),u={endingStart:Es,endingEnd:Es};for(let h=0;h!==a;++h){const p=s[h].createInterpolant(null);l[h]=p,p.settings=u}this._interpolantSettings=u,this._interpolants=l,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=S_,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const i=this._clip.duration,s=t._clip.duration,a=s/i,l=i/s;t.warp(1,a,e),this.warp(l,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,s=i.time,a=this.timeScale;let l=this._timeScaleInterpolant;l===null&&(l=i._lendControlInterpolant(),this._timeScaleInterpolant=l);const u=l.parameterPositions,h=l.sampleValues;return u[0]=s,u[1]=s+n,h[0]=t/a,h[1]=e/a,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled){this._updateWeight(t);return}const s=this._startTime;if(s!==null){const u=(t-s)*n;if(u<0||n===0)return;this._startTime=null,e=n*u}e*=this._updateTimeScale(t);const a=this._updateTime(e),l=this._updateWeight(t);if(l>0){const u=this._interpolants,h=this._propertyBindings;switch(this.blendMode){case Zd:for(let p=0,f=u.length;p!==f;++p)u[p].evaluate(a),h[p].accumulateAdditive(l);break;case hc:default:for(let p=0,f=u.length;p!==f;++p)u[p].evaluate(a),h[p].accumulate(i,l)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,s=this._loopCount;const a=n===T_;if(t===0)return s===-1?i:a&&(s&1)===1?e-i:i;if(n===E_){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else if(i<0)i=0;else{this.time=i;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(s===-1&&(t>=0?(s=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),i>=e||i<0){const l=Math.floor(i/e);i-=e*l,s+=Math.abs(l);const u=this.repetitions-s;if(u<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(u===1){const h=t<0;this._setEndings(h,!h,a)}else this._setEndings(!1,!1,a);this._loopCount=s,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:l})}}else this.time=i;if(a&&(s&1)===1)return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=Ss,i.endingEnd=Ss):(t?i.endingStart=this.zeroSlopeAtStart?Ss:Es:i.endingStart=oa,e?i.endingEnd=this.zeroSlopeAtEnd?Ss:Es:i.endingEnd=oa)}_scheduleFading(t,e,n){const i=this._mixer,s=i.time;let a=this._weightInterpolant;a===null&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);const l=a.parameterPositions,u=a.sampleValues;return l[0]=s,u[0]=e,l[1]=s+t,u[1]=n,this}}class XM extends fi{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,s=i.length,a=t._propertyBindings,l=t._interpolants,u=n.uuid,h=this._bindingsByRootAndName;let p=h[u];p===void 0&&(p={},h[u]=p);for(let f=0;f!==s;++f){const m=i[f],v=m.name;let x=p[v];if(x!==void 0)a[f]=x;else{if(x=a[f],x!==void 0){x._cacheIndex===null&&(++x.referenceCount,this._addInactiveBinding(x,u,v));continue}const b=e&&e._propertyBindings[f].binding.parsedPath;x=new FM(te.create(n,v,b),m.ValueTypeName,m.getValueSize()),++x.referenceCount,this._addInactiveBinding(x,u,v),a[f]=x}l[f].resultBuffer=x.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const n=(t._localRoot||this._root).uuid,i=t._clip.uuid,s=this._actionsByClip[i];this._bindAction(t,s&&s.knownActions[0]),this._addInactiveAction(t,i,n)}const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const s=e[n];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const s=e[n];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,n){const i=this._actions,s=this._actionsByClip;let a=s[e];if(a===void 0)a={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,s[e]=a;else{const l=a.knownActions;t._byClipCacheIndex=l.length,l.push(t)}t._cacheIndex=i.length,i.push(t),a.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const s=t._clip.uuid,a=this._actionsByClip,l=a[s],u=l.knownActions,h=u[u.length-1],p=t._byClipCacheIndex;h._byClipCacheIndex=p,u[p]=h,u.pop(),t._byClipCacheIndex=null;const f=l.actionByRoot,m=(t._localRoot||this._root).uuid;delete f[m],u.length===0&&delete a[s],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const s=e[n];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,s=e[i];t._cacheIndex=i,e[i]=t,s._cacheIndex=n,e[n]=s}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,s=e[i];t._cacheIndex=i,e[i]=t,s._cacheIndex=n,e[n]=s}_addInactiveBinding(t,e,n){const i=this._bindingsByRootAndName,s=this._bindings;let a=i[e];a===void 0&&(a={},i[e]=a),a[n]=t,t._cacheIndex=s.length,s.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,s=n.path,a=this._bindingsByRootAndName,l=a[i],u=e[e.length-1],h=t._cacheIndex;u._cacheIndex=h,e[h]=u,e.pop(),delete l[s],Object.keys(l).length===0&&delete a[i]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,s=e[i];t._cacheIndex=i,e[i]=t,s._cacheIndex=n,e[n]=s}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,s=e[i];t._cacheIndex=i,e[i]=t,s._cacheIndex=n,e[n]=s}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return n===void 0&&(n=new Cp(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,s=e[i];t.__cacheIndex=i,e[i]=t,s.__cacheIndex=n,e[n]=s}clipAction(t,e,n){const i=e||this._root,s=i.uuid;let a=typeof t=="string"?Xl.findByName(i,t):t;const l=a!==null?a.uuid:t,u=this._actionsByClip[l];let h=null;if(n===void 0&&(a!==null?n=a.blendMode:n=hc),u!==void 0){const f=u.actionByRoot[s];if(f!==void 0&&f.blendMode===n)return f;h=u.knownActions[0],a===null&&(a=h._clip)}if(a===null)return null;const p=new jM(this,a,e,n);return this._bindAction(p,h),this._addInactiveAction(p,l,s),p}existingAction(t,e){const n=e||this._root,i=n.uuid,s=typeof t=="string"?Xl.findByName(n,t):t,a=s?s.uuid:t,l=this._actionsByClip[a];return l!==void 0&&l.actionByRoot[i]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let n=e-1;n>=0;--n)t[n].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,i=this.time+=t,s=Math.sign(t),a=this._accuIndex^=1;for(let h=0;h!==n;++h)e[h]._update(i,t,s,a);const l=this._bindings,u=this._nActiveBindings;for(let h=0;h!==u;++h)l[h].apply(a);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,s=i[n];if(s!==void 0){const a=s.knownActions;for(let l=0,u=a.length;l!==u;++l){const h=a[l];this._deactivateAction(h);const p=h._cacheIndex,f=e[e.length-1];h._cacheIndex=null,h._byClipCacheIndex=null,f._cacheIndex=p,e[p]=f,e.pop(),this._removeInactiveBindingsForAction(h)}delete i[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const a in n){const l=n[a].actionByRoot,u=l[e];u!==void 0&&(this._deactivateAction(u),this._removeInactiveAction(u))}const i=this._bindingsByRootAndName,s=i[e];if(s!==void 0)for(const a in s){const l=s[a];l.restoreOriginalState(),this._removeInactiveBinding(l)}}uncacheAction(t,e){const n=this.existingAction(t,e);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}XM.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class $r{constructor(t){typeof t=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new $r(this.value.clone===void 0?this.value:this.value.clone())}}class qM extends ki{constructor(t,e,n=1){super(t,e),this.meshPerAttribute=n||1}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}qM.prototype.isInstancedInterleavedBuffer=!0;class YM{constructor(t,e,n=0,i=1/0){this.ray=new Ni(t,e),this.near=n,this.far=i,this.camera=null,this.layers=new tp,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!1,n=[]){return Yl(t,this,n,e),n.sort(rd),n}intersectObjects(t,e=!1,n=[]){for(let i=0,s=t.length;i<s;i++)Yl(t[i],this,n,e);return n.sort(rd),n}}function rd(r,t){return r.distance-t.distance}function Yl(r,t,e,n){if(r.layers.test(t.layers)&&r.raycast(t,e),n===!0){const i=r.children;for(let s=0,a=i.length;s<a;s++)Yl(i[s],t,e,!0)}}class od{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(Le(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}const ad=new C,Vo=new C;class xn{constructor(t=new C,e=new C){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t===void 0&&(console.warn("THREE.Line3: .getCenter() target is now required"),t=new C),t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t===void 0&&(console.warn("THREE.Line3: .delta() target is now required"),t=new C),t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return e===void 0&&(console.warn("THREE.Line3: .at() target is now required"),e=new C),this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){ad.subVectors(t,this.start),Vo.subVectors(this.end,this.start);const n=Vo.dot(Vo);let s=Vo.dot(ad)/n;return e&&(s=Le(s,0,1)),s}closestPointToPoint(t,e,n){const i=this.closestPointToPointParameter(t,e);return n===void 0&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),n=new C),this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}class ZM extends Wt{constructor(t){super(),this.material=t,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}}ZM.prototype.isImmediateRenderObject=!0;const ni=new C,zo=new Et,Tl=new Et;class KM extends fa{constructor(t){const e=Hp(t),n=new Yt,i=[],s=[],a=new yt(0,0,1),l=new yt(0,1,0);for(let h=0;h<e.length;h++){const p=e[h];p.parent&&p.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),s.push(a.r,a.g,a.b),s.push(l.r,l.g,l.b))}n.setAttribute("position",new qt(i,3)),n.setAttribute("color",new qt(s,3));const u=new Bi({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,u),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");Tl.copy(this.root.matrixWorld).invert();for(let s=0,a=0;s<e.length;s++){const l=e[s];l.parent&&l.parent.isBone&&(zo.multiplyMatrices(Tl,l.matrixWorld),ni.setFromMatrixPosition(zo),i.setXYZ(a,ni.x,ni.y,ni.z),zo.multiplyMatrices(Tl,l.parent.matrixWorld),ni.setFromMatrixPosition(zo),i.setXYZ(a+1,ni.x,ni.y,ni.z),a+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function Hp(r){const t=[];r&&r.isBone&&t.push(r);for(let e=0;e<r.children.length;e++)t.push.apply(t,Hp(r.children[e]));return t}class $M extends fa{constructor(t=10,e=10,n=4473924,i=8947848){n=new yt(n),i=new yt(i);const s=e/2,a=t/e,l=t/2,u=[],h=[];for(let m=0,v=0,x=-l;m<=e;m++,x+=a){u.push(-l,0,x,l,0,x),u.push(x,0,-l,x,0,l);const b=m===s?n:i;b.toArray(h,v),v+=3,b.toArray(h,v),v+=3,b.toArray(h,v),v+=3,b.toArray(h,v),v+=3}const p=new Yt;p.setAttribute("position",new qt(u,3)),p.setAttribute("color",new qt(h,3));const f=new Bi({vertexColors:!0,toneMapped:!1});super(p,f),this.type="GridHelper"}}const JM=new Float32Array(1);new Int32Array(JM.buffer);const QM=new sn({side:ye,depthWrite:!1,depthTest:!1});new wt(new fn,QM);Ze.create=function(r,t){return console.log("THREE.Curve.create() has been deprecated"),r.prototype=Object.create(Ze.prototype),r.prototype.constructor=r,r.prototype.getPoint=t,r};ql.prototype.fromPoints=function(r){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(r)};$M.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};KM.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};Un.prototype.extractUrlBase=function(r){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Ps.extractUrlBase(r)};Un.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};ve.prototype.center=function(r){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(r)};ve.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};ve.prototype.isIntersectionBox=function(r){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(r)};ve.prototype.isIntersectionSphere=function(r){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(r)};ve.prototype.size=function(r){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(r)};mi.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};pa.prototype.setFromMatrix=function(r){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(r)};xn.prototype.center=function(r){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(r)};Ae.prototype.flattenToArrayOffset=function(r,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(r,t)};Ae.prototype.multiplyVector3=function(r){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),r.applyMatrix3(this)};Ae.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};Ae.prototype.applyToBufferAttribute=function(r){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),r.applyMatrix3(this)};Ae.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};Ae.prototype.getInverse=function(r){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(r).invert()};Et.prototype.extractPosition=function(r){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(r)};Et.prototype.flattenToArrayOffset=function(r,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(r,t)};Et.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new C().setFromMatrixColumn(this,3)};Et.prototype.setRotationFromQuaternion=function(r){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(r)};Et.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};Et.prototype.multiplyVector3=function(r){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)};Et.prototype.multiplyVector4=function(r){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)};Et.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};Et.prototype.rotateAxis=function(r){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),r.transformDirection(this)};Et.prototype.crossVector=function(r){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)};Et.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};Et.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};Et.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};Et.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};Et.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};Et.prototype.applyToBufferAttribute=function(r){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)};Et.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};Et.prototype.makeFrustum=function(r,t,e,n,i,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(r,t,n,e,i,s)};Et.prototype.getInverse=function(r){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(r).invert()};qe.prototype.isIntersectionLine=function(r){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(r)};se.prototype.multiplyVector3=function(r){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),r.applyQuaternion(this)};se.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};Ni.prototype.isIntersectionBox=function(r){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(r)};Ni.prototype.isIntersectionPlane=function(r){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(r)};Ni.prototype.isIntersectionSphere=function(r){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(r)};de.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};de.prototype.barycoordFromPoint=function(r,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(r,t)};de.prototype.midpoint=function(r){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(r)};de.prototypenormal=function(r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(r)};de.prototype.plane=function(r){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(r)};de.barycoordFromPoint=function(r,t,e,n,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),de.getBarycoord(r,t,e,n,i)};de.normal=function(r,t,e,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),de.getNormal(r,t,e,n)};Ac.prototype.extractAllPoints=function(r){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(r)};Ac.prototype.extrude=function(r){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new ga(this,r)};Ac.prototype.makeGeometry=function(r){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Kw(this,r)};nt.prototype.fromAttribute=function(r,t,e){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(r,t,e)};nt.prototype.distanceToManhattan=function(r){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(r)};nt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};C.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};C.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};C.prototype.getPositionFromMatrix=function(r){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(r)};C.prototype.getScaleFromMatrix=function(r){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(r)};C.prototype.getColumnFromMatrix=function(r,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,r)};C.prototype.applyProjection=function(r){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(r)};C.prototype.fromAttribute=function(r,t,e){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(r,t,e)};C.prototype.distanceToManhattan=function(r){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(r)};C.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};ne.prototype.fromAttribute=function(r,t,e){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(r,t,e)};ne.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Wt.prototype.getChildByName=function(r){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(r)};Wt.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};Wt.prototype.translate=function(r,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,r)};Wt.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};Wt.prototype.applyMatrix=function(r){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(r)};Object.defineProperties(Wt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(r){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=r}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});wt.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(wt.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Kd},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});gc.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};De.prototype.setLens=function(r,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(r)};Object.defineProperties(bn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(r){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=r}},shadowCameraLeft:{set:function(r){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=r}},shadowCameraRight:{set:function(r){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=r}},shadowCameraTop:{set:function(r){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=r}},shadowCameraBottom:{set:function(r){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=r}},shadowCameraNear:{set:function(r){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=r}},shadowCameraFar:{set:function(r){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=r}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(r){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=r}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(r){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=r}},shadowMapHeight:{set:function(r){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=r}}});Object.defineProperties(ae.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===la},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(la)}}});ae.prototype.setDynamic=function(r){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(r===!0?la:Or),this};ae.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},ae.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Yt.prototype.addIndex=function(r){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(r)};Yt.prototype.addAttribute=function(r,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(r,new ae(arguments[1],arguments[2]))):r==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(r,t)};Yt.prototype.addDrawCall=function(r,t,e){e!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(r,t)};Yt.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};Yt.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};Yt.prototype.removeAttribute=function(r){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(r)};Yt.prototype.applyMatrix=function(r){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(r)};Object.defineProperties(Yt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});ki.prototype.setDynamic=function(r){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(r===!0?la:Or),this};ki.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};ga.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};ga.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};ga.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};mc.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};$r.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this};Object.defineProperties(Me.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new yt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(r){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=r===zd}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(r){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=r}}});Object.defineProperties(yn.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(r){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=r}}});ie.prototype.clearTarget=function(r,t,e,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(r),this.clear(t,e,n)};ie.prototype.animate=function(r){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(r)};ie.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};ie.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};ie.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};ie.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};ie.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};ie.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};ie.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};ie.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};ie.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};ie.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};ie.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};ie.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};ie.prototype.enableScissorTest=function(r){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(r)};ie.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};ie.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};ie.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};ie.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};ie.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};ie.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};ie.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};ie.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};ie.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};ie.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(ie.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(r){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=r}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(r){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=r}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(r){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=r===!0?Br:Yr}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(_p.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(rn.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(r){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=r}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(r){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=r}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(r){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=r}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(r){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=r}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(r){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=r}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(r){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=r}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(r){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=r}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(r){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=r}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(r){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=r}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(r){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=r}}});NM.prototype.load=function(r){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return new RM().load(r,function(n){t.setBuffer(n)}),this};fc.prototype.updateCubeMap=function(r,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(r,t)};fc.prototype.clear=function(r,t,e,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(r,t,e,n)};Os.crossOrigin=void 0;Os.loadTexture=function(r,t,e,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new wc;i.setCrossOrigin(this.crossOrigin);const s=i.load(r,e,void 0,n);return t&&(s.mapping=t),s};Os.loadTextureCube=function(r,t,e,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new fM;i.setCrossOrigin(this.crossOrigin);const s=i.load(r,e,void 0,n);return t&&(s.mapping=t),s};Os.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Os.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Od}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Od);class tE extends Un{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(e){return new sE(e)}),this.register(function(e){return new oE(e)}),this.register(function(e){return new aE(e)}),this.register(function(e){return new rE(e)}),this.register(function(e){return new nE(e)}),this.register(function(e){return new lE(e)})}load(t,e,n,i){const s=this;let a;this.resourcePath!==""?a=this.resourcePath:this.path!==""?a=this.path:a=Ps.extractUrlBase(t),this.manager.itemStart(t);const l=function(h){i?i(h):console.error(h),s.manager.itemError(t),s.manager.itemEnd(t)},u=new bc(this.manager);u.setPath(this.path),u.setResponseType("arraybuffer"),u.setRequestHeader(this.requestHeader),u.setWithCredentials(this.withCredentials),u.load(t,function(h){try{s.parse(h,a,function(p){e(p),s.manager.itemEnd(t)},l)}catch(p){l(p)}},n,l)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return this.pluginCallbacks.indexOf(t)===-1&&this.pluginCallbacks.push(t),this}unregister(t){return this.pluginCallbacks.indexOf(t)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,n,i){let s;const a={},l={};if(typeof t=="string")s=t;else if(Ps.decodeText(new Uint8Array(t,0,4))===Gp){try{a[Jt.KHR_BINARY_GLTF]=new cE(t)}catch(f){i&&i(f);return}s=a[Jt.KHR_BINARY_GLTF].content}else s=Ps.decodeText(new Uint8Array(t));const u=JSON.parse(s);if(u.asset===void 0||u.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const h=new xE(u,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});h.fileLoader.setRequestHeader(this.requestHeader);for(let p=0;p<this.pluginCallbacks.length;p++){const f=this.pluginCallbacks[p](h);l[f.name]=f,a[f.name]=!0}if(u.extensionsUsed)for(let p=0;p<u.extensionsUsed.length;++p){const f=u.extensionsUsed[p],m=u.extensionsRequired||[];switch(f){case Jt.KHR_MATERIALS_UNLIT:a[f]=new iE;break;case Jt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:a[f]=new dE;break;case Jt.KHR_DRACO_MESH_COMPRESSION:a[f]=new uE(u,this.dracoLoader);break;case Jt.KHR_TEXTURE_TRANSFORM:a[f]=new hE;break;case Jt.KHR_MESH_QUANTIZATION:a[f]=new pE;break;default:m.indexOf(f)>=0&&l[f]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+f+'".')}}h.setExtensions(a),h.setPlugins(l),h.parse(n,i)}}function eE(){let r={};return{get:function(t){return r[t]},add:function(t,e){r[t]=e},remove:function(t){delete r[t]},removeAll:function(){r={}}}}const Jt={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class nE{constructor(t){this.parser=t,this.name=Jt.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,e=this.parser.json.nodes||[];for(let n=0,i=e.length;n<i;n++){const s=e[n];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&t._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(t){const e=this.parser,n="light:"+t;let i=e.cache.get(n);if(i)return i;const s=e.json,u=((s.extensions&&s.extensions[this.name]||{}).lights||[])[t];let h;const p=new yt(16777215);u.color!==void 0&&p.fromArray(u.color);const f=u.range!==void 0?u.range:0;switch(u.type){case"directional":h=new Pc(p),h.target.position.set(0,0,-1),h.add(h.target);break;case"point":h=new Op(p),h.distance=f;break;case"spot":h=new kp(p),h.distance=f,u.spot=u.spot||{},u.spot.innerConeAngle=u.spot.innerConeAngle!==void 0?u.spot.innerConeAngle:0,u.spot.outerConeAngle=u.spot.outerConeAngle!==void 0?u.spot.outerConeAngle:Math.PI/4,h.angle=u.spot.outerConeAngle,h.penumbra=1-u.spot.innerConeAngle/u.spot.outerConeAngle,h.target.position.set(0,0,-1),h.add(h.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+u.type)}return h.position.set(0,0,0),h.decay=2,u.intensity!==void 0&&(h.intensity=u.intensity),h.name=e.createUniqueName(u.name||"light_"+t),i=Promise.resolve(h),e.cache.add(n,i),i}createNodeAttachment(t){const e=this,n=this.parser,s=n.json.nodes[t],l=(s.extensions&&s.extensions[this.name]||{}).light;return l===void 0?null:this._loadLight(l).then(function(u){return n._getNodeRef(e.cache,l,u)})}}class iE{constructor(){this.name=Jt.KHR_MATERIALS_UNLIT}getMaterialType(){return sn}extendParams(t,e,n){const i=[];t.color=new yt(1,1,1),t.opacity=1;const s=e.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const a=s.baseColorFactor;t.color.fromArray(a),t.opacity=a[3]}s.baseColorTexture!==void 0&&i.push(n.assignTexture(t,"map",s.baseColorTexture))}return Promise.all(i)}}class sE{constructor(t){this.parser=t,this.name=Jt.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const n=this.parser.json.materials[t];return!n.extensions||!n.extensions[this.name]?null:yc}extendMaterialParams(t,e){const n=this.parser,i=n.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];if(a.clearcoatFactor!==void 0&&(e.clearcoat=a.clearcoatFactor),a.clearcoatTexture!==void 0&&s.push(n.assignTexture(e,"clearcoatMap",a.clearcoatTexture)),a.clearcoatRoughnessFactor!==void 0&&(e.clearcoatRoughness=a.clearcoatRoughnessFactor),a.clearcoatRoughnessTexture!==void 0&&s.push(n.assignTexture(e,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),a.clearcoatNormalTexture!==void 0&&(s.push(n.assignTexture(e,"clearcoatNormalMap",a.clearcoatNormalTexture)),a.clearcoatNormalTexture.scale!==void 0)){const l=a.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new nt(l,-l)}return Promise.all(s)}}class rE{constructor(t){this.parser=t,this.name=Jt.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const n=this.parser.json.materials[t];return!n.extensions||!n.extensions[this.name]?null:yc}extendMaterialParams(t,e){const n=this.parser,i=n.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];return a.transmissionFactor!==void 0&&(e.transmission=a.transmissionFactor),a.transmissionTexture!==void 0&&s.push(n.assignTexture(e,"transmissionMap",a.transmissionTexture)),Promise.all(s)}}class oE{constructor(t){this.parser=t,this.name=Jt.KHR_TEXTURE_BASISU}loadTexture(t){const e=this.parser,n=e.json,i=n.textures[t];if(!i.extensions||!i.extensions[this.name])return null;const s=i.extensions[this.name],a=n.images[s.source],l=e.options.ktx2Loader;if(!l){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(t,a,l)}}class aE{constructor(t){this.parser=t,this.name=Jt.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const e=this.name,n=this.parser,i=n.json,s=i.textures[t];if(!s.extensions||!s.extensions[e])return null;const a=s.extensions[e],l=i.images[a.source];let u=n.textureLoader;if(l.uri){const h=n.options.manager.getHandler(l.uri);h!==null&&(u=h)}return this.detectSupport().then(function(h){if(h)return n.loadTextureImage(t,l,u);if(i.extensionsRequired&&i.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const e=new Image;e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.onload=e.onerror=function(){t(e.height===1)}})),this.isSupported}}class lE{constructor(t){this.name=Jt.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const e=this.parser.json,n=e.bufferViews[t];if(n.extensions&&n.extensions[this.name]){const i=n.extensions[this.name],s=this.parser.getDependency("buffer",i.buffer),a=this.parser.options.meshoptDecoder;if(!a||!a.supported){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([s,a.ready]).then(function(l){const u=i.byteOffset||0,h=i.byteLength||0,p=i.count,f=i.byteStride,m=new ArrayBuffer(p*f),v=new Uint8Array(l[0],u,h);return a.decodeGltfBuffer(new Uint8Array(m),p,f,v,i.mode,i.filter),m})}else return null}}const Gp="glTF",fr=12,ld={JSON:1313821514,BIN:5130562};class cE{constructor(t){this.name=Jt.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(t,0,fr);if(this.header={magic:Ps.decodeText(new Uint8Array(t.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==Gp)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-fr,i=new DataView(t,fr);let s=0;for(;s<n;){const a=i.getUint32(s,!0);s+=4;const l=i.getUint32(s,!0);if(s+=4,l===ld.JSON){const u=new Uint8Array(t,fr+s,a);this.content=Ps.decodeText(u)}else if(l===ld.BIN){const u=fr+s;this.body=t.slice(u,u+a)}s+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class uE{constructor(t,e){if(!e)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Jt.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=e,this.dracoLoader.preload()}decodePrimitive(t,e){const n=this.json,i=this.dracoLoader,s=t.extensions[this.name].bufferView,a=t.extensions[this.name].attributes,l={},u={},h={};for(const p in a){const f=Kl[p]||p.toLowerCase();l[f]=a[p]}for(const p in t.attributes){const f=Kl[p]||p.toLowerCase();if(a[p]!==void 0){const m=n.accessors[t.attributes[p]],v=Xr[m.componentType];h[f]=v,u[f]=m.normalized===!0}}return e.getDependency("bufferView",s).then(function(p){return new Promise(function(f){i.decodeDracoFile(p,function(m){for(const v in m.attributes){const x=m.attributes[v],b=u[v];b!==void 0&&(x.normalized=b)}f(m)},l,h)})})}}class hE{constructor(){this.name=Jt.KHR_TEXTURE_TRANSFORM}extendTexture(t,e){return e.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),e.offset===void 0&&e.rotation===void 0&&e.scale===void 0||(t=t.clone(),e.offset!==void 0&&t.offset.fromArray(e.offset),e.rotation!==void 0&&(t.rotation=e.rotation),e.scale!==void 0&&t.repeat.fromArray(e.scale),t.needsUpdate=!0),t}}class Zl extends Zr{constructor(t){super(),this.isGLTFSpecularGlossinessMaterial=!0;const e=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),n=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),i=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	texelSpecular = sRGBToLinear( texelSpecular );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),s=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),a=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.specularRoughness += geometryRoughness;","material.specularRoughness = min( material.specularRoughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),l={specular:{value:new yt().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=l,this.onBeforeCompile=function(u){for(const h in l)u.uniforms[h]=l[h];u.fragmentShader=u.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",e).replace("#include <metalnessmap_pars_fragment>",n).replace("#include <roughnessmap_fragment>",i).replace("#include <metalnessmap_fragment>",s).replace("#include <lights_physical_fragment>",a)},Object.defineProperties(this,{specular:{get:function(){return l.specular.value},set:function(u){l.specular.value=u}},specularMap:{get:function(){return l.specularMap.value},set:function(u){l.specularMap.value=u,u?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return l.glossiness.value},set:function(u){l.glossiness.value=u}},glossinessMap:{get:function(){return l.glossinessMap.value},set:function(u){l.glossinessMap.value=u,u?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(t)}copy(t){return super.copy(t),this.specularMap=t.specularMap,this.specular.copy(t.specular),this.glossinessMap=t.glossinessMap,this.glossiness=t.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class dE{constructor(){this.name=Jt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"]}getMaterialType(){return Zl}extendParams(t,e,n){const i=e.extensions[this.name];t.color=new yt(1,1,1),t.opacity=1;const s=[];if(Array.isArray(i.diffuseFactor)){const a=i.diffuseFactor;t.color.fromArray(a),t.opacity=a[3]}if(i.diffuseTexture!==void 0&&s.push(n.assignTexture(t,"map",i.diffuseTexture)),t.emissive=new yt(0,0,0),t.glossiness=i.glossinessFactor!==void 0?i.glossinessFactor:1,t.specular=new yt(1,1,1),Array.isArray(i.specularFactor)&&t.specular.fromArray(i.specularFactor),i.specularGlossinessTexture!==void 0){const a=i.specularGlossinessTexture;s.push(n.assignTexture(t,"glossinessMap",a)),s.push(n.assignTexture(t,"specularMap",a))}return Promise.all(s)}createMaterial(t){const e=new Zl(t);return e.fog=!0,e.color=t.color,e.map=t.map===void 0?null:t.map,e.lightMap=null,e.lightMapIntensity=1,e.aoMap=t.aoMap===void 0?null:t.aoMap,e.aoMapIntensity=1,e.emissive=t.emissive,e.emissiveIntensity=1,e.emissiveMap=t.emissiveMap===void 0?null:t.emissiveMap,e.bumpMap=t.bumpMap===void 0?null:t.bumpMap,e.bumpScale=1,e.normalMap=t.normalMap===void 0?null:t.normalMap,e.normalMapType=Di,t.normalScale&&(e.normalScale=t.normalScale),e.displacementMap=null,e.displacementScale=1,e.displacementBias=0,e.specularMap=t.specularMap===void 0?null:t.specularMap,e.specular=t.specular,e.glossinessMap=t.glossinessMap===void 0?null:t.glossinessMap,e.glossiness=t.glossiness,e.alphaMap=null,e.envMap=t.envMap===void 0?null:t.envMap,e.envMapIntensity=1,e.refractionRatio=.98,e}}class pE{constructor(){this.name=Jt.KHR_MESH_QUANTIZATION}}class Ns extends Vn{constructor(t,e,n,i){super(t,e,n,i)}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=t*i*3+i;for(let a=0;a!==i;a++)e[a]=n[s+a];return e}}Ns.prototype.beforeStart_=Ns.prototype.copySampleValue_;Ns.prototype.afterEnd_=Ns.prototype.copySampleValue_;Ns.prototype.interpolate_=function(r,t,e,n){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,l=a*2,u=a*3,h=n-t,p=(e-t)/h,f=p*p,m=f*p,v=r*u,x=v-u,b=-2*m+3*f,w=m-f,_=1-b,y=w-f+p;for(let M=0;M!==a;M++){const T=s[x+M+a],A=s[x+M+l]*h,E=s[v+M+a],P=s[v+M]*h;i[M]=_*T+y*A+b*E+w*P}return i};const Fn={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Xr={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},cd={9728:oe,9729:Re,9984:Ol,9985:Wd,9986:Vl,9987:Bs},ud={33071:Ve,33648:ia,10497:Ls},hd={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Kl={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},ii={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},fE={CUBICSPLINE:void 0,LINEAR:Rs,STEP:kr},Al={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function dd(r,t){return typeof r!="string"||r===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(r)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(r)||/^data:.*,.*$/i.test(r)||/^blob:.*$/i.test(r)?r:t+r)}function mE(r){return r.DefaultMaterial===void 0&&(r.DefaultMaterial=new Zr({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Ri})),r.DefaultMaterial}function mr(r,t,e){for(const n in e.extensions)r[n]===void 0&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[n]=e.extensions[n])}function Ai(r,t){t.extras!==void 0&&(typeof t.extras=="object"?Object.assign(r.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function gE(r,t,e){let n=!1,i=!1;for(let l=0,u=t.length;l<u;l++){const h=t[l];if(h.POSITION!==void 0&&(n=!0),h.NORMAL!==void 0&&(i=!0),n&&i)break}if(!n&&!i)return Promise.resolve(r);const s=[],a=[];for(let l=0,u=t.length;l<u;l++){const h=t[l];if(n){const p=h.POSITION!==void 0?e.getDependency("accessor",h.POSITION):r.attributes.position;s.push(p)}if(i){const p=h.NORMAL!==void 0?e.getDependency("accessor",h.NORMAL):r.attributes.normal;a.push(p)}}return Promise.all([Promise.all(s),Promise.all(a)]).then(function(l){const u=l[0],h=l[1];return n&&(r.morphAttributes.position=u),i&&(r.morphAttributes.normal=h),r.morphTargetsRelative=!0,r})}function vE(r,t){if(r.updateMorphTargets(),t.weights!==void 0)for(let e=0,n=t.weights.length;e<n;e++)r.morphTargetInfluences[e]=t.weights[e];if(t.extras&&Array.isArray(t.extras.targetNames)){const e=t.extras.targetNames;if(r.morphTargetInfluences.length===e.length){r.morphTargetDictionary={};for(let n=0,i=e.length;n<i;n++)r.morphTargetDictionary[e[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function _E(r){const t=r.extensions&&r.extensions[Jt.KHR_DRACO_MESH_COMPRESSION];let e;return t?e="draco:"+t.bufferView+":"+t.indices+":"+pd(t.attributes):e=r.indices+":"+pd(r.attributes)+":"+r.mode,e}function pd(r){let t="";const e=Object.keys(r).sort();for(let n=0,i=e.length;n<i;n++)t+=e[n]+":"+r[e[n]]+";";return t}function $l(r){switch(r){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class xE{constructor(t={},e={}){this.json=t,this.extensions={},this.plugins={},this.options=e,this.cache=new eE,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.textureCache={},this.nodeNamesUsed={},typeof createImageBitmap!="undefined"&&/Firefox/.test(navigator.userAgent)===!1?this.textureLoader=new Up(this.options.manager):this.textureLoader=new wc(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new bc(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,e){const n=this,i=this.json,s=this.extensions;this.cache.removeAll(),this._invokeAll(function(a){return a._markDefs&&a._markDefs()}),Promise.all(this._invokeAll(function(a){return a.beforeRoot&&a.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(a){const l={scene:a[0][i.scene||0],scenes:a[0],animations:a[1],cameras:a[2],asset:i.asset,parser:n,userData:{}};mr(s,l,i),Ai(l,i),Promise.all(n._invokeAll(function(u){return u.afterRoot&&u.afterRoot(l)})).then(function(){t(l)})}).catch(e)}_markDefs(){const t=this.json.nodes||[],e=this.json.skins||[],n=this.json.meshes||[];for(let i=0,s=e.length;i<s;i++){const a=e[i].joints;for(let l=0,u=a.length;l<u;l++)t[a[l]].isBone=!0}for(let i=0,s=t.length;i<s;i++){const a=t[i];a.mesh!==void 0&&(this._addNodeRef(this.meshCache,a.mesh),a.skin!==void 0&&(n[a.mesh].isSkinnedMesh=!0)),a.camera!==void 0&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(t,e){e!==void 0&&(t.refs[e]===void 0&&(t.refs[e]=t.uses[e]=0),t.refs[e]++)}_getNodeRef(t,e,n){if(t.refs[e]<=1)return n;const i=n.clone();return i.name+="_instance_"+t.uses[e]++,i}_invokeOne(t){const e=Object.values(this.plugins);e.push(this);for(let n=0;n<e.length;n++){const i=t(e[n]);if(i)return i}return null}_invokeAll(t){const e=Object.values(this.plugins);e.unshift(this);const n=[];for(let i=0;i<e.length;i++){const s=t(e[i]);s&&n.push(s)}return n}getDependency(t,e){const n=t+":"+e;let i=this.cache.get(n);if(!i){switch(t){case"scene":i=this.loadScene(e);break;case"node":i=this.loadNode(e);break;case"mesh":i=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(e)});break;case"accessor":i=this.loadAccessor(e);break;case"bufferView":i=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(e)});break;case"buffer":i=this.loadBuffer(e);break;case"material":i=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(e)});break;case"texture":i=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(e)});break;case"skin":i=this.loadSkin(e);break;case"animation":i=this.loadAnimation(e);break;case"camera":i=this.loadCamera(e);break;default:throw new Error("Unknown type: "+t)}this.cache.add(n,i)}return i}getDependencies(t){let e=this.cache.get(t);if(!e){const n=this,i=this.json[t+(t==="mesh"?"es":"s")]||[];e=Promise.all(i.map(function(s,a){return n.getDependency(t,a)})),this.cache.add(t,e)}return e}loadBuffer(t){const e=this.json.buffers[t],n=this.fileLoader;if(e.type&&e.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+e.type+" buffer type is not supported.");if(e.uri===void 0&&t===0)return Promise.resolve(this.extensions[Jt.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(s,a){n.load(dd(e.uri,i.path),s,void 0,function(){a(new Error('THREE.GLTFLoader: Failed to load buffer "'+e.uri+'".'))})})}loadBufferView(t){const e=this.json.bufferViews[t];return this.getDependency("buffer",e.buffer).then(function(n){const i=e.byteLength||0,s=e.byteOffset||0;return n.slice(s,s+i)})}loadAccessor(t){const e=this,n=this.json,i=this.json.accessors[t];if(i.bufferView===void 0&&i.sparse===void 0)return Promise.resolve(null);const s=[];return i.bufferView!==void 0?s.push(this.getDependency("bufferView",i.bufferView)):s.push(null),i.sparse!==void 0&&(s.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(s).then(function(a){const l=a[0],u=hd[i.type],h=Xr[i.componentType],p=h.BYTES_PER_ELEMENT,f=p*u,m=i.byteOffset||0,v=i.bufferView!==void 0?n.bufferViews[i.bufferView].byteStride:void 0,x=i.normalized===!0;let b,w;if(v&&v!==f){const _=Math.floor(m/v),y="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+_+":"+i.count;let M=e.cache.get(y);M||(b=new h(l,_*v,i.count*v/p),M=new ki(b,v/p),e.cache.add(y,M)),w=new Ii(M,u,m%v/p,x)}else l===null?b=new h(i.count*u):b=new h(l,m,i.count*u),w=new ae(b,u,x);if(i.sparse!==void 0){const _=hd.SCALAR,y=Xr[i.sparse.indices.componentType],M=i.sparse.indices.byteOffset||0,T=i.sparse.values.byteOffset||0,A=new y(a[1],M,i.sparse.count*_),E=new h(a[2],T,i.sparse.count*u);l!==null&&(w=new ae(w.array.slice(),w.itemSize,w.normalized));for(let P=0,I=A.length;P<I;P++){const N=A[P];if(w.setX(N,E[P*u]),u>=2&&w.setY(N,E[P*u+1]),u>=3&&w.setZ(N,E[P*u+2]),u>=4&&w.setW(N,E[P*u+3]),u>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return w})}loadTexture(t){const e=this.json,n=this.options,i=e.textures[t],s=e.images[i.source];let a=this.textureLoader;if(s.uri){const l=n.manager.getHandler(s.uri);l!==null&&(a=l)}return this.loadTextureImage(t,s,a)}loadTextureImage(t,e,n){const i=this,s=this.json,a=this.options,l=s.textures[t],u=(e.uri||e.bufferView)+":"+l.sampler;if(this.textureCache[u])return this.textureCache[u];const h=self.URL||self.webkitURL;let p=e.uri||"",f=!1,m=!0;const v=p.search(/\.jpe?g($|\?)/i)>0||p.search(/^data\:image\/jpeg/)===0;if((e.mimeType==="image/jpeg"||v)&&(m=!1),e.bufferView!==void 0)p=i.getDependency("bufferView",e.bufferView).then(function(b){if(e.mimeType==="image/png"){const _=new DataView(b,25,1).getUint8(0,!1);m=_===6||_===4||_===3}f=!0;const w=new Blob([b],{type:e.mimeType});return p=h.createObjectURL(w),p});else if(e.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const x=Promise.resolve(p).then(function(b){return new Promise(function(w,_){let y=w;n.isImageBitmapLoader===!0&&(y=function(M){w(new Ep(M))}),n.load(dd(b,a.path),y,void 0,_)})}).then(function(b){f===!0&&h.revokeObjectURL(p),b.flipY=!1,l.name&&(b.name=l.name),m||(b.format=li);const _=(s.samplers||{})[l.sampler]||{};return b.magFilter=cd[_.magFilter]||Re,b.minFilter=cd[_.minFilter]||Bs,b.wrapS=ud[_.wrapS]||Ls,b.wrapT=ud[_.wrapT]||Ls,i.associations.set(b,{type:"textures",index:t}),b});return this.textureCache[u]=x,x}assignTexture(t,e,n){const i=this;return this.getDependency("texture",n.index).then(function(s){if(n.texCoord!==void 0&&n.texCoord!=0&&!(e==="aoMap"&&n.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+n.texCoord+" for texture "+e+" not yet supported."),i.extensions[Jt.KHR_TEXTURE_TRANSFORM]){const a=n.extensions!==void 0?n.extensions[Jt.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const l=i.associations.get(s);s=i.extensions[Jt.KHR_TEXTURE_TRANSFORM].extendTexture(s,a),i.associations.set(s,l)}}t[e]=s})}assignFinalMaterial(t){const e=t.geometry;let n=t.material;const i=e.attributes.tangent!==void 0,s=e.attributes.color!==void 0,a=e.attributes.normal===void 0,l=Object.keys(e.morphAttributes).length>0,u=l&&e.morphAttributes.normal!==void 0;if(t.isPoints){const h="PointsMaterial:"+n.uuid;let p=this.cache.get(h);p||(p=new xc,Me.prototype.copy.call(p,n),p.color.copy(n.color),p.map=n.map,p.sizeAttenuation=!1,this.cache.add(h,p)),n=p}else if(t.isLine){const h="LineBasicMaterial:"+n.uuid;let p=this.cache.get(h);p||(p=new Bi,Me.prototype.copy.call(p,n),p.color.copy(n.color),this.cache.add(h,p)),n=p}if(i||s||a||l){let h="ClonedMaterial:"+n.uuid+":";n.isGLTFSpecularGlossinessMaterial&&(h+="specular-glossiness:"),i&&(h+="vertex-tangents:"),s&&(h+="vertex-colors:"),a&&(h+="flat-shading:"),l&&(h+="morph-targets:"),u&&(h+="morph-normals:");let p=this.cache.get(h);p||(p=n.clone(),s&&(p.vertexColors=!0),a&&(p.flatShading=!0),l&&(p.morphTargets=!0),u&&(p.morphNormals=!0),i&&(p.vertexTangents=!0,p.normalScale&&(p.normalScale.y*=-1),p.clearcoatNormalScale&&(p.clearcoatNormalScale.y*=-1)),this.cache.add(h,p),this.associations.set(p,this.associations.get(n))),n=p}n.aoMap&&e.attributes.uv2===void 0&&e.attributes.uv!==void 0&&e.setAttribute("uv2",e.attributes.uv),t.material=n}getMaterialType(){return Zr}loadMaterial(t){const e=this,n=this.json,i=this.extensions,s=n.materials[t];let a;const l={},u=s.extensions||{},h=[];if(u[Jt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const f=i[Jt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];a=f.getMaterialType(),h.push(f.extendParams(l,s,e))}else if(u[Jt.KHR_MATERIALS_UNLIT]){const f=i[Jt.KHR_MATERIALS_UNLIT];a=f.getMaterialType(),h.push(f.extendParams(l,s,e))}else{const f=s.pbrMetallicRoughness||{};if(l.color=new yt(1,1,1),l.opacity=1,Array.isArray(f.baseColorFactor)){const m=f.baseColorFactor;l.color.fromArray(m),l.opacity=m[3]}f.baseColorTexture!==void 0&&h.push(e.assignTexture(l,"map",f.baseColorTexture)),l.metalness=f.metallicFactor!==void 0?f.metallicFactor:1,l.roughness=f.roughnessFactor!==void 0?f.roughnessFactor:1,f.metallicRoughnessTexture!==void 0&&(h.push(e.assignTexture(l,"metalnessMap",f.metallicRoughnessTexture)),h.push(e.assignTexture(l,"roughnessMap",f.metallicRoughnessTexture))),a=this._invokeOne(function(m){return m.getMaterialType&&m.getMaterialType(t)}),h.push(Promise.all(this._invokeAll(function(m){return m.extendMaterialParams&&m.extendMaterialParams(t,l)})))}s.doubleSided===!0&&(l.side=on);const p=s.alphaMode||Al.OPAQUE;return p===Al.BLEND?(l.transparent=!0,l.depthWrite=!1):(l.transparent=!1,p===Al.MASK&&(l.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&a!==sn&&(h.push(e.assignTexture(l,"normalMap",s.normalTexture)),l.normalScale=new nt(1,-1),s.normalTexture.scale!==void 0&&l.normalScale.set(s.normalTexture.scale,-s.normalTexture.scale)),s.occlusionTexture!==void 0&&a!==sn&&(h.push(e.assignTexture(l,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(l.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&a!==sn&&(l.emissive=new yt().fromArray(s.emissiveFactor)),s.emissiveTexture!==void 0&&a!==sn&&h.push(e.assignTexture(l,"emissiveMap",s.emissiveTexture)),Promise.all(h).then(function(){let f;return a===Zl?f=i[Jt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(l):f=new a(l),s.name&&(f.name=s.name),f.map&&(f.map.encoding=Br),f.emissiveMap&&(f.emissiveMap.encoding=Br),Ai(f,s),e.associations.set(f,{type:"materials",index:t}),s.extensions&&mr(i,f,s),f})}createUniqueName(t){const e=te.sanitizeNodeName(t||"");let n=e;for(let i=1;this.nodeNamesUsed[n];++i)n=e+"_"+i;return this.nodeNamesUsed[n]=!0,n}loadGeometries(t){const e=this,n=this.extensions,i=this.primitiveCache;function s(l){return n[Jt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(l,e).then(function(u){return fd(u,l,e)})}const a=[];for(let l=0,u=t.length;l<u;l++){const h=t[l],p=_E(h),f=i[p];if(f)a.push(f.promise);else{let m;h.extensions&&h.extensions[Jt.KHR_DRACO_MESH_COMPRESSION]?m=s(h):m=fd(new Yt,h,e),i[p]={primitive:h,promise:m},a.push(m)}}return Promise.all(a)}loadMesh(t){const e=this,n=this.json,i=this.extensions,s=n.meshes[t],a=s.primitives,l=[];for(let u=0,h=a.length;u<h;u++){const p=a[u].material===void 0?mE(this.cache):this.getDependency("material",a[u].material);l.push(p)}return l.push(e.loadGeometries(a)),Promise.all(l).then(function(u){const h=u.slice(0,u.length-1),p=u[u.length-1],f=[];for(let v=0,x=p.length;v<x;v++){const b=p[v],w=a[v];let _;const y=h[v];if(w.mode===Fn.TRIANGLES||w.mode===Fn.TRIANGLE_STRIP||w.mode===Fn.TRIANGLE_FAN||w.mode===void 0)_=s.isSkinnedMesh===!0?new gc(b,y):new wt(b,y),_.isSkinnedMesh===!0&&!_.geometry.attributes.skinWeight.normalized&&_.normalizeSkinWeights(),w.mode===Fn.TRIANGLE_STRIP?_.geometry=md(_.geometry,$d):w.mode===Fn.TRIANGLE_FAN&&(_.geometry=md(_.geometry,aa));else if(w.mode===Fn.LINES)_=new fa(b,y);else if(w.mode===Fn.LINE_STRIP)_=new Xt(b,y);else if(w.mode===Fn.LINE_LOOP)_=new wp(b,y);else if(w.mode===Fn.POINTS)_=new Mp(b,y);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+w.mode);Object.keys(_.geometry.morphAttributes).length>0&&vE(_,s),_.name=e.createUniqueName(s.name||"mesh_"+t),Ai(_,s),w.extensions&&mr(i,_,w),e.assignFinalMaterial(_),f.push(_)}if(f.length===1)return f[0];const m=new ai;for(let v=0,x=f.length;v<x;v++)m.add(f[v]);return m})}loadCamera(t){let e;const n=this.json.cameras[t],i=n[n.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?e=new De(K_.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):n.type==="orthographic"&&(e=new Kr(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),n.name&&(e.name=this.createUniqueName(n.name)),Ai(e,n),Promise.resolve(e)}loadSkin(t){const e=this.json.skins[t],n={joints:e.joints};return e.inverseBindMatrices===void 0?Promise.resolve(n):this.getDependency("accessor",e.inverseBindMatrices).then(function(i){return n.inverseBindMatrices=i,n})}loadAnimation(t){const n=this.json.animations[t],i=[],s=[],a=[],l=[],u=[];for(let h=0,p=n.channels.length;h<p;h++){const f=n.channels[h],m=n.samplers[f.sampler],v=f.target,x=v.node!==void 0?v.node:v.id,b=n.parameters!==void 0?n.parameters[m.input]:m.input,w=n.parameters!==void 0?n.parameters[m.output]:m.output;i.push(this.getDependency("node",x)),s.push(this.getDependency("accessor",b)),a.push(this.getDependency("accessor",w)),l.push(m),u.push(v)}return Promise.all([Promise.all(i),Promise.all(s),Promise.all(a),Promise.all(l),Promise.all(u)]).then(function(h){const p=h[0],f=h[1],m=h[2],v=h[3],x=h[4],b=[];for(let _=0,y=p.length;_<y;_++){const M=p[_],T=f[_],A=m[_],E=v[_],P=x[_];if(M===void 0)continue;M.updateMatrix(),M.matrixAutoUpdate=!0;let I;switch(ii[P.path]){case ii.weights:I=Wr;break;case ii.rotation:I=Us;break;case ii.position:case ii.scale:default:I=jr;break}const N=M.name?M.name:M.uuid,z=E.interpolation!==void 0?fE[E.interpolation]:Rs,W=[];ii[P.path]===ii.weights?M.traverse(function(D){D.isMesh===!0&&D.morphTargetInfluences&&W.push(D.name?D.name:D.uuid)}):W.push(N);let H=A.array;if(A.normalized){const D=$l(H.constructor),V=new Float32Array(H.length);for(let G=0,B=H.length;G<B;G++)V[G]=H[G]*D;H=V}for(let D=0,V=W.length;D<V;D++){const G=new I(W[D]+"."+ii[P.path],T.array,H,z);E.interpolation==="CUBICSPLINE"&&(G.createInterpolant=function(j){return new Ns(this.times,this.values,this.getValueSize()/3,j)},G.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),b.push(G)}}const w=n.name?n.name:"animation_"+t;return new Xl(w,void 0,b)})}createNodeMesh(t){const e=this.json,n=this,i=e.nodes[t];return i.mesh===void 0?null:n.getDependency("mesh",i.mesh).then(function(s){const a=n._getNodeRef(n.meshCache,i.mesh,s);return i.weights!==void 0&&a.traverse(function(l){if(!!l.isMesh)for(let u=0,h=i.weights.length;u<h;u++)l.morphTargetInfluences[u]=i.weights[u]}),a})}loadNode(t){const e=this.json,n=this.extensions,i=this,s=e.nodes[t],a=s.name?i.createUniqueName(s.name):"";return function(){const l=[],u=i._invokeOne(function(h){return h.createNodeMesh&&h.createNodeMesh(t)});return u&&l.push(u),s.camera!==void 0&&l.push(i.getDependency("camera",s.camera).then(function(h){return i._getNodeRef(i.cameraCache,s.camera,h)})),i._invokeAll(function(h){return h.createNodeAttachment&&h.createNodeAttachment(t)}).forEach(function(h){l.push(h)}),Promise.all(l)}().then(function(l){let u;if(s.isBone===!0?u=new vc:l.length>1?u=new ai:l.length===1?u=l[0]:u=new Wt,u!==l[0])for(let h=0,p=l.length;h<p;h++)u.add(l[h]);if(s.name&&(u.userData.name=s.name,u.name=a),Ai(u,s),s.extensions&&mr(n,u,s),s.matrix!==void 0){const h=new Et;h.fromArray(s.matrix),u.applyMatrix4(h)}else s.translation!==void 0&&u.position.fromArray(s.translation),s.rotation!==void 0&&u.quaternion.fromArray(s.rotation),s.scale!==void 0&&u.scale.fromArray(s.scale);return i.associations.set(u,{type:"nodes",index:t}),u})}loadScene(t){const e=this.json,n=this.extensions,i=this.json.scenes[t],s=this,a=new ai;i.name&&(a.name=s.createUniqueName(i.name)),Ai(a,i),i.extensions&&mr(n,a,i);const l=i.nodes||[],u=[];for(let h=0,p=l.length;h<p;h++)u.push(Wp(l[h],a,e,s));return Promise.all(u).then(function(){return a})}}function Wp(r,t,e,n){const i=e.nodes[r];return n.getDependency("node",r).then(function(s){if(i.skin===void 0)return s;let a;return n.getDependency("skin",i.skin).then(function(l){a=l;const u=[];for(let h=0,p=a.joints.length;h<p;h++)u.push(n.getDependency("node",a.joints[h]));return Promise.all(u)}).then(function(l){return s.traverse(function(u){if(!u.isMesh)return;const h=[],p=[];for(let f=0,m=l.length;f<m;f++){const v=l[f];if(v){h.push(v);const x=new Et;a.inverseBindMatrices!==void 0&&x.fromArray(a.inverseBindMatrices.array,f*16),p.push(x)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',a.joints[f])}u.bind(new _c(h,p),u.matrixWorld)}),s})}).then(function(s){t.add(s);const a=[];if(i.children){const l=i.children;for(let u=0,h=l.length;u<h;u++){const p=l[u];a.push(Wp(p,s,e,n))}}return Promise.all(a)})}function yE(r,t,e){const n=t.attributes,i=new ve;if(n.POSITION!==void 0){const l=e.json.accessors[n.POSITION],u=l.min,h=l.max;if(u!==void 0&&h!==void 0){if(i.set(new C(u[0],u[1],u[2]),new C(h[0],h[1],h[2])),l.normalized){const p=$l(Xr[l.componentType]);i.min.multiplyScalar(p),i.max.multiplyScalar(p)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=t.targets;if(s!==void 0){const l=new C,u=new C;for(let h=0,p=s.length;h<p;h++){const f=s[h];if(f.POSITION!==void 0){const m=e.json.accessors[f.POSITION],v=m.min,x=m.max;if(v!==void 0&&x!==void 0){if(u.setX(Math.max(Math.abs(v[0]),Math.abs(x[0]))),u.setY(Math.max(Math.abs(v[1]),Math.abs(x[1]))),u.setZ(Math.max(Math.abs(v[2]),Math.abs(x[2]))),m.normalized){const b=$l(Xr[m.componentType]);u.multiplyScalar(b)}l.max(u)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(l)}r.boundingBox=i;const a=new mi;i.getCenter(a.center),a.radius=i.min.distanceTo(i.max)/2,r.boundingSphere=a}function fd(r,t,e){const n=t.attributes,i=[];function s(a,l){return e.getDependency("accessor",a).then(function(u){r.setAttribute(l,u)})}for(const a in n){const l=Kl[a]||a.toLowerCase();l in r.attributes||i.push(s(n[a],l))}if(t.indices!==void 0&&!r.index){const a=e.getDependency("accessor",t.indices).then(function(l){r.setIndex(l)});i.push(a)}return Ai(r,t),yE(r,t,e),Promise.all(i).then(function(){return t.targets!==void 0?gE(r,t.targets,e):r})}function md(r,t){let e=r.getIndex();if(e===null){const a=[],l=r.getAttribute("position");if(l!==void 0){for(let u=0;u<l.count;u++)a.push(u);r.setIndex(a),e=r.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),r}const n=e.count-2,i=[];if(t===aa)for(let a=1;a<=n;a++)i.push(e.getX(0)),i.push(e.getX(a)),i.push(e.getX(a+1));else for(let a=0;a<n;a++)a%2===0?(i.push(e.getX(a)),i.push(e.getX(a+1)),i.push(e.getX(a+2))):(i.push(e.getX(a+2)),i.push(e.getX(a+1)),i.push(e.getX(a)));i.length/3!==n&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=r.clone();return s.setIndex(i),s}const bE=r=>new Promise((t,e)=>{new wc().load(r,t,void 0,e)}),wE=r=>new Promise(async(t,e)=>{new tE().load(r,t,void 0,e)}),jp=0,ME=1,EE=2,gd=2,Cl=1.25,vd=1,Pi=6*4+4+4,Jl=65535,SE=Math.pow(2,-24);class Uo{constructor(){}}function _n(r,t,e){return e.min.x=t[r],e.min.y=t[r+1],e.min.z=t[r+2],e.max.x=t[r+3],e.max.y=t[r+4],e.max.z=t[r+5],e}function _d(r){let t=-1,e=-1/0;for(let n=0;n<3;n++){const i=r[n+3]-r[n];i>e&&(e=i,t=n)}return t}function xd(r,t){t.set(r)}function yd(r,t,e){let n,i;for(let s=0;s<3;s++){const a=s+3;n=r[s],i=t[s],e[s]=n<i?n:i,n=r[a],i=t[a],e[a]=n>i?n:i}}function Ho(r,t,e){for(let n=0;n<3;n++){const i=t[r+2*n],s=t[r+2*n+1],a=i-s,l=i+s;a<e[n]&&(e[n]=a),l>e[n+3]&&(e[n+3]=l)}}function gr(r){const t=r[3]-r[0],e=r[4]-r[1],n=r[5]-r[2];return 2*(t*e+e*n+n*t)}function TE(r,t){if(!r.index){const e=r.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;e>65535?i=new Uint32Array(new n(4*e)):i=new Uint16Array(new n(2*e)),r.setIndex(new ae(i,1));for(let s=0;s<e;s++)i[s]=s}}function AE(r){if(!r.groups||!r.groups.length)return[{offset:0,count:r.index.count/3}];const t=[],e=new Set;for(const i of r.groups)e.add(i.start),e.add(i.start+i.count);const n=Array.from(e.values()).sort((i,s)=>i-s);for(let i=0;i<n.length-1;i++){const s=n[i],a=n[i+1];t.push({offset:s/3,count:(a-s)/3})}return t}function Pl(r,t,e,n,i=null){let s=1/0,a=1/0,l=1/0,u=-1/0,h=-1/0,p=-1/0,f=1/0,m=1/0,v=1/0,x=-1/0,b=-1/0,w=-1/0;const _=i!==null;for(let y=t*6,M=(t+e)*6;y<M;y+=6){const T=r[y+0],A=r[y+1],E=T-A,P=T+A;E<s&&(s=E),P>u&&(u=P),_&&T<f&&(f=T),_&&T>x&&(x=T);const I=r[y+2],N=r[y+3],z=I-N,W=I+N;z<a&&(a=z),W>h&&(h=W),_&&I<m&&(m=I),_&&I>b&&(b=I);const H=r[y+4],D=r[y+5],V=H-D,G=H+D;V<l&&(l=V),G>p&&(p=G),_&&H<v&&(v=H),_&&H>w&&(w=H)}n[0]=s,n[1]=a,n[2]=l,n[3]=u,n[4]=h,n[5]=p,_&&(i[0]=f,i[1]=m,i[2]=v,i[3]=x,i[4]=b,i[5]=w)}function CE(r,t,e,n){let i=1/0,s=1/0,a=1/0,l=-1/0,u=-1/0,h=-1/0;for(let p=t*6,f=(t+e)*6;p<f;p+=6){const m=r[p+0];m<i&&(i=m),m>l&&(l=m);const v=r[p+2];v<s&&(s=v),v>u&&(u=v);const x=r[p+4];x<a&&(a=x),x>h&&(h=x)}n[0]=i,n[1]=s,n[2]=a,n[3]=l,n[4]=u,n[5]=h}function PE(r,t,e,n,i){let s=e,a=e+n-1;const l=i.pos,u=i.axis*2;for(;;){for(;s<=a&&t[s*6+u]<l;)s++;for(;s<=a&&t[a*6+u]>=l;)a--;if(s<a){for(let h=0;h<3;h++){let p=r[s*3+h];r[s*3+h]=r[a*3+h],r[a*3+h]=p;let f=t[s*6+h*2+0];t[s*6+h*2+0]=t[a*6+h*2+0],t[a*6+h*2+0]=f;let m=t[s*6+h*2+1];t[s*6+h*2+1]=t[a*6+h*2+1],t[a*6+h*2+1]=m}s++,a--}else return s}}const kn=32,LE=(r,t)=>r.candidate-t.candidate,si=new Array(kn).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Go=new Float32Array(6);function RE(r,t,e,n,i,s){let a=-1,l=0;if(s===jp)a=_d(t),a!==-1&&(l=(t[a]+t[a+3])/2);else if(s===ME)a=_d(r),a!==-1&&(l=IE(e,n,i,a));else if(s===EE){const u=gr(r);let h=Cl*i;const p=n*6,f=(n+i)*6;for(let m=0;m<3;m++){const v=t[m],w=(t[m+3]-v)/kn;if(i<kn/4){const _=[...si];_.length=i;let y=0;for(let T=p;T<f;T+=6,y++){const A=_[y];A.candidate=e[T+2*m],A.count=0;const{bounds:E,leftCacheBounds:P,rightCacheBounds:I}=A;for(let N=0;N<3;N++)I[N]=1/0,I[N+3]=-1/0,P[N]=1/0,P[N+3]=-1/0,E[N]=1/0,E[N+3]=-1/0;Ho(T,e,E)}_.sort(LE);let M=i;for(let T=0;T<M;T++){const A=_[T];for(;T+1<M&&_[T+1].candidate===A.candidate;)_.splice(T+1,1),M--}for(let T=p;T<f;T+=6){const A=e[T+2*m];for(let E=0;E<M;E++){const P=_[E];A>=P.candidate?Ho(T,e,P.rightCacheBounds):(Ho(T,e,P.leftCacheBounds),P.count++)}}for(let T=0;T<M;T++){const A=_[T],E=A.count,P=i-A.count,I=A.leftCacheBounds,N=A.rightCacheBounds;let z=0;E!==0&&(z=gr(I)/u);let W=0;P!==0&&(W=gr(N)/u);const H=vd+Cl*(z*E+W*P);H<h&&(a=m,h=H,l=A.candidate)}}else{for(let M=0;M<kn;M++){const T=si[M];T.count=0,T.candidate=v+w+M*w;const A=T.bounds;for(let E=0;E<3;E++)A[E]=1/0,A[E+3]=-1/0}for(let M=p;M<f;M+=6){let E=~~((e[M+2*m]-v)/w);E>=kn&&(E=kn-1);const P=si[E];P.count++,Ho(M,e,P.bounds)}const _=si[kn-1];xd(_.bounds,_.rightCacheBounds);for(let M=kn-2;M>=0;M--){const T=si[M],A=si[M+1];yd(T.bounds,A.rightCacheBounds,T.rightCacheBounds)}let y=0;for(let M=0;M<kn-1;M++){const T=si[M],A=T.count,E=T.bounds,I=si[M+1].rightCacheBounds;A!==0&&(y===0?xd(E,Go):yd(E,Go,Go)),y+=A;let N=0,z=0;y!==0&&(N=gr(Go)/u);const W=i-y;W!==0&&(z=gr(I)/u);const H=vd+Cl*(N*y+z*W);H<h&&(a=m,h=H,l=T.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${s} used.`);return{axis:a,pos:l}}function IE(r,t,e,n){let i=0;for(let s=t,a=t+e;s<a;s++)i+=r[s*6+n*2];return i/e}function DE(r,t){const e=r.attributes.position,n=r.index.array,i=n.length/3,s=new Float32Array(i*6),a=e.normalized,l=e.array,u=e.offset||0;let h=3;e.isInterleavedBufferAttribute&&(h=e.data.stride);const p=["getX","getY","getZ"];for(let f=0;f<i;f++){const m=f*3,v=f*6;let x,b,w;a?(x=n[m+0],b=n[m+1],w=n[m+2]):(x=n[m+0]*h+u,b=n[m+1]*h+u,w=n[m+2]*h+u);for(let _=0;_<3;_++){let y,M,T;a?(y=e[p[_]](x),M=e[p[_]](b),T=e[p[_]](w)):(y=l[x+_],M=l[b+_],T=l[w+_]);let A=y;M<A&&(A=M),T<A&&(A=T);let E=y;M>E&&(E=M),T>E&&(E=T);const P=(E-A)/2,I=_*2;s[v+I+0]=A+P,s[v+I+1]=P+(Math.abs(A)+P)*SE,A<t[_]&&(t[_]=A),E>t[_+3]&&(t[_+3]=E)}}return s}function NE(r,t){function e(_){m&&m(_/v)}function n(_,y,M,T=null,A=0){if(!x&&A>=u&&(x=!0,h&&(console.warn(`MeshBVH: Max depth of ${u} reached when generating BVH. Consider increasing maxDepth.`),console.warn(r))),M<=p||A>=u)return e(y+M),_.offset=y,_.count=M,_;const E=RE(_.boundingData,T,a,y,M,f);if(E.axis===-1)return e(y+M),_.offset=y,_.count=M,_;const P=PE(l,a,y,M,E);if(P===y||P===y+M)e(y+M),_.offset=y,_.count=M;else{_.splitAxis=E.axis;const I=new Uo,N=y,z=P-y;_.left=I,I.boundingData=new Float32Array(6),Pl(a,N,z,I.boundingData,s),n(I,N,z,s,A+1);const W=new Uo,H=P,D=M-z;_.right=W,W.boundingData=new Float32Array(6),Pl(a,H,D,W.boundingData,s),n(W,H,D,s,A+1)}return _}TE(r,t);const i=new Float32Array(6),s=new Float32Array(6),a=DE(r,i),l=r.index.array,u=t.maxDepth,h=t.verbose,p=t.maxLeafTris,f=t.strategy,m=t.onProgress,v=r.index.count/3;let x=!1;const b=[],w=AE(r);if(w.length===1){const _=w[0],y=new Uo;y.boundingData=i,CE(a,_.offset,_.count,s),n(y,_.offset,_.count,s),b.push(y)}else for(let _ of w){const y=new Uo;y.boundingData=new Float32Array(6),Pl(a,_.offset,_.count,y.boundingData,s),n(y,_.offset,_.count,s),b.push(y)}return b}function FE(r,t){const e=NE(r,t);let n,i,s;const a=[],l=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let p=0;p<e.length;p++){const f=e[p];let m=u(f);const v=new l(Pi*m);n=new Float32Array(v),i=new Uint32Array(v),s=new Uint16Array(v),h(0,f),a.push(v)}return a;function u(p){return p.count?1:1+u(p.left)+u(p.right)}function h(p,f){const m=p/4,v=p/2,x=!!f.count,b=f.boundingData;for(let w=0;w<6;w++)n[m+w]=b[w];if(x){const w=f.offset,_=f.count;return i[m+6]=w,s[v+14]=_,s[v+15]=Jl,p+Pi}else{const w=f.left,_=f.right,y=f.splitAxis;let M;if(M=h(p+Pi,w),M/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[m+6]=M/4,M=h(M,_),i[m+7]=y,M}}}class wn{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,i=-1/0;for(let s=0,a=t.length;s<a;s++){const u=t[s][e];n=u<n?u:n,i=u>i?u:i}this.min=n,this.max=i}setFromPoints(t,e){let n=1/0,i=-1/0;for(let s=0,a=e.length;s<a;s++){const l=e[s],u=t.dot(l);n=u<n?u:n,i=u>i?u:i}this.min=n,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}wn.prototype.setFromBox=function(){const r=new C;return function(e,n){const i=n.min,s=n.max;let a=1/0,l=-1/0;for(let u=0;u<=1;u++)for(let h=0;h<=1;h++)for(let p=0;p<=1;p++){r.x=i.x*u+s.x*(1-u),r.y=i.y*h+s.y*(1-h),r.z=i.z*p+s.z*(1-p);const f=e.dot(r);a=Math.min(f,a),l=Math.max(f,l)}this.min=a,this.max=l}}();(function(){const r=new wn;return function(e,n){const i=e.points,s=e.satAxes,a=e.satBounds,l=n.points,u=n.satAxes,h=n.satBounds;for(let p=0;p<3;p++){const f=a[p],m=s[p];if(r.setFromPoints(m,l),f.isSeparated(r))return!1}for(let p=0;p<3;p++){const f=h[p],m=u[p];if(r.setFromPoints(m,i),f.isSeparated(r))return!1}}})();const kE=function(){const r=new C,t=new C,e=new C;return function(i,s,a){const l=i.start,u=r,h=s.start,p=t;e.subVectors(l,h),r.subVectors(i.end,i.start),t.subVectors(s.end,s.start);const f=e.dot(p),m=p.dot(u),v=p.dot(p),x=e.dot(u),w=u.dot(u)*v-m*m;let _,y;w!==0?_=(f*m-x*v)/w:_=0,y=(f+_*m)/v,a.x=_,a.y=y}}(),Dc=function(){const r=new nt,t=new C,e=new C;return function(i,s,a,l){kE(i,s,r);let u=r.x,h=r.y;if(u>=0&&u<=1&&h>=0&&h<=1){i.at(u,a),s.at(h,l);return}else if(u>=0&&u<=1){h<0?s.at(0,l):s.at(1,l),i.closestPointToPoint(l,!0,a);return}else if(h>=0&&h<=1){u<0?i.at(0,a):i.at(1,a),s.closestPointToPoint(a,!0,l);return}else{let p;u<0?p=i.start:p=i.end;let f;h<0?f=s.start:f=s.end;const m=t,v=e;if(i.closestPointToPoint(f,!0,t),s.closestPointToPoint(p,!0,e),m.distanceToSquared(f)<=v.distanceToSquared(p)){a.copy(m),l.copy(f);return}else{a.copy(p),l.copy(v);return}}}}(),BE=function(){const r=new C,t=new C,e=new qe,n=new xn;return function(s,a){const{radius:l,center:u}=s,{a:h,b:p,c:f}=a;if(n.start=h,n.end=p,n.closestPointToPoint(u,!0,r).distanceTo(u)<=l||(n.start=h,n.end=f,n.closestPointToPoint(u,!0,r).distanceTo(u)<=l)||(n.start=p,n.end=f,n.closestPointToPoint(u,!0,r).distanceTo(u)<=l))return!0;const b=a.getPlane(e);if(Math.abs(b.distanceToPoint(u))<=l){const _=b.projectPoint(u,t);if(a.containsPoint(_))return!0}return!1}}(),OE=1e-15;function vs(r){return Math.abs(r)<OE}class zn extends de{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new C),this.satBounds=new Array(4).fill().map(()=>new wn),this.points=[this.a,this.b,this.c],this.sphere=new mi,this.plane=new qe,this.needsUpdate=!0}intersectsSphere(t){return BE(t,this)}update(){const t=this.a,e=this.b,n=this.c,i=this.points,s=this.satAxes,a=this.satBounds,l=s[0],u=a[0];this.getNormal(l),u.setFromPoints(l,i);const h=s[1],p=a[1];h.subVectors(t,e),p.setFromPoints(h,i);const f=s[2],m=a[2];f.subVectors(e,n),m.setFromPoints(f,i);const v=s[3],x=a[3];v.subVectors(n,t),x.setFromPoints(v,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(l,t),this.needsUpdate=!1}}zn.prototype.closestPointToSegment=function(){const r=new C,t=new C,e=new xn;return function(i,s=null,a=null){const{start:l,end:u}=i,h=this.points;let p,f=1/0;for(let m=0;m<3;m++){const v=(m+1)%3;e.start.copy(h[m]),e.end.copy(h[v]),Dc(e,i,r,t),p=r.distanceToSquared(t),p<f&&(f=p,s&&s.copy(r),a&&a.copy(t))}return this.closestPointToPoint(l,r),p=l.distanceToSquared(r),p<f&&(f=p,s&&s.copy(r),a&&a.copy(l)),this.closestPointToPoint(u,r),p=u.distanceToSquared(r),p<f&&(f=p,s&&s.copy(r),a&&a.copy(u)),Math.sqrt(f)}}();zn.prototype.intersectsTriangle=function(){const r=new zn,t=new Array(3),e=new Array(3),n=new wn,i=new wn,s=new C,a=new C,l=new C,u=new C,h=new xn,p=new xn,f=new xn;return function(v,x=null){this.needsUpdate&&this.update(),v.isExtendedTriangle?v.needsUpdate&&v.update():(r.copy(v),r.update(),v=r);const b=this.plane,w=v.plane;if(Math.abs(b.normal.dot(w.normal))>1-1e-10){const _=this.satBounds,y=this.satAxes;e[0]=v.a,e[1]=v.b,e[2]=v.c;for(let A=0;A<4;A++){const E=_[A],P=y[A];if(n.setFromPoints(P,e),E.isSeparated(n))return!1}const M=v.satBounds,T=v.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let A=0;A<4;A++){const E=M[A],P=T[A];if(n.setFromPoints(P,t),E.isSeparated(n))return!1}for(let A=0;A<4;A++){const E=y[A];for(let P=0;P<4;P++){const I=T[P];if(s.crossVectors(E,I),n.setFromPoints(s,t),i.setFromPoints(s,e),n.isSeparated(i))return!1}}return x&&(console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),x.start.set(0,0,0),x.end.set(0,0,0)),!0}else{const _=this.points;let y=!1,M=0;for(let D=0;D<3;D++){const V=_[D],G=_[(D+1)%3];h.start.copy(V),h.end.copy(G),h.delta(a);const B=y?p.start:p.end,j=vs(w.distanceToPoint(V));if(vs(w.normal.dot(a))&&j){p.copy(h),M=2;break}if((w.intersectLine(h,B)||j)&&!vs(B.distanceTo(G))){if(M++,y)break;y=!0}}if(M===1&&this.containsPoint(p.end))return x&&(x.start.copy(p.end),x.end.copy(p.end)),!0;if(M!==2)return!1;const T=v.points;let A=!1,E=0;for(let D=0;D<3;D++){const V=T[D],G=T[(D+1)%3];h.start.copy(V),h.end.copy(G),h.delta(l);const B=A?f.start:f.end,j=vs(b.distanceToPoint(V));if(vs(b.normal.dot(l))&&j){f.copy(h),E=2;break}if((b.intersectLine(h,B)||j)&&!vs(B.distanceTo(G))){if(E++,A)break;A=!0}}if(E===1&&this.containsPoint(f.end))return x&&(x.start.copy(f.end),x.end.copy(f.end)),!0;if(E!==2)return!1;if(p.delta(a),f.delta(l),a.dot(l)<0){let D=f.start;f.start=f.end,f.end=D}const P=p.start.dot(a),I=p.end.dot(a),N=f.start.dot(a),z=f.end.dot(a),W=I<N,H=P<z;return P!==z&&N!==I&&W===H?!1:(x&&(u.subVectors(p.start,f.start),u.dot(a)>0?x.start.copy(p.start):x.start.copy(f.start),u.subVectors(p.end,f.end),u.dot(a)<0?x.end.copy(p.end):x.end.copy(f.end)),!0)}}}();zn.prototype.distanceToPoint=function(){const r=new C;return function(e){return this.closestPointToPoint(e,r),e.distanceTo(r)}}();zn.prototype.distanceToTriangle=function(){const r=new C,t=new C,e=["a","b","c"],n=new xn,i=new xn;return function(a,l=null,u=null){const h=l||u?n:null;if(this.intersectsTriangle(a,h))return(l||u)&&(l&&h.getCenter(l),u&&h.getCenter(u)),0;let p=1/0;for(let f=0;f<3;f++){let m;const v=e[f],x=a[v];this.closestPointToPoint(x,r),m=x.distanceToSquared(r),m<p&&(p=m,l&&l.copy(r),u&&u.copy(x));const b=this[v];a.closestPointToPoint(b,r),m=b.distanceToSquared(r),m<p&&(p=m,l&&l.copy(b),u&&u.copy(r))}for(let f=0;f<3;f++){const m=e[f],v=e[(f+1)%3];n.set(this[m],this[v]);for(let x=0;x<3;x++){const b=e[x],w=e[(x+1)%3];i.set(a[b],a[w]),Dc(n,i,r,t);const _=r.distanceToSquared(t);_<p&&(p=_,l&&l.copy(r),u&&u.copy(t))}}return Math.sqrt(p)}}();class Mn extends ve{constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new Et,this.invMatrix=new Et,this.points=new Array(8).fill().map(()=>new C),this.satAxes=new Array(3).fill().map(()=>new C),this.satBounds=new Array(3).fill().map(()=>new wn),this.alignedSatBounds=new Array(3).fill().map(()=>new wn),this.needsUpdate=!1}set(t,e,n){super.set(t,e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Mn.prototype.update=function(){return function(){const t=this.matrix,e=this.min,n=this.max,i=this.points;for(let h=0;h<=1;h++)for(let p=0;p<=1;p++)for(let f=0;f<=1;f++){const m=1*h|2*p|4*f,v=i[m];v.x=h?n.x:e.x,v.y=p?n.y:e.y,v.z=f?n.z:e.z,v.applyMatrix4(t)}const s=this.satBounds,a=this.satAxes,l=i[0];for(let h=0;h<3;h++){const p=a[h],f=s[h],m=1<<h,v=i[m];p.subVectors(l,v),f.setFromPoints(p,i)}const u=this.alignedSatBounds;u[0].setFromPointsField(i,"x"),u[1].setFromPointsField(i,"y"),u[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();Mn.prototype.intersectsBox=function(){const r=new wn;return function(e){this.needsUpdate&&this.update();const n=e.min,i=e.max,s=this.satBounds,a=this.satAxes,l=this.alignedSatBounds;if(r.min=n.x,r.max=i.x,l[0].isSeparated(r)||(r.min=n.y,r.max=i.y,l[1].isSeparated(r))||(r.min=n.z,r.max=i.z,l[2].isSeparated(r)))return!1;for(let u=0;u<3;u++){const h=a[u],p=s[u];if(r.setFromBox(h,e),p.isSeparated(r))return!1}return!0}}();Mn.prototype.intersectsTriangle=function(){const r=new zn,t=new Array(3),e=new wn,n=new wn,i=new C;return function(a){this.needsUpdate&&this.update(),a.isExtendedTriangle?a.needsUpdate&&a.update():(r.copy(a),r.update(),a=r);const l=this.satBounds,u=this.satAxes;t[0]=a.a,t[1]=a.b,t[2]=a.c;for(let m=0;m<3;m++){const v=l[m],x=u[m];if(e.setFromPoints(x,t),v.isSeparated(e))return!1}const h=a.satBounds,p=a.satAxes,f=this.points;for(let m=0;m<3;m++){const v=h[m],x=p[m];if(e.setFromPoints(x,f),v.isSeparated(e))return!1}for(let m=0;m<3;m++){const v=u[m];for(let x=0;x<4;x++){const b=p[x];if(i.crossVectors(v,b),e.setFromPoints(i,t),n.setFromPoints(i,f),e.isSeparated(n))return!1}}return!0}}();Mn.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();Mn.prototype.distanceToPoint=function(){const r=new C;return function(e){return this.closestPointToPoint(e,r),e.distanceTo(r)}}();Mn.prototype.distanceToBox=function(){const r=["x","y","z"],t=new Array(12).fill().map(()=>new xn),e=new Array(12).fill().map(()=>new xn),n=new C,i=new C;return function(a,l=0,u=null,h=null){if(this.needsUpdate&&this.update(),this.intersectsBox(a))return(u||h)&&(a.getCenter(i),this.closestPointToPoint(i,n),a.closestPointToPoint(n,i),u&&u.copy(n),h&&h.copy(i)),0;const p=l*l,f=a.min,m=a.max,v=this.points;let x=1/0;for(let w=0;w<8;w++){const _=v[w];i.copy(_).clamp(f,m);const y=_.distanceToSquared(i);if(y<x&&(x=y,u&&u.copy(_),h&&h.copy(i),y<p))return Math.sqrt(y)}let b=0;for(let w=0;w<3;w++)for(let _=0;_<=1;_++)for(let y=0;y<=1;y++){const M=(w+1)%3,T=(w+2)%3,A=_<<M|y<<T,E=1<<w|_<<M|y<<T,P=v[A],I=v[E];t[b].set(P,I);const z=r[w],W=r[M],H=r[T],D=e[b],V=D.start,G=D.end;V[z]=f[z],V[W]=_?f[W]:m[W],V[H]=y?f[H]:m[W],G[z]=m[z],G[W]=_?f[W]:m[W],G[H]=y?f[H]:m[W],b++}for(let w=0;w<=1;w++)for(let _=0;_<=1;_++)for(let y=0;y<=1;y++){i.x=w?m.x:f.x,i.y=_?m.y:f.y,i.z=y?m.z:f.z,this.closestPointToPoint(i,n);const M=i.distanceToSquared(n);if(M<x&&(x=M,u&&u.copy(n),h&&h.copy(i),M<p))return Math.sqrt(M)}for(let w=0;w<12;w++){const _=t[w];for(let y=0;y<12;y++){const M=e[y];Dc(_,M,n,i);const T=n.distanceToSquared(i);if(T<x&&(x=T,u&&u.copy(n),h&&h.copy(i),T<p))return Math.sqrt(T)}}return Math.sqrt(x)}}();const Wo=new C,jo=new C,Xo=new C,bd=new nt,wd=new nt,Md=new nt,Ed=new C;function VE(r,t,e,n,i,s){let a;return s===ye?a=r.intersectTriangle(n,e,t,!0,i):a=r.intersectTriangle(t,e,n,s!==on,i),a===null?null:{distance:r.origin.distanceTo(i),point:i.clone()}}function zE(r,t,e,n,i,s,a){Wo.fromBufferAttribute(t,n),jo.fromBufferAttribute(t,i),Xo.fromBufferAttribute(t,s);const l=VE(r,Wo,jo,Xo,Ed,a);if(l){e&&(bd.fromBufferAttribute(e,n),wd.fromBufferAttribute(e,i),Md.fromBufferAttribute(e,s),l.uv=de.getUV(Ed,Wo,jo,Xo,bd,wd,Md,new nt));const u={a:n,b:i,c:s,normal:new C,materialIndex:0};de.getNormal(Wo,jo,Xo,u.normal),l.face=u,l.faceIndex=n}return l}function Xp(r,t,e,n,i){const s=n*3,a=r.index.getX(s),l=r.index.getX(s+1),u=r.index.getX(s+2),h=zE(e,r.attributes.position,r.attributes.uv,a,l,u,t);return h?(h.faceIndex=n,i&&i.push(h),h):null}function UE(r,t,e,n,i,s){for(let a=n,l=n+i;a<l;a++)Xp(r,t,e,a,s)}function HE(r,t,e,n,i){let s=1/0,a=null;for(let l=n,u=n+i;l<u;l++){const h=Xp(r,t,e,l);h&&h.distance<s&&(a=h,s=h.distance)}return a}function vn(r,t,e,n){const i=r.a,s=r.b,a=r.c;let l=t,u=t+1,h=t+2;e&&(l=e.getX(t),u=e.getX(t+1),h=e.getX(t+2)),i.x=n.getX(l),i.y=n.getY(l),i.z=n.getZ(l),s.x=n.getX(u),s.y=n.getY(u),s.z=n.getZ(u),a.x=n.getX(h),a.y=n.getY(h),a.z=n.getZ(h)}function Sd(r,t,e,n,i,s,a){const l=e.index,u=e.attributes.position;for(let h=r,p=t+r;h<p;h++)if(vn(a,h*3,l,u),a.needsUpdate=!0,n(a,h,i,s))return!0;return!1}class qp{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function Bn(r,t){return t[r+15]===65535}function Li(r,t){return t[r+6]}function Fs(r,t){return t[r+14]}function qr(r){return r+8}function ks(r,t){return t[r+6]}function Yp(r,t){return t[r+7]}const As=new ve,ca=new C,GE=["x","y","z"];function Ql(r,t,e,n,i){let s=r*2,a=Gs,l=hi,u=di;if(Bn(s,l)){const p=Li(r,u),f=Fs(s,l);UE(t,e,n,p,f,i)}else{const p=qr(r);ua(p,a,n,ca)&&Ql(p,t,e,n,i);const f=ks(r,u);ua(f,a,n,ca)&&Ql(f,t,e,n,i)}}function tc(r,t,e,n){let i=r*2,s=Gs,a=hi,l=di;if(Bn(i,a)){const h=Li(r,l),p=Fs(i,a);return HE(t,e,n,h,p)}else{const h=Yp(r,l),p=GE[h],m=n.direction[p]>=0;let v,x;m?(v=qr(r),x=ks(r,l)):(v=ks(r,l),x=qr(r));const w=ua(v,s,n,ca)?tc(v,t,e,n):null;if(w){const M=w.point[p];if(m?M<=s[x+h]:M>=s[x+h+3])return w}const y=ua(x,s,n,ca)?tc(x,t,e,n):null;return w&&y?w.distance<=y.distance?w:y:w||y||null}}const WE=function(){let r,t;const e=[],n=new qp(()=>new ve);return function(...a){r=n.getPrimitive(),t=n.getPrimitive(),e.push(r,t);const l=i(...a);n.releasePrimitive(r),n.releasePrimitive(t),e.pop(),e.pop();const u=e.length;return u>0&&(t=e[u-1],r=e[u-2]),l};function i(s,a,l,u,h=null,p=0,f=0){function m(M){let T=M*2,A=hi,E=di;for(;!Bn(T,A);)M=qr(M),T=M*2;return Li(M,E)}function v(M){let T=M*2,A=hi,E=di;for(;!Bn(T,A);)M=ks(M,E),T=M*2;return Li(M,E)+Fs(T,A)}let x=s*2,b=Gs,w=hi,_=di;if(Bn(x,w)){const M=Li(s,_),T=Fs(x,w);return _n(s,b,r),u(M,T,!1,f,p+s,r)}else{const M=qr(s),T=ks(s,_);let A=M,E=T,P,I,N,z;if(h&&(N=r,z=t,_n(A,b,N),_n(E,b,z),P=h(N),I=h(z),I<P)){A=T,E=M;const j=P;P=I,I=j,N=z}N||(N=r,_n(A,b,N));const W=Bn(A*2,w),H=l(N,W,P,f+1,p+A);let D;if(H===gd){const j=m(A),Q=v(A)-j;D=u(j,Q,!0,f+1,p+A,N)}else D=H&&i(A,a,l,u,h,p,f+1);if(D)return!0;z=t,_n(E,b,z);const V=Bn(E*2,w),G=l(z,V,I,f+1,p+E);let B;if(G===gd){const j=m(E),Q=v(E)-j;B=u(j,Q,!0,f+1,p+E,z)}else B=G&&i(E,a,l,u,h,p,f+1);return!!B}}}(),jE=function(){const r=new zn,t=new zn,e=new Et,n=new Mn,i=new Mn;return function s(a,l,u,h,p=null){let f=a*2,m=Gs,v=hi,x=di;if(p===null&&(u.boundingBox||u.computeBoundingBox(),n.set(u.boundingBox.min,u.boundingBox.max,h),p=n),Bn(f,v)){const w=l,_=w.index,y=w.attributes.position,M=u.index,T=u.attributes.position,A=Li(a,x),E=Fs(f,v);if(e.copy(h).invert(),u.boundsTree)return _n(a,m,i),i.matrix.copy(e),i.needsUpdate=!0,u.boundsTree.shapecast({intersectsBounds:I=>i.intersectsBox(I),intersectsTriangle:I=>{I.a.applyMatrix4(h),I.b.applyMatrix4(h),I.c.applyMatrix4(h),I.needsUpdate=!0;for(let N=A*3,z=(E+A)*3;N<z;N+=3)if(vn(t,N,_,y),t.needsUpdate=!0,I.intersectsTriangle(t))return!0;return!1}});for(let P=A*3,I=E+A*3;P<I;P+=3){vn(r,P,_,y),r.a.applyMatrix4(e),r.b.applyMatrix4(e),r.c.applyMatrix4(e),r.needsUpdate=!0;for(let N=0,z=M.count;N<z;N+=3)if(vn(t,N,M,T),t.needsUpdate=!0,r.intersectsTriangle(t))return!0}}else{const w=a+8,_=x[a+6];return _n(w,m,As),!!(p.intersectsBox(As)&&s(w,l,u,h,p)||(_n(_,m,As),p.intersectsBox(As)&&s(_,l,u,h,p)))}}}();function ua(r,t,e,n){return _n(r,t,As),e.intersectBox(As,n)}const ec=[];let ta,Gs,hi,di;function Mr(r){ta&&ec.push(ta),ta=r,Gs=new Float32Array(r),hi=new Uint16Array(r),di=new Uint32Array(r)}function qo(){ta=null,Gs=null,hi=null,di=null,ec.length&&Mr(ec.pop())}const Ll=Symbol("skip tree generation"),Rl=new ve,Il=new ve,_s=new Et,Ti=new Mn,vr=new Mn,_r=new C,Yo=new C,XE=new C,qE=new C,YE=new C,Td=new ve,dn=new qp(()=>new zn);class Ir{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),Ir.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});e={cloneBuffers:!0,...e};const n=t.geometry,i=t._roots,s=n.getIndex();let a;return e.cloneBuffers?a={roots:i.map(l=>l.slice()),index:s.array.slice()}:a={roots:i,index:s.array},a}static deserialize(t,e,n={}){if(typeof n=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),Ir.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});n={setIndex:!0,...n};const{index:i,roots:s}=t,a=new Ir(e,{...n,[Ll]:!0});if(a._roots=s,n.setIndex){const l=e.getIndex();if(l===null){const u=new ae(t.index,1,!1);e.setIndex(u)}else l.array!==i&&(l.array.set(i),l.needsUpdate=!0)}return a}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:jp,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Ll]:!1},e),e.useSharedArrayBuffer&&typeof SharedArrayBuffer=="undefined")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[Ll]||(this._roots=FE(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new ve))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index.array,i=e.attributes.position;let s,a,l,u,h=0;const p=this._roots;for(let m=0,v=p.length;m<v;m++)s=p[m],a=new Uint32Array(s),l=new Uint16Array(s),u=new Float32Array(s),f(0,h),h+=s.byteLength;function f(m,v,x=!1){const b=m*2;if(l[b+15]===Jl){const _=a[m+6],y=l[b+14];let M=1/0,T=1/0,A=1/0,E=-1/0,P=-1/0,I=-1/0;for(let N=3*_,z=3*(_+y);N<z;N++){const W=n[N],H=i.getX(W),D=i.getY(W),V=i.getZ(W);H<M&&(M=H),H>E&&(E=H),D<T&&(T=D),D>P&&(P=D),V<A&&(A=V),V>I&&(I=V)}return u[m+0]!==M||u[m+1]!==T||u[m+2]!==A||u[m+3]!==E||u[m+4]!==P||u[m+5]!==I?(u[m+0]=M,u[m+1]=T,u[m+2]=A,u[m+3]=E,u[m+4]=P,u[m+5]=I,!0):!1}else{const _=m+8,y=a[m+6],M=_+v,T=y+v;let A=x,E=!1,P=!1;t?A||(E=t.has(M),P=t.has(T),A=!E&&!P):(E=!0,P=!0);const I=A||E,N=A||P;let z=!1;I&&(z=f(_,v,A));let W=!1;N&&(W=f(y,v,A));const H=z||W;if(H)for(let D=0;D<3;D++){const V=_+D,G=y+D,B=u[V],j=u[V+3],ot=u[G],Q=u[G+3];u[m+D]=B<ot?B:ot,u[m+D+3]=j>Q?j:Q}return H}}}traverse(t,e=0){const n=this._roots[e],i=new Uint32Array(n),s=new Uint16Array(n);a(0);function a(l,u=0){const h=l*2,p=s[h+15]===Jl;if(p){const f=i[l+6],m=s[h+14];t(u,p,new Float32Array(n,l*4,6),f,m)}else{const f=l+Pi/4,m=i[l+6],v=i[l+7];t(u,p,new Float32Array(n,l*4,6),v)||(a(f,u+1),a(m,u+1))}}}raycast(t,e=Ri){const n=this._roots,i=this.geometry,s=[],a=e.isMaterial,l=Array.isArray(e),u=i.groups,h=a?e.side:e;for(let p=0,f=n.length;p<f;p++){const m=l?e[u[p].materialIndex].side:h,v=s.length;if(Mr(n[p]),Ql(0,i,m,t,s),qo(),l){const x=u[p].materialIndex;for(let b=v,w=s.length;b<w;b++)s[b].face.materialIndex=x}}return s}raycastFirst(t,e=Ri){const n=this._roots,i=this.geometry,s=e.isMaterial,a=Array.isArray(e);let l=null;const u=i.groups,h=s?e.side:e;for(let p=0,f=n.length;p<f;p++){const m=a?e[u[p].materialIndex].side:h;Mr(n[p]);const v=tc(0,i,m,t);qo(),v!=null&&(l==null||v.distance<l.distance)&&(l=v,a&&(v.face.materialIndex=u[p].materialIndex))}return l}intersectsGeometry(t,e){const n=this.geometry;let i=!1;for(const s of this._roots)if(Mr(s),i=jE(0,n,t,e),qo(),i)break;return i}shapecast(t,e,n){const i=this.geometry;if(t instanceof Function){if(e){const m=e;e=(v,x,b,w)=>{const _=x*3;return m(v,_,_+1,_+2,b,w)}}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const s=dn.getPrimitive();let{boundsTraverseOrder:a,intersectsBounds:l,intersectsRange:u,intersectsTriangle:h}=t;if(u&&h){const m=u;u=(v,x,b,w,_)=>m(v,x,b,w,_)?!0:Sd(v,x,i,h,b,w,s)}else u||(h?u=(m,v,x,b)=>Sd(m,v,i,h,x,b,s):u=(m,v,x)=>x);let p=!1,f=0;for(const m of this._roots){if(Mr(m),p=WE(0,i,l,u,a,f),qo(),p)break;f+=m.byteLength}return dn.releasePrimitive(s),p}bvhcast(t,e,n){let{intersectsRanges:i,intersectsTriangles:s}=n;const a=this.geometry.index,l=this.geometry.attributes.position,u=t.geometry.index,h=t.geometry.attributes.position;_s.copy(e).invert();const p=dn.getPrimitive(),f=dn.getPrimitive();if(s){let x=function(b,w,_,y,M,T,A,E){for(let P=_,I=_+y;P<I;P++){vn(f,P*3,u,h),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let N=b,z=b+w;N<z;N++)if(vn(p,N*3,a,l),p.needsUpdate=!0,s(p,f,N,P,M,T,A,E))return!0}return!1};var v=x;if(i){const b=i;i=function(w,_,y,M,T,A,E,P){return b(w,_,y,M,T,A,E,P)?!0:x(w,_,y,M,T,A,E,P)}}else i=x}t.getBoundingBox(Il),Il.applyMatrix4(e);const m=this.shapecast({intersectsBounds:x=>Il.intersectsBox(x),intersectsRange:(x,b,w,_,y,M)=>(Rl.copy(M),Rl.applyMatrix4(_s),t.shapecast({intersectsBounds:T=>Rl.intersectsBox(T),intersectsRange:(T,A,E,P,I)=>i(x,b,T,A,_,y,P,I)}))});return dn.releasePrimitive(p),dn.releasePrimitive(f),m}intersectsBox(t,e){return Ti.set(t.min,t.max,e),Ti.needsUpdate=!0,this.shapecast({intersectsBounds:n=>Ti.intersectsBox(n),intersectsTriangle:n=>Ti.intersectsTriangle(n)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},i={},s=0,a=1/0){t.boundingBox||t.computeBoundingBox(),Ti.set(t.boundingBox.min,t.boundingBox.max,e),Ti.needsUpdate=!0;const l=this.geometry,u=l.attributes.position,h=l.index,p=t.attributes.position,f=t.index,m=dn.getPrimitive(),v=dn.getPrimitive();let x=Yo,b=XE,w=null,_=null;i&&(w=qE,_=YE);let y=1/0,M=null,T=null;return _s.copy(e).invert(),vr.matrix.copy(_s),this.shapecast({boundsTraverseOrder:A=>Ti.distanceToBox(A),intersectsBounds:(A,E,P)=>P<y&&P<a?(E&&(vr.min.copy(A.min),vr.max.copy(A.max),vr.needsUpdate=!0),!0):!1,intersectsRange:(A,E)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:P=>vr.distanceToBox(P),intersectsBounds:(P,I,N)=>N<y&&N<a,intersectsRange:(P,I)=>{for(let N=P*3,z=(P+I)*3;N<z;N+=3){vn(v,N,f,p),v.a.applyMatrix4(e),v.b.applyMatrix4(e),v.c.applyMatrix4(e),v.needsUpdate=!0;for(let W=A*3,H=(A+E)*3;W<H;W+=3){vn(m,W,h,u),m.needsUpdate=!0;const D=m.distanceToTriangle(v,x,w);if(D<y&&(b.copy(x),_&&_.copy(w),y=D,M=W/3,T=N/3),D<s)return!0}}}});{const P=f?f.count:p.count;for(let I=0,N=P;I<N;I+=3){vn(v,I,f,p),v.a.applyMatrix4(e),v.b.applyMatrix4(e),v.c.applyMatrix4(e),v.needsUpdate=!0;for(let z=A*3,W=(A+E)*3;z<W;z+=3){vn(m,z,h,u),m.needsUpdate=!0;const H=m.distanceToTriangle(v,x,w);if(H<y&&(b.copy(x),_&&_.copy(w),y=H,M=z/3,T=I/3),H<s)return!0}}}}}),dn.releasePrimitive(m),dn.releasePrimitive(v),y===1/0?null:(n.point?n.point.copy(b):n.point=b.clone(),n.distance=y,n.faceIndex=M,i&&(i.point?i.point.copy(_):i.point=_.clone(),i.point.applyMatrix4(_s),b.applyMatrix4(_s),i.distance=b.sub(i.point).length(),i.faceIndex=T),n)}closestPointToPoint(t,e={},n=0,i=1/0){const s=n*n,a=i*i;let l=1/0,u=null;if(this.shapecast({boundsTraverseOrder:p=>(_r.copy(t).clamp(p.min,p.max),_r.distanceToSquared(t)),intersectsBounds:(p,f,m)=>m<l&&m<a,intersectsTriangle:(p,f)=>{p.closestPointToPoint(t,_r);const m=t.distanceToSquared(_r);return m<l&&(Yo.copy(_r),l=m,u=f),m<s}}),l===1/0)return null;const h=Math.sqrt(l);return e.point?e.point.copy(Yo):e.point=Yo.clone(),e.distance=h,e.faceIndex=u,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(n=>{_n(0,new Float32Array(n),Td),t.union(Td)}),t}}function ZE(r){switch(r){case 1:return"R";case 2:return"RG";case 3:return"RGBA";case 4:return"RGBA"}throw new Error}function KE(r){switch(r){case 1:return Xd;case 2:return Yd;case 3:return Fe;case 4:return Fe}}function Ad(r){switch(r){case 1:return qd;case 2:return uc;case 3:return ra;case 4:return ra}}class Zp extends zr{constructor(){super(),this.minFilter=oe,this.magFilter=oe,this.generateMipmaps=!1,this.overrideItemSize=null,this._forcedType=null}updateFrom(t){const e=this.overrideItemSize,n=t.itemSize,i=t.count;if(e!==null){if(n*i%e!==0)throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");t.itemSize=e,t.count=i*n/e}const s=t.itemSize,a=t.count,l=t.normalized,u=t.array.constructor,h=u.BYTES_PER_ELEMENT;let p=this._forcedType,f=s;if(p===null)switch(u){case Float32Array:p=Ne;break;case Uint8Array:case Uint16Array:case Uint32Array:p=On;break;case Int8Array:case Int16Array:case Int32Array:p=Qo;break}let m,v,x,b,w=ZE(s);switch(p){case Ne:x=1,v=KE(s),l&&h===1?(b=u,w+="8",u===Uint8Array?m=Dr:(m=zl,w+="_SNORM")):(b=Float32Array,w+="32F",m=Ne);break;case Qo:w+=h*8+"I",x=l?Math.pow(2,u.BYTES_PER_ELEMENT*8-1):1,v=Ad(s),h===1?(b=Int8Array,m=zl):h===2?(b=Int16Array,m=jd):(b=Int32Array,m=Qo);break;case On:w+=h*8+"UI",x=l?Math.pow(2,u.BYTES_PER_ELEMENT*8-1):1,v=Ad(s),h===1?(b=Uint8Array,m=Dr):h===2?(b=Uint16Array,m=Nr):(b=Uint32Array,m=On);break}f===3&&(v===Fe||v===ra)&&(f=4);const _=Math.ceil(Math.sqrt(a)),y=f*_*_,M=new b(y);for(let T=0;T<a;T++){const A=f*T;M[A]=t.getX(T)/x,s>=2&&(M[A+1]=t.getY(T)/x),s>=3&&(M[A+2]=t.getZ(T)/x,f===4&&(M[A+3]=1)),s>=4&&(M[A+3]=t.getW(T)/x)}this.internalFormat=w,this.format=v,this.type=m,this.image.width=_,this.image.height=_,this.image.data=M,this.needsUpdate=!0,this.dispose(),t.itemSize=n,t.count=i}}class $E extends Zp{constructor(){super(),this._forcedType=On}}class JE extends Zp{constructor(){super(),this._forcedType=Ne}}function QE(r,t,e){const n=r._roots;if(n.length!==1)throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");const i=n[0],s=new Uint16Array(i),a=new Uint32Array(i),l=new Float32Array(i),u=i.byteLength/Pi,h=2*Math.ceil(Math.sqrt(u/2)),p=new Float32Array(4*h*h),f=Math.ceil(Math.sqrt(u)),m=new Uint32Array(2*f*f);for(let v=0;v<u;v++){const x=v*Pi/4,b=x*2,w=x;for(let _=0;_<3;_++)p[8*v+0+_]=l[w+0+_],p[8*v+4+_]=l[w+3+_];if(Bn(b,s)){const _=Fs(b,s),y=Li(x,a),M=4294901760|_;m[v*2+0]=M,m[v*2+1]=y}else{const _=4*ks(x,a)/Pi,y=Yp(x,a);m[v*2+0]=y,m[v*2+1]=_}}t.image.data=p,t.image.width=h,t.image.height=h,t.format=Fe,t.type=Ne,t.internalFormat="RGBA32F",t.minFilter=oe,t.magFilter=oe,t.generateMipmaps=!1,t.needsUpdate=!0,t.dispose(),e.image.data=m,e.image.width=f,e.image.height=f,e.format=uc,e.type=On,e.internalFormat="RG32UI",e.minFilter=oe,e.magFilter=oe,e.generateMipmaps=!1,e.needsUpdate=!0,e.dispose()}class tS{constructor(){this.autoDispose=!0,this.index=new $E,this.position=new JE,this.bvhBounds=new zr,this.bvhContents=new zr,this.index.overrideItemSize=3}updateFrom(t){const{geometry:e}=t;QE(t,this.bvhBounds,this.bvhContents),this.index.updateFrom(e.index),this.position.updateFrom(e.attributes.position)}dispose(){const{index:t,position:e,bvhBounds:n,bvhContents:i}=this;t&&t.dispose(),e&&e.dispose(),n&&n.dispose(),i&&i.dispose()}}const eS=`
#ifndef TRI_INTERSECT_EPSILON
#define TRI_INTERSECT_EPSILON 1e-5
#endif

#ifndef INFINITY
#define INFINITY 1e20
#endif

struct BVH {

	usampler2D index;
	sampler2D position;

	sampler2D bvhBounds;
	usampler2D bvhContents;

};

// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,
// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically
// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.
`,nS=`

uvec4 uTexelFetch1D( usampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

ivec4 iTexelFetch1D( isampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 texelFetch1D( sampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {

	return
		barycoord.x * texelFetch1D( tex, faceIndices.x ) +
		barycoord.y * texelFetch1D( tex, faceIndices.y ) +
		barycoord.z * texelFetch1D( tex, faceIndices.z );

}

void ndcToCameraRay(
	vec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,
	out vec3 rayOrigin, out vec3 rayDirection
) {

	// get camera look direction and near plane for camera clipping
	vec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );
	vec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );
	float near = abs( nearVector.z / nearVector.w );

	// get the camera direction and position from camera matrices
	vec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );
	direction /= direction.w;
	direction = cameraWorld * direction - origin;

	// slide the origin along the ray until it sits at the near clip plane position
	origin.xyz += direction.xyz * near / dot( direction, lookDirection );

	rayOrigin = origin.xyz;
	rayDirection = direction.xyz;

}

float intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {

	// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/
	// https://tavianator.com/2011/ray_box.html
	vec3 invDir = 1.0 / rayDirection;

	// find intersection distances for each plane
	vec3 tMinPlane = invDir * ( boundsMin - rayOrigin );
	vec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );

	// get the min and max distances from each intersection
	vec3 tMinHit = min( tMaxPlane, tMinPlane );
	vec3 tMaxHit = max( tMaxPlane, tMinPlane );

	// get the furthest hit distance
	vec2 t = max( tMinHit.xx, tMinHit.yz );
	float t0 = max( t.x, t.y );

	// get the minimum hit distance
	t = min( tMaxHit.xx, tMaxHit.yz );
	float t1 = min( t.x, t.y );

	// set distance to 0.0 if the ray starts inside the box
	float dist = max( t0, 0.0 );

	return t1 >= dist ? dist : INFINITY;

}

bool intersectsTriangle(
	vec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,
	out vec3 barycoord, out vec3 norm, out float dist, out float side
) {

	// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d
	vec3 edge1 = b - a;
	vec3 edge2 = c - a;
	norm = cross( edge1, edge2 );

	float det = - dot( rayDirection, norm );
	float invdet = 1.0 / det;

	vec3 AO = rayOrigin - a;
	vec3 DAO = cross( AO, rayDirection );

	vec4 uvt;
	uvt.x = dot( edge2, DAO ) * invdet;
	uvt.y = - dot( edge1, DAO ) * invdet;
	uvt.z = dot( AO, norm ) * invdet;
	uvt.w = 1.0 - uvt.x - uvt.y;

	// set the hit information
	barycoord = uvt.wxy; // arranged in A, B, C order
	dist = uvt.z;
	side = sign( det );
	norm = side * normalize( norm );

	// add an epsilon to avoid misses between triangles
	uvt += vec4( TRI_INTERSECT_EPSILON );

	return all( greaterThanEqual( uvt, vec4( 0.0 ) ) );

}

bool intersectTriangles(
	BVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,
	inout float minDistance,

	// output variables
	out uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,
	out float side, out float dist
) {

	bool found = false;
	vec3 localBarycoord, localNormal;
	float localDist, localSide;
	for ( uint i = offset, l = offset + count; i < l; i ++ ) {

		uvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;
		vec3 a = texelFetch1D( bvh.position, indices.x ).rgb;
		vec3 b = texelFetch1D( bvh.position, indices.y ).rgb;
		vec3 c = texelFetch1D( bvh.position, indices.z ).rgb;

		if (
			intersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )
			&& localDist < minDistance
		) {

			found = true;
			minDistance = localDist;

			faceIndices = uvec4( indices.xyz, i );
			faceNormal = localNormal;

			side = localSide;
			barycoord = localBarycoord;
			dist = localDist;

		}

	}

	return found;

}

float intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {

	vec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;
	vec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;
	return intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );

}

bool bvhIntersectFirstHit(
	BVH bvh, vec3 rayOrigin, vec3 rayDirection,

	// output variables
	out uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,
	out float side, out float dist
) {

	// stack needs to be twice as long as the deepest tree we expect because
	// we push both the left and right child onto the stack every traversal
	int ptr = 0;
	uint stack[ 60 ];
	stack[ 0 ] = 0u;

	float triangleDistance = 1e20;
	bool found = false;
	while ( ptr > - 1 && ptr < 60 ) {

		uint currNodeIndex = stack[ ptr ];
		ptr --;

		// check if we intersect the current bounds
		float boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );
		if ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {

			continue;

		}

		uvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;
		bool isLeaf = bool( boundsInfo.x & 0xffff0000u );

		if ( isLeaf ) {

			uint count = boundsInfo.x & 0x0000ffffu;
			uint offset = boundsInfo.y;

			found = intersectTriangles(
				bvh, rayOrigin, rayDirection, offset, count, triangleDistance,
				faceIndices, faceNormal, barycoord, side, dist
			) || found;

		} else {

			uint leftIndex = currNodeIndex + 1u;
			uint splitAxis = boundsInfo.x & 0x0000ffffu;
			uint rightIndex = boundsInfo.y;

			bool leftToRight = rayDirection[ splitAxis ] >= 0.0;
			uint c1 = leftToRight ? leftIndex : rightIndex;
			uint c2 = leftToRight ? rightIndex : leftIndex;

			// set c2 in the stack so we traverse it later. We need to keep track of a pointer in
			// the stack while we traverse. The second pointer added is the one that will be
			// traversed first
			ptr ++;
			stack[ ptr ] = c2;

			ptr ++;
			stack[ ptr ] = c1;

		}

	}

	return found;

}

`,Cd={type:"change"},Dl={type:"start"},Nl={type:"end"};class iS extends fi{constructor(t,e){super(),e===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=t,this.domElement=e,this.enabled=!0,this.target=new C,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:Ji.ROTATE,MIDDLE:Ji.DOLLY,RIGHT:Ji.PAN},this.touches={ONE:Qi.ROTATE,TWO:Qi.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return l.phi},this.getAzimuthalAngle=function(){return l.theta},this.listenToKeyEvents=function(O){O.addEventListener("keydown",J),this._domElementKeyEvents=O},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(Cd),n.update(),s=i.NONE},this.update=function(){const O=new C,mt=new se().setFromUnitVectors(t.up,new C(0,1,0)),ht=mt.clone().invert(),U=new C,at=new se,$=2*Math.PI;return function(){const dt=n.object.position;O.copy(dt).sub(n.target),O.applyQuaternion(mt),l.setFromVector3(O),n.autoRotate&&s===i.NONE&&P(A()),n.enableDamping?(l.theta+=u.theta*n.dampingFactor,l.phi+=u.phi*n.dampingFactor):(l.theta+=u.theta,l.phi+=u.phi);let Ht=n.minAzimuthAngle,ee=n.maxAzimuthAngle;return isFinite(Ht)&&isFinite(ee)&&(Ht<-Math.PI?Ht+=$:Ht>Math.PI&&(Ht-=$),ee<-Math.PI?ee+=$:ee>Math.PI&&(ee-=$),Ht<=ee?l.theta=Math.max(Ht,Math.min(ee,l.theta)):l.theta=l.theta>(Ht+ee)/2?Math.max(Ht,l.theta):Math.min(ee,l.theta)),l.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,l.phi)),l.makeSafe(),l.radius*=h,l.radius=Math.max(n.minDistance,Math.min(n.maxDistance,l.radius)),n.enableDamping===!0?n.target.addScaledVector(p,n.dampingFactor):n.target.add(p),O.setFromSpherical(l),O.applyQuaternion(ht),dt.copy(n.target).add(O),n.object.lookAt(n.target),n.enableDamping===!0?(u.theta*=1-n.dampingFactor,u.phi*=1-n.dampingFactor,p.multiplyScalar(1-n.dampingFactor)):(u.set(0,0,0),p.set(0,0,0)),h=1,f||U.distanceToSquared(n.object.position)>a||8*(1-at.dot(n.object.quaternion))>a?(n.dispatchEvent(Cd),U.copy(n.object.position),at.copy(n.object.quaternion),f=!1,!0):!1}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",Pt),n.domElement.removeEventListener("pointerdown",tt),n.domElement.removeEventListener("wheel",R),n.domElement.removeEventListener("touchstart",it),n.domElement.removeEventListener("touchend",xt),n.domElement.removeEventListener("touchmove",gt),n.domElement.ownerDocument.removeEventListener("pointermove",et),n.domElement.ownerDocument.removeEventListener("pointerup",lt),n._domElementKeyEvents!==null&&n._domElementKeyEvents.removeEventListener("keydown",J)};const n=this,i={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=i.NONE;const a=1e-6,l=new od,u=new od;let h=1;const p=new C;let f=!1;const m=new nt,v=new nt,x=new nt,b=new nt,w=new nt,_=new nt,y=new nt,M=new nt,T=new nt;function A(){return 2*Math.PI/60/60*n.autoRotateSpeed}function E(){return Math.pow(.95,n.zoomSpeed)}function P(O){u.theta-=O}function I(O){u.phi-=O}const N=function(){const O=new C;return function(ht,U){O.setFromMatrixColumn(U,0),O.multiplyScalar(-ht),p.add(O)}}(),z=function(){const O=new C;return function(ht,U){n.screenSpacePanning===!0?O.setFromMatrixColumn(U,1):(O.setFromMatrixColumn(U,0),O.crossVectors(n.object.up,O)),O.multiplyScalar(ht),p.add(O)}}(),W=function(){const O=new C;return function(ht,U){const at=n.domElement;if(n.object.isPerspectiveCamera){const $=n.object.position;O.copy($).sub(n.target);let St=O.length();St*=Math.tan(n.object.fov/2*Math.PI/180),N(2*ht*St/at.clientHeight,n.object.matrix),z(2*U*St/at.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(N(ht*(n.object.right-n.object.left)/n.object.zoom/at.clientWidth,n.object.matrix),z(U*(n.object.top-n.object.bottom)/n.object.zoom/at.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function H(O){n.object.isPerspectiveCamera?h/=O:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*O)),n.object.updateProjectionMatrix(),f=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function D(O){n.object.isPerspectiveCamera?h*=O:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/O)),n.object.updateProjectionMatrix(),f=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function V(O){m.set(O.clientX,O.clientY)}function G(O){y.set(O.clientX,O.clientY)}function B(O){b.set(O.clientX,O.clientY)}function j(O){v.set(O.clientX,O.clientY),x.subVectors(v,m).multiplyScalar(n.rotateSpeed);const mt=n.domElement;P(2*Math.PI*x.x/mt.clientHeight),I(2*Math.PI*x.y/mt.clientHeight),m.copy(v),n.update()}function ot(O){M.set(O.clientX,O.clientY),T.subVectors(M,y),T.y>0?H(E()):T.y<0&&D(E()),y.copy(M),n.update()}function Q(O){w.set(O.clientX,O.clientY),_.subVectors(w,b).multiplyScalar(n.panSpeed),W(_.x,_.y),b.copy(w),n.update()}function ut(O){O.deltaY<0?D(E()):O.deltaY>0&&H(E()),n.update()}function rt(O){let mt=!1;switch(O.code){case n.keys.UP:W(0,n.keyPanSpeed),mt=!0;break;case n.keys.BOTTOM:W(0,-n.keyPanSpeed),mt=!0;break;case n.keys.LEFT:W(n.keyPanSpeed,0),mt=!0;break;case n.keys.RIGHT:W(-n.keyPanSpeed,0),mt=!0;break}mt&&(O.preventDefault(),n.update())}function Tt(O){if(O.touches.length==1)m.set(O.touches[0].pageX,O.touches[0].pageY);else{const mt=.5*(O.touches[0].pageX+O.touches[1].pageX),ht=.5*(O.touches[0].pageY+O.touches[1].pageY);m.set(mt,ht)}}function ct(O){if(O.touches.length==1)b.set(O.touches[0].pageX,O.touches[0].pageY);else{const mt=.5*(O.touches[0].pageX+O.touches[1].pageX),ht=.5*(O.touches[0].pageY+O.touches[1].pageY);b.set(mt,ht)}}function ft(O){const mt=O.touches[0].pageX-O.touches[1].pageX,ht=O.touches[0].pageY-O.touches[1].pageY,U=Math.sqrt(mt*mt+ht*ht);y.set(0,U)}function Ft(O){n.enableZoom&&ft(O),n.enablePan&&ct(O)}function K(O){n.enableZoom&&ft(O),n.enableRotate&&Tt(O)}function Ot(O){if(O.touches.length==1)v.set(O.touches[0].pageX,O.touches[0].pageY);else{const ht=.5*(O.touches[0].pageX+O.touches[1].pageX),U=.5*(O.touches[0].pageY+O.touches[1].pageY);v.set(ht,U)}x.subVectors(v,m).multiplyScalar(n.rotateSpeed);const mt=n.domElement;P(2*Math.PI*x.x/mt.clientHeight),I(2*Math.PI*x.y/mt.clientHeight),m.copy(v)}function Dt(O){if(O.touches.length==1)w.set(O.touches[0].pageX,O.touches[0].pageY);else{const mt=.5*(O.touches[0].pageX+O.touches[1].pageX),ht=.5*(O.touches[0].pageY+O.touches[1].pageY);w.set(mt,ht)}_.subVectors(w,b).multiplyScalar(n.panSpeed),W(_.x,_.y),b.copy(w)}function Mt(O){const mt=O.touches[0].pageX-O.touches[1].pageX,ht=O.touches[0].pageY-O.touches[1].pageY,U=Math.sqrt(mt*mt+ht*ht);M.set(0,U),T.set(0,Math.pow(M.y/y.y,n.zoomSpeed)),H(T.y),y.copy(M)}function bt(O){n.enableZoom&&Mt(O),n.enablePan&&Dt(O)}function Nt(O){n.enableZoom&&Mt(O),n.enableRotate&&Ot(O)}function tt(O){if(n.enabled!==!1)switch(O.pointerType){case"mouse":case"pen":At(O);break}}function et(O){if(n.enabled!==!1)switch(O.pointerType){case"mouse":case"pen":_t(O);break}}function lt(O){switch(O.pointerType){case"mouse":case"pen":F();break}}function At(O){O.preventDefault(),n.domElement.focus?n.domElement.focus():window.focus();let mt;switch(O.button){case 0:mt=n.mouseButtons.LEFT;break;case 1:mt=n.mouseButtons.MIDDLE;break;case 2:mt=n.mouseButtons.RIGHT;break;default:mt=-1}switch(mt){case Ji.DOLLY:if(n.enableZoom===!1)return;G(O),s=i.DOLLY;break;case Ji.ROTATE:if(O.ctrlKey||O.metaKey||O.shiftKey){if(n.enablePan===!1)return;B(O),s=i.PAN}else{if(n.enableRotate===!1)return;V(O),s=i.ROTATE}break;case Ji.PAN:if(O.ctrlKey||O.metaKey||O.shiftKey){if(n.enableRotate===!1)return;V(O),s=i.ROTATE}else{if(n.enablePan===!1)return;B(O),s=i.PAN}break;default:s=i.NONE}s!==i.NONE&&(n.domElement.ownerDocument.addEventListener("pointermove",et),n.domElement.ownerDocument.addEventListener("pointerup",lt),n.dispatchEvent(Dl))}function _t(O){if(n.enabled!==!1)switch(O.preventDefault(),s){case i.ROTATE:if(n.enableRotate===!1)return;j(O);break;case i.DOLLY:if(n.enableZoom===!1)return;ot(O);break;case i.PAN:if(n.enablePan===!1)return;Q(O);break}}function F(O){n.domElement.ownerDocument.removeEventListener("pointermove",et),n.domElement.ownerDocument.removeEventListener("pointerup",lt),n.enabled!==!1&&(n.dispatchEvent(Nl),s=i.NONE)}function R(O){n.enabled===!1||n.enableZoom===!1||s!==i.NONE&&s!==i.ROTATE||(O.preventDefault(),n.dispatchEvent(Dl),ut(O),n.dispatchEvent(Nl))}function J(O){n.enabled===!1||n.enablePan===!1||rt(O)}function it(O){if(n.enabled!==!1){switch(O.preventDefault(),O.touches.length){case 1:switch(n.touches.ONE){case Qi.ROTATE:if(n.enableRotate===!1)return;Tt(O),s=i.TOUCH_ROTATE;break;case Qi.PAN:if(n.enablePan===!1)return;ct(O),s=i.TOUCH_PAN;break;default:s=i.NONE}break;case 2:switch(n.touches.TWO){case Qi.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;Ft(O),s=i.TOUCH_DOLLY_PAN;break;case Qi.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;K(O),s=i.TOUCH_DOLLY_ROTATE;break;default:s=i.NONE}break;default:s=i.NONE}s!==i.NONE&&n.dispatchEvent(Dl)}}function gt(O){if(n.enabled!==!1)switch(O.preventDefault(),s){case i.TOUCH_ROTATE:if(n.enableRotate===!1)return;Ot(O),n.update();break;case i.TOUCH_PAN:if(n.enablePan===!1)return;Dt(O),n.update();break;case i.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;bt(O),n.update();break;case i.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;Nt(O),n.update();break;default:s=i.NONE}}function xt(O){n.enabled!==!1&&(n.dispatchEvent(Nl),s=i.NONE)}function Pt(O){n.enabled!==!1&&O.preventDefault()}n.domElement.addEventListener("contextmenu",Pt),n.domElement.addEventListener("pointerdown",tt),n.domElement.addEventListener("wheel",R,{passive:!1}),n.domElement.addEventListener("touchstart",it,{passive:!1}),n.domElement.addEventListener("touchend",xt),n.domElement.addEventListener("touchmove",gt,{passive:!1}),this.update()}}const xs=new YM,Oe=new C,ri=new C,ce=new se,Pd={X:new C(1,0,0),Y:new C(0,1,0),Z:new C(0,0,1)},Ld={type:"change"},Rd={type:"mouseDown"},Id={type:"mouseUp",mode:null},sS={type:"objectChange"};class Kp extends Wt{constructor(t,e){super(),e===void 0&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),e=document),this.visible=!1,this.domElement=e;const n=new $p;this._gizmo=n,this.add(n);const i=new Jp;this._plane=i,this.add(i);const s=this;function a(y,M){let T=M;Object.defineProperty(s,y,{get:function(){return T!==void 0?T:M},set:function(A){T!==A&&(T=A,i[y]=A,n[y]=A,s.dispatchEvent({type:y+"-changed",value:A}),s.dispatchEvent(Ld))}}),s[y]=M,i[y]=M,n[y]=M}a("camera",t),a("object",void 0),a("enabled",!0),a("axis",null),a("mode","translate"),a("translationSnap",null),a("rotationSnap",null),a("scaleSnap",null),a("space","world"),a("size",1),a("dragging",!1),a("showX",!0),a("showY",!0),a("showZ",!0);const l=new C,u=new C,h=new se,p=new se,f=new C,m=new se,v=new C,x=new C,b=new C,w=0,_=new C;a("worldPosition",l),a("worldPositionStart",u),a("worldQuaternion",h),a("worldQuaternionStart",p),a("cameraPosition",f),a("cameraQuaternion",m),a("pointStart",v),a("pointEnd",x),a("rotationAxis",b),a("rotationAngle",w),a("eye",_),this._offset=new C,this._startNorm=new C,this._endNorm=new C,this._cameraScale=new C,this._parentPosition=new C,this._parentQuaternion=new se,this._parentQuaternionInv=new se,this._parentScale=new C,this._worldScaleStart=new C,this._worldQuaternionInv=new se,this._worldScale=new C,this._positionStart=new C,this._quaternionStart=new se,this._scaleStart=new C,this._getPointer=rS.bind(this),this._onPointerDown=aS.bind(this),this._onPointerHover=oS.bind(this),this._onPointerMove=lS.bind(this),this._onPointerUp=cS.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.ownerDocument.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(t){if(this.object===void 0||this.dragging===!0)return;xs.setFromCamera(t,this.camera);const e=Fl(this._gizmo.picker[this.mode],xs);e?this.axis=e.object.name:this.axis=null}pointerDown(t){if(!(this.object===void 0||this.dragging===!0||t.button!==0)&&this.axis!==null){xs.setFromCamera(t,this.camera);const e=Fl(this._plane,xs,!0);if(e){let n=this.space;if(this.mode==="scale"?n="local":(this.axis==="E"||this.axis==="XYZE"||this.axis==="XYZ")&&(n="world"),n==="local"&&this.mode==="rotate"){const i=this.rotationSnap;this.axis==="X"&&i&&(this.object.rotation.x=Math.round(this.object.rotation.x/i)*i),this.axis==="Y"&&i&&(this.object.rotation.y=Math.round(this.object.rotation.y/i)*i),this.axis==="Z"&&i&&(this.object.rotation.z=Math.round(this.object.rotation.z/i)*i)}this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(e.point).sub(this.worldPositionStart)}this.dragging=!0,Rd.mode=this.mode,this.dispatchEvent(Rd)}}pointerMove(t){const e=this.axis,n=this.mode,i=this.object;let s=this.space;if(n==="scale"?s="local":(e==="E"||e==="XYZE"||e==="XYZ")&&(s="world"),i===void 0||e===null||this.dragging===!1||t.button!==-1)return;xs.setFromCamera(t,this.camera);const a=Fl(this._plane,xs,!0);if(!!a){if(this.pointEnd.copy(a.point).sub(this.worldPositionStart),n==="translate")this._offset.copy(this.pointEnd).sub(this.pointStart),s==="local"&&e!=="XYZ"&&this._offset.applyQuaternion(this._worldQuaternionInv),e.indexOf("X")===-1&&(this._offset.x=0),e.indexOf("Y")===-1&&(this._offset.y=0),e.indexOf("Z")===-1&&(this._offset.z=0),s==="local"&&e!=="XYZ"?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),i.position.copy(this._offset).add(this._positionStart),this.translationSnap&&(s==="local"&&(i.position.applyQuaternion(ce.copy(this._quaternionStart).invert()),e.search("X")!==-1&&(i.position.x=Math.round(i.position.x/this.translationSnap)*this.translationSnap),e.search("Y")!==-1&&(i.position.y=Math.round(i.position.y/this.translationSnap)*this.translationSnap),e.search("Z")!==-1&&(i.position.z=Math.round(i.position.z/this.translationSnap)*this.translationSnap),i.position.applyQuaternion(this._quaternionStart)),s==="world"&&(i.parent&&i.position.add(Oe.setFromMatrixPosition(i.parent.matrixWorld)),e.search("X")!==-1&&(i.position.x=Math.round(i.position.x/this.translationSnap)*this.translationSnap),e.search("Y")!==-1&&(i.position.y=Math.round(i.position.y/this.translationSnap)*this.translationSnap),e.search("Z")!==-1&&(i.position.z=Math.round(i.position.z/this.translationSnap)*this.translationSnap),i.parent&&i.position.sub(Oe.setFromMatrixPosition(i.parent.matrixWorld))));else if(n==="scale"){if(e.search("XYZ")!==-1){let l=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(l*=-1),ri.set(l,l,l)}else Oe.copy(this.pointStart),ri.copy(this.pointEnd),Oe.applyQuaternion(this._worldQuaternionInv),ri.applyQuaternion(this._worldQuaternionInv),ri.divide(Oe),e.search("X")===-1&&(ri.x=1),e.search("Y")===-1&&(ri.y=1),e.search("Z")===-1&&(ri.z=1);i.scale.copy(this._scaleStart).multiply(ri),this.scaleSnap&&(e.search("X")!==-1&&(i.scale.x=Math.round(i.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),e.search("Y")!==-1&&(i.scale.y=Math.round(i.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),e.search("Z")!==-1&&(i.scale.z=Math.round(i.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(n==="rotate"){this._offset.copy(this.pointEnd).sub(this.pointStart);const l=20/this.worldPosition.distanceTo(Oe.setFromMatrixPosition(this.camera.matrixWorld));e==="E"?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1):e==="XYZE"?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(Oe.copy(this.rotationAxis).cross(this.eye))*l):(e==="X"||e==="Y"||e==="Z")&&(this.rotationAxis.copy(Pd[e]),Oe.copy(Pd[e]),s==="local"&&Oe.applyQuaternion(this.worldQuaternion),this.rotationAngle=this._offset.dot(Oe.cross(this.eye).normalize())*l),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),s==="local"&&e!=="E"&&e!=="XYZE"?(i.quaternion.copy(this._quaternionStart),i.quaternion.multiply(ce.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),i.quaternion.copy(ce.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),i.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(Ld),this.dispatchEvent(sS)}}pointerUp(t){t.button===0&&(this.dragging&&this.axis!==null&&(Id.mode=this.mode,this.dispatchEvent(Id)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.ownerDocument.removeEventListener("pointermove",this._onPointerMove),this.domElement.ownerDocument.removeEventListener("pointerup",this._onPointerUp),this.traverse(function(t){t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose()})}attach(t){return this.object=t,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}getMode(){return this.mode}setMode(t){this.mode=t}setTranslationSnap(t){this.translationSnap=t}setRotationSnap(t){this.rotationSnap=t}setScaleSnap(t){this.scaleSnap=t}setSize(t){this.size=t}setSpace(t){this.space=t}update(){console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}}Kp.prototype.isTransformControls=!0;function rS(r){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:r.button};{const t=r.changedTouches?r.changedTouches[0]:r,e=this.domElement.getBoundingClientRect();return{x:(t.clientX-e.left)/e.width*2-1,y:-(t.clientY-e.top)/e.height*2+1,button:r.button}}}function oS(r){if(!!this.enabled)switch(r.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(r));break}}function aS(r){!this.enabled||(this.domElement.style.touchAction="none",this.domElement.ownerDocument.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(r)),this.pointerDown(this._getPointer(r)))}function lS(r){!this.enabled||this.pointerMove(this._getPointer(r))}function cS(r){!this.enabled||(this.domElement.style.touchAction="",this.domElement.ownerDocument.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(r)))}function Fl(r,t,e){const n=t.intersectObject(r,!0);for(let i=0;i<n.length;i++)if(n[i].object.visible||e)return n[i];return!1}const Zo=new Fi,Qt=new C(0,1,0),Dd=new C(0,0,0),Nd=new Et,Ko=new se,ea=new se,pn=new C,Fd=new Et,ws=new C(1,0,0),oi=new C(0,1,0),Ms=new C(0,0,1),$o=new C,xr=new C,yr=new C;class $p extends Wt{constructor(){super(),this.type="TransformControlsGizmo";const t=new sn({depthTest:!1,depthWrite:!1,transparent:!0,side:on,fog:!1,toneMapped:!1}),e=new Bi({depthTest:!1,depthWrite:!1,transparent:!0,linewidth:1,fog:!1,toneMapped:!1}),n=t.clone();n.opacity=.15;const i=t.clone();i.opacity=.33;const s=t.clone();s.color.set(16711680);const a=t.clone();a.color.set(65280);const l=t.clone();l.color.set(255);const u=t.clone();u.opacity=.25;const h=u.clone();h.color.set(16776960);const p=u.clone();p.color.set(65535);const f=u.clone();f.color.set(16711935),t.clone().color.set(16776960);const v=e.clone();v.color.set(16711680);const x=e.clone();x.color.set(65280);const b=e.clone();b.color.set(255);const w=e.clone();w.color.set(65535);const _=e.clone();_.color.set(16711935);const y=e.clone();y.color.set(16776960);const M=e.clone();M.color.set(7895160);const T=y.clone();T.opacity=.25;const A=new en(0,.05,.2,12,1,!1),E=new fn(.125,.125,.125),P=new Yt;P.setAttribute("position",new qt([0,0,0,1,0,0],3));function I(ut,rt){const Tt=new Yt,ct=[];for(let ft=0;ft<=64*rt;++ft)ct.push(0,Math.cos(ft/32*Math.PI)*ut,Math.sin(ft/32*Math.PI)*ut);return Tt.setAttribute("position",new qt(ct,3)),Tt}function N(){const ut=new Yt;return ut.setAttribute("position",new qt([0,0,0,1,1,1],3)),ut}const z={X:[[new wt(A,s),[1,0,0],[0,0,-Math.PI/2],null,"fwd"],[new wt(A,s),[1,0,0],[0,0,Math.PI/2],null,"bwd"],[new Xt(P,v)]],Y:[[new wt(A,a),[0,1,0],null,null,"fwd"],[new wt(A,a),[0,1,0],[Math.PI,0,0],null,"bwd"],[new Xt(P,x),null,[0,0,Math.PI/2]]],Z:[[new wt(A,l),[0,0,1],[Math.PI/2,0,0],null,"fwd"],[new wt(A,l),[0,0,1],[-Math.PI/2,0,0],null,"bwd"],[new Xt(P,b),null,[0,-Math.PI/2,0]]],XYZ:[[new wt(new Si(.1,0),u.clone()),[0,0,0],[0,0,0]]],XY:[[new wt(new mn(.295,.295),h.clone()),[.15,.15,0]],[new Xt(P,y),[.18,.3,0],null,[.125,1,1]],[new Xt(P,y),[.3,.18,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new wt(new mn(.295,.295),p.clone()),[0,.15,.15],[0,Math.PI/2,0]],[new Xt(P,w),[0,.18,.3],[0,0,Math.PI/2],[.125,1,1]],[new Xt(P,w),[0,.3,.18],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new wt(new mn(.295,.295),f.clone()),[.15,0,.15],[-Math.PI/2,0,0]],[new Xt(P,_),[.18,0,.3],null,[.125,1,1]],[new Xt(P,_),[.3,0,.18],[0,-Math.PI/2,0],[.125,1,1]]]},W={X:[[new wt(new en(.2,0,1,4,1,!1),n),[.6,0,0],[0,0,-Math.PI/2]]],Y:[[new wt(new en(.2,0,1,4,1,!1),n),[0,.6,0]]],Z:[[new wt(new en(.2,0,1,4,1,!1),n),[0,0,.6],[Math.PI/2,0,0]]],XYZ:[[new wt(new Si(.2,0),n)]],XY:[[new wt(new mn(.4,.4),n),[.2,.2,0]]],YZ:[[new wt(new mn(.4,.4),n),[0,.2,.2],[0,Math.PI/2,0]]],XZ:[[new wt(new mn(.4,.4),n),[.2,0,.2],[-Math.PI/2,0,0]]]},H={START:[[new wt(new Si(.01,2),i),null,null,null,"helper"]],END:[[new wt(new Si(.01,2),i),null,null,null,"helper"]],DELTA:[[new Xt(N(),i),null,null,null,"helper"]],X:[[new Xt(P,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new Xt(P,i.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new Xt(P,i.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},D={X:[[new Xt(I(1,.5),v)],[new wt(new Si(.04,0),s),[0,0,.99],null,[1,3,1]]],Y:[[new Xt(I(1,.5),x),null,[0,0,-Math.PI/2]],[new wt(new Si(.04,0),a),[0,0,.99],null,[3,1,1]]],Z:[[new Xt(I(1,.5),b),null,[0,Math.PI/2,0]],[new wt(new Si(.04,0),l),[.99,0,0],null,[1,3,1]]],E:[[new Xt(I(1.25,1),T),null,[0,Math.PI/2,0]],[new wt(new en(.03,0,.15,4,1,!1),T),[1.17,0,0],[0,0,-Math.PI/2],[1,1,.001]],[new wt(new en(.03,0,.15,4,1,!1),T),[-1.17,0,0],[0,0,Math.PI/2],[1,1,.001]],[new wt(new en(.03,0,.15,4,1,!1),T),[0,-1.17,0],[Math.PI,0,0],[1,1,.001]],[new wt(new en(.03,0,.15,4,1,!1),T),[0,1.17,0],[0,0,0],[1,1,.001]]],XYZE:[[new Xt(I(1,1),M),null,[0,Math.PI/2,0]]]},V={AXIS:[[new Xt(P,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},G={X:[[new wt(new ko(1,.1,4,24),n),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new wt(new ko(1,.1,4,24),n),[0,0,0],[Math.PI/2,0,0]]],Z:[[new wt(new ko(1,.1,4,24),n),[0,0,0],[0,0,-Math.PI/2]]],E:[[new wt(new ko(1.25,.1,2,24),n)]],XYZE:[[new wt(new Jw(.7,10,8),n)]]},B={X:[[new wt(E,s),[.8,0,0],[0,0,-Math.PI/2]],[new Xt(P,v),null,null,[.8,1,1]]],Y:[[new wt(E,a),[0,.8,0]],[new Xt(P,x),null,[0,0,Math.PI/2],[.8,1,1]]],Z:[[new wt(E,l),[0,0,.8],[Math.PI/2,0,0]],[new Xt(P,b),null,[0,-Math.PI/2,0],[.8,1,1]]],XY:[[new wt(E,h),[.85,.85,0],null,[2,2,.2]],[new Xt(P,y),[.855,.98,0],null,[.125,1,1]],[new Xt(P,y),[.98,.855,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new wt(E,p),[0,.85,.85],null,[.2,2,2]],[new Xt(P,w),[0,.855,.98],[0,0,Math.PI/2],[.125,1,1]],[new Xt(P,w),[0,.98,.855],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new wt(E,f),[.85,0,.85],null,[2,.2,2]],[new Xt(P,_),[.855,0,.98],null,[.125,1,1]],[new Xt(P,_),[.98,0,.855],[0,-Math.PI/2,0],[.125,1,1]]],XYZX:[[new wt(new fn(.125,.125,.125),u.clone()),[1.1,0,0]]],XYZY:[[new wt(new fn(.125,.125,.125),u.clone()),[0,1.1,0]]],XYZZ:[[new wt(new fn(.125,.125,.125),u.clone()),[0,0,1.1]]]},j={X:[[new wt(new en(.2,0,.8,4,1,!1),n),[.5,0,0],[0,0,-Math.PI/2]]],Y:[[new wt(new en(.2,0,.8,4,1,!1),n),[0,.5,0]]],Z:[[new wt(new en(.2,0,.8,4,1,!1),n),[0,0,.5],[Math.PI/2,0,0]]],XY:[[new wt(E,n),[.85,.85,0],null,[3,3,.2]]],YZ:[[new wt(E,n),[0,.85,.85],null,[.2,3,3]]],XZ:[[new wt(E,n),[.85,0,.85],null,[3,.2,3]]],XYZX:[[new wt(new fn(.2,.2,.2),n),[1.1,0,0]]],XYZY:[[new wt(new fn(.2,.2,.2),n),[0,1.1,0]]],XYZZ:[[new wt(new fn(.2,.2,.2),n),[0,0,1.1]]]},ot={X:[[new Xt(P,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new Xt(P,i.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new Xt(P,i.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function Q(ut){const rt=new Wt;for(const Tt in ut)for(let ct=ut[Tt].length;ct--;){const ft=ut[Tt][ct][0].clone(),Ft=ut[Tt][ct][1],K=ut[Tt][ct][2],Ot=ut[Tt][ct][3],Dt=ut[Tt][ct][4];ft.name=Tt,ft.tag=Dt,Ft&&ft.position.set(Ft[0],Ft[1],Ft[2]),K&&ft.rotation.set(K[0],K[1],K[2]),Ot&&ft.scale.set(Ot[0],Ot[1],Ot[2]),ft.updateMatrix();const Mt=ft.geometry.clone();Mt.applyMatrix4(ft.matrix),ft.geometry=Mt,ft.renderOrder=1/0,ft.position.set(0,0,0),ft.rotation.set(0,0,0),ft.scale.set(1,1,1),rt.add(ft)}return rt}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=Q(z)),this.add(this.gizmo.rotate=Q(D)),this.add(this.gizmo.scale=Q(B)),this.add(this.picker.translate=Q(W)),this.add(this.picker.rotate=Q(G)),this.add(this.picker.scale=Q(j)),this.add(this.helper.translate=Q(H)),this.add(this.helper.rotate=Q(V)),this.add(this.helper.scale=Q(ot)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(t){const n=(this.mode==="scale"?"local":this.space)==="local"?this.worldQuaternion:ea;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let i=[];i=i.concat(this.picker[this.mode].children),i=i.concat(this.gizmo[this.mode].children),i=i.concat(this.helper[this.mode].children);for(let s=0;s<i.length;s++){const a=i[s];a.visible=!0,a.rotation.set(0,0,0),a.position.copy(this.worldPosition);let l;if(this.camera.isOrthographicCamera?l=(this.camera.top-this.camera.bottom)/this.camera.zoom:l=this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),a.scale.set(1,1,1).multiplyScalar(l*this.size/7),a.tag==="helper"){a.visible=!1,a.name==="AXIS"?(a.position.copy(this.worldPositionStart),a.visible=!!this.axis,this.axis==="X"&&(ce.setFromEuler(Zo.set(0,0,0)),a.quaternion.copy(n).multiply(ce),Math.abs(Qt.copy(ws).applyQuaternion(n).dot(this.eye))>.9&&(a.visible=!1)),this.axis==="Y"&&(ce.setFromEuler(Zo.set(0,0,Math.PI/2)),a.quaternion.copy(n).multiply(ce),Math.abs(Qt.copy(oi).applyQuaternion(n).dot(this.eye))>.9&&(a.visible=!1)),this.axis==="Z"&&(ce.setFromEuler(Zo.set(0,Math.PI/2,0)),a.quaternion.copy(n).multiply(ce),Math.abs(Qt.copy(Ms).applyQuaternion(n).dot(this.eye))>.9&&(a.visible=!1)),this.axis==="XYZE"&&(ce.setFromEuler(Zo.set(0,Math.PI/2,0)),Qt.copy(this.rotationAxis),a.quaternion.setFromRotationMatrix(Nd.lookAt(Dd,Qt,oi)),a.quaternion.multiply(ce),a.visible=this.dragging),this.axis==="E"&&(a.visible=!1)):a.name==="START"?(a.position.copy(this.worldPositionStart),a.visible=this.dragging):a.name==="END"?(a.position.copy(this.worldPosition),a.visible=this.dragging):a.name==="DELTA"?(a.position.copy(this.worldPositionStart),a.quaternion.copy(this.worldQuaternionStart),Oe.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),Oe.applyQuaternion(this.worldQuaternionStart.clone().invert()),a.scale.copy(Oe),a.visible=this.dragging):(a.quaternion.copy(n),this.dragging?a.position.copy(this.worldPositionStart):a.position.copy(this.worldPosition),this.axis&&(a.visible=this.axis.search(a.name)!==-1));continue}a.quaternion.copy(n),this.mode==="translate"||this.mode==="scale"?((a.name==="X"||a.name==="XYZX")&&Math.abs(Qt.copy(ws).applyQuaternion(n).dot(this.eye))>.99&&(a.scale.set(1e-10,1e-10,1e-10),a.visible=!1),(a.name==="Y"||a.name==="XYZY")&&Math.abs(Qt.copy(oi).applyQuaternion(n).dot(this.eye))>.99&&(a.scale.set(1e-10,1e-10,1e-10),a.visible=!1),(a.name==="Z"||a.name==="XYZZ")&&Math.abs(Qt.copy(Ms).applyQuaternion(n).dot(this.eye))>.99&&(a.scale.set(1e-10,1e-10,1e-10),a.visible=!1),a.name==="XY"&&Math.abs(Qt.copy(Ms).applyQuaternion(n).dot(this.eye))<.2&&(a.scale.set(1e-10,1e-10,1e-10),a.visible=!1),a.name==="YZ"&&Math.abs(Qt.copy(ws).applyQuaternion(n).dot(this.eye))<.2&&(a.scale.set(1e-10,1e-10,1e-10),a.visible=!1),a.name==="XZ"&&Math.abs(Qt.copy(oi).applyQuaternion(n).dot(this.eye))<.2&&(a.scale.set(1e-10,1e-10,1e-10),a.visible=!1),a.name.search("X")!==-1&&(Qt.copy(ws).applyQuaternion(n).dot(this.eye)<0?a.tag==="fwd"?a.visible=!1:a.scale.x*=-1:a.tag==="bwd"&&(a.visible=!1)),a.name.search("Y")!==-1&&(Qt.copy(oi).applyQuaternion(n).dot(this.eye)<0?a.tag==="fwd"?a.visible=!1:a.scale.y*=-1:a.tag==="bwd"&&(a.visible=!1)),a.name.search("Z")!==-1&&(Qt.copy(Ms).applyQuaternion(n).dot(this.eye)<0?a.tag==="fwd"?a.visible=!1:a.scale.z*=-1:a.tag==="bwd"&&(a.visible=!1))):this.mode==="rotate"&&(Ko.copy(n),Qt.copy(this.eye).applyQuaternion(ce.copy(n).invert()),a.name.search("E")!==-1&&a.quaternion.setFromRotationMatrix(Nd.lookAt(this.eye,Dd,oi)),a.name==="X"&&(ce.setFromAxisAngle(ws,Math.atan2(-Qt.y,Qt.z)),ce.multiplyQuaternions(Ko,ce),a.quaternion.copy(ce)),a.name==="Y"&&(ce.setFromAxisAngle(oi,Math.atan2(Qt.x,Qt.z)),ce.multiplyQuaternions(Ko,ce),a.quaternion.copy(ce)),a.name==="Z"&&(ce.setFromAxisAngle(Ms,Math.atan2(Qt.y,Qt.x)),ce.multiplyQuaternions(Ko,ce),a.quaternion.copy(ce))),a.visible=a.visible&&(a.name.indexOf("X")===-1||this.showX),a.visible=a.visible&&(a.name.indexOf("Y")===-1||this.showY),a.visible=a.visible&&(a.name.indexOf("Z")===-1||this.showZ),a.visible=a.visible&&(a.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),a.material._opacity=a.material._opacity||a.material.opacity,a.material._color=a.material._color||a.material.color.clone(),a.material.color.copy(a.material._color),a.material.opacity=a.material._opacity,this.enabled?this.axis&&(a.name===this.axis?(a.material.opacity=1,a.material.color.lerp(new yt(1,1,1),.5)):this.axis.split("").some(function(u){return a.name===u})?(a.material.opacity=1,a.material.color.lerp(new yt(1,1,1),.5)):(a.material.opacity*=.25,a.material.color.lerp(new yt(1,1,1),.5))):(a.material.opacity*=.5,a.material.color.lerp(new yt(1,1,1),.5))}super.updateMatrixWorld(t)}}$p.prototype.isTransformControlsGizmo=!0;class Jp extends wt{constructor(){super(new mn(1e5,1e5,2,2),new sn({visible:!1,wireframe:!0,side:on,transparent:!0,opacity:.1,toneMapped:!1})),this.type="TransformControlsPlane"}updateMatrixWorld(t){let e=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(e="local"),$o.copy(ws).applyQuaternion(e==="local"?this.worldQuaternion:ea),xr.copy(oi).applyQuaternion(e==="local"?this.worldQuaternion:ea),yr.copy(Ms).applyQuaternion(e==="local"?this.worldQuaternion:ea),Qt.copy(xr),this.mode){case"translate":case"scale":switch(this.axis){case"X":Qt.copy(this.eye).cross($o),pn.copy($o).cross(Qt);break;case"Y":Qt.copy(this.eye).cross(xr),pn.copy(xr).cross(Qt);break;case"Z":Qt.copy(this.eye).cross(yr),pn.copy(yr).cross(Qt);break;case"XY":pn.copy(yr);break;case"YZ":pn.copy($o);break;case"XZ":Qt.copy(yr),pn.copy(xr);break;case"XYZ":case"E":pn.set(0,0,0);break}break;case"rotate":default:pn.set(0,0,0)}pn.length()===0?this.quaternion.copy(this.cameraQuaternion):(Fd.lookAt(Oe.set(0,0,0),pn,Qt),this.quaternion.setFromRotationMatrix(Fd)),super.updateMatrixWorld(t)}}Jp.prototype.isTransformControlsPlane=!0;var uS=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{},nc={exports:{}};/*! Tweakpane 3.1.0 (c) 2016 cocopon, licensed under the MIT license. */(function(r,t){(function(e,n){n(t)})(uS,function(e){class n{constructor(o){const[c,g]=o.split("-"),S=c.split(".");this.major=parseInt(S[0],10),this.minor=parseInt(S[1],10),this.patch=parseInt(S[2],10),this.prerelease=g!=null?g:null}toString(){const o=[this.major,this.minor,this.patch].join(".");return this.prerelease!==null?[o,this.prerelease].join("-"):o}}class i{constructor(o){this.controller_=o}get element(){return this.controller_.view.element}get disabled(){return this.controller_.viewProps.get("disabled")}set disabled(o){this.controller_.viewProps.set("disabled",o)}get hidden(){return this.controller_.viewProps.get("hidden")}set hidden(o){this.controller_.viewProps.set("hidden",o)}dispose(){this.controller_.viewProps.set("disposed",!0)}}class s{constructor(o){this.target=o}}class a extends s{constructor(o,c,g,S){super(o),this.value=c,this.presetKey=g,this.last=S!=null?S:!0}}class l extends s{constructor(o,c,g){super(o),this.value=c,this.presetKey=g}}class u extends s{constructor(o,c){super(o),this.expanded=c}}class h extends s{constructor(o,c){super(o),this.index=c}}function p(d){return d}function f(d){return d==null}function m(d,o){if(d.length!==o.length)return!1;for(let c=0;c<d.length;c++)if(d[c]!==o[c])return!1;return!0}const v={alreadydisposed:()=>"View has been already disposed",invalidparams:d=>`Invalid parameters for '${d.name}'`,nomatchingcontroller:d=>`No matching controller for '${d.key}'`,nomatchingview:d=>`No matching view for '${JSON.stringify(d.params)}'`,notbindable:()=>"Value is not bindable",propertynotfound:d=>`Property '${d.name}' not found`,shouldneverhappen:()=>"This error should never happen"};class x{constructor(o){var c;this.message=(c=v[o.type](o.context))!==null&&c!==void 0?c:"Unexpected error",this.name=this.constructor.name,this.stack=new Error(this.message).stack,this.type=o.type}static alreadyDisposed(){return new x({type:"alreadydisposed"})}static notBindable(){return new x({type:"notbindable"})}static propertyNotFound(o){return new x({type:"propertynotfound",context:{name:o}})}static shouldNeverHappen(){return new x({type:"shouldneverhappen"})}}class b{constructor(o,c,g){this.obj_=o,this.key_=c,this.presetKey_=g!=null?g:c}static isBindable(o){return!(o===null||typeof o!="object")}get key(){return this.key_}get presetKey(){return this.presetKey_}read(){return this.obj_[this.key_]}write(o){this.obj_[this.key_]=o}writeProperty(o,c){const g=this.read();if(!b.isBindable(g))throw x.notBindable();if(!(o in g))throw x.propertyNotFound(o);g[o]=c}}class w extends i{get label(){return this.controller_.props.get("label")}set label(o){this.controller_.props.set("label",o)}get title(){var o;return(o=this.controller_.valueController.props.get("title"))!==null&&o!==void 0?o:""}set title(o){this.controller_.valueController.props.set("title",o)}on(o,c){const g=c.bind(this);return this.controller_.valueController.emitter.on(o,()=>{g(new s(this))}),this}}class _{constructor(){this.observers_={}}on(o,c){let g=this.observers_[o];return g||(g=this.observers_[o]=[]),g.push({handler:c}),this}off(o,c){const g=this.observers_[o];return g&&(this.observers_[o]=g.filter(S=>S.handler!==c)),this}emit(o,c){const g=this.observers_[o];!g||g.forEach(S=>{S.handler(c)})}}const y="tp";function M(d){return(c,g)=>[y,"-",d,"v",c?`_${c}`:"",g?`-${g}`:""].join("")}function T(d,o){return c=>o(d(c))}function A(d){return d.rawValue}function E(d,o){d.emitter.on("change",T(A,o)),o(d.rawValue)}function P(d,o,c){E(d.value(o),c)}function I(d,o,c){c?d.classList.add(o):d.classList.remove(o)}function N(d,o){return c=>{I(d,o,c)}}function z(d,o){E(d,c=>{o.textContent=c!=null?c:""})}const W=M("btn");class H{constructor(o,c){this.element=o.createElement("div"),this.element.classList.add(W()),c.viewProps.bindClassModifiers(this.element);const g=o.createElement("button");g.classList.add(W("b")),c.viewProps.bindDisabled(g),this.element.appendChild(g),this.buttonElement=g;const S=o.createElement("div");S.classList.add(W("t")),z(c.props.value("title"),S),this.buttonElement.appendChild(S)}}class D{constructor(o,c){this.emitter=new _,this.onClick_=this.onClick_.bind(this),this.props=c.props,this.viewProps=c.viewProps,this.view=new H(o,{props:this.props,viewProps:this.viewProps}),this.view.buttonElement.addEventListener("click",this.onClick_)}onClick_(){this.emitter.emit("click",{sender:this})}}class V{constructor(o,c){var g;this.constraint_=c==null?void 0:c.constraint,this.equals_=(g=c==null?void 0:c.equals)!==null&&g!==void 0?g:(S,k)=>S===k,this.emitter=new _,this.rawValue_=o}get constraint(){return this.constraint_}get rawValue(){return this.rawValue_}set rawValue(o){this.setRawValue(o,{forceEmit:!1,last:!0})}setRawValue(o,c){const g=c!=null?c:{forceEmit:!1,last:!0},S=this.constraint_?this.constraint_.constrain(o):o;!!this.equals_(this.rawValue_,S)&&!g.forceEmit||(this.emitter.emit("beforechange",{sender:this}),this.rawValue_=S,this.emitter.emit("change",{options:g,rawValue:S,sender:this}))}}class G{constructor(o){this.emitter=new _,this.value_=o}get rawValue(){return this.value_}set rawValue(o){this.setRawValue(o,{forceEmit:!1,last:!0})}setRawValue(o,c){const g=c!=null?c:{forceEmit:!1,last:!0};this.value_===o&&!g.forceEmit||(this.emitter.emit("beforechange",{sender:this}),this.value_=o,this.emitter.emit("change",{options:g,rawValue:this.value_,sender:this}))}}function B(d,o){const c=o==null?void 0:o.constraint,g=o==null?void 0:o.equals;return!c&&!g?new G(d):new V(d,o)}class j{constructor(o){this.emitter=new _,this.valMap_=o;for(const c in this.valMap_)this.valMap_[c].emitter.on("change",()=>{this.emitter.emit("change",{key:c,sender:this})})}static createCore(o){return Object.keys(o).reduce((g,S)=>Object.assign(g,{[S]:B(o[S])}),{})}static fromObject(o){const c=this.createCore(o);return new j(c)}get(o){return this.valMap_[o].rawValue}set(o,c){this.valMap_[o].rawValue=c}value(o){return this.valMap_[o]}}function ot(d,o){const g=Object.keys(o).reduce((S,k)=>{if(S===void 0)return;const X=o[k],st=X(d[k]);return st.succeeded?Object.assign(Object.assign({},S),{[k]:st.value}):void 0},{});return g}function Q(d,o){return d.reduce((c,g)=>{if(c===void 0)return;const S=o(g);if(!(!S.succeeded||S.value===void 0))return[...c,S.value]},[])}function ut(d){return d===null?!1:typeof d=="object"}function rt(d){return o=>c=>{if(!o&&c===void 0)return{succeeded:!1,value:void 0};if(o&&c===void 0)return{succeeded:!0,value:void 0};const g=d(c);return g!==void 0?{succeeded:!0,value:g}:{succeeded:!1,value:void 0}}}function Tt(d){return{custom:o=>rt(o)(d),boolean:rt(o=>typeof o=="boolean"?o:void 0)(d),number:rt(o=>typeof o=="number"?o:void 0)(d),string:rt(o=>typeof o=="string"?o:void 0)(d),function:rt(o=>typeof o=="function"?o:void 0)(d),constant:o=>rt(c=>c===o?o:void 0)(d),raw:rt(o=>o)(d),object:o=>rt(c=>{if(!!ut(c))return ot(c,o)})(d),array:o=>rt(c=>{if(!!Array.isArray(c))return Q(c,o)})(d)}}const ct={optional:Tt(!0),required:Tt(!1)};function ft(d,o){const c=ct.required.object(o)(d);return c.succeeded?c.value:void 0}function Ft(d){return d&&d.parentElement&&d.parentElement.removeChild(d),null}function K(){return["veryfirst","first","last","verylast"]}const Ot=M(""),Dt={veryfirst:"vfst",first:"fst",last:"lst",verylast:"vlst"};class Mt{constructor(o){this.parent_=null,this.blade=o.blade,this.view=o.view,this.viewProps=o.viewProps;const c=this.view.element;this.blade.value("positions").emitter.on("change",()=>{K().forEach(g=>{c.classList.remove(Ot(void 0,Dt[g]))}),this.blade.get("positions").forEach(g=>{c.classList.add(Ot(void 0,Dt[g]))})}),this.viewProps.handleDispose(()=>{Ft(c)})}get parent(){return this.parent_}}const bt="http://www.w3.org/2000/svg";function Nt(d){d.offsetHeight}function tt(d,o){const c=d.style.transition;d.style.transition="none",o(),d.style.transition=c}function et(d){return d.ontouchstart!==void 0}function lt(){return new Function("return this")()}function At(){return lt().document}function _t(d){const o=d.ownerDocument.defaultView;return o&&"document"in o?d.getContext("2d"):null}const F={check:'<path d="M2 8l4 4l8 -8"/>',dropdown:'<path d="M5 7h6l-3 3 z"/>',p2dpad:'<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'};function R(d,o){const c=d.createElementNS(bt,"svg");return c.innerHTML=F[o],c}function J(d,o,c){d.insertBefore(o,d.children[c])}function it(d){d.parentElement&&d.parentElement.removeChild(d)}function gt(d){for(;d.children.length>0;)d.removeChild(d.children[0])}function xt(d){for(;d.childNodes.length>0;)d.removeChild(d.childNodes[0])}function Pt(d){return d.relatedTarget?d.relatedTarget:"explicitOriginalTarget"in d?d.explicitOriginalTarget:null}const O=M("lbl");function mt(d,o){const c=d.createDocumentFragment();return o.split(`
`).map(S=>d.createTextNode(S)).forEach((S,k)=>{k>0&&c.appendChild(d.createElement("br")),c.appendChild(S)}),c}class ht{constructor(o,c){this.element=o.createElement("div"),this.element.classList.add(O()),c.viewProps.bindClassModifiers(this.element);const g=o.createElement("div");g.classList.add(O("l")),P(c.props,"label",k=>{f(k)?this.element.classList.add(O(void 0,"nol")):(this.element.classList.remove(O(void 0,"nol")),xt(g),g.appendChild(mt(o,k)))}),this.element.appendChild(g),this.labelElement=g;const S=o.createElement("div");S.classList.add(O("v")),this.element.appendChild(S),this.valueElement=S}}class U extends Mt{constructor(o,c){const g=c.valueController.viewProps;super(Object.assign(Object.assign({},c),{view:new ht(o,{props:c.props,viewProps:g}),viewProps:g})),this.props=c.props,this.valueController=c.valueController,this.view.valueElement.appendChild(this.valueController.view.element)}}const at={id:"button",type:"blade",accept(d){const o=ct,c=ft(d,{title:o.required.string,view:o.required.constant("button"),label:o.optional.string});return c?{params:c}:null},controller(d){return new U(d.document,{blade:d.blade,props:j.fromObject({label:d.params.label}),valueController:new D(d.document,{props:j.fromObject({title:d.params.title}),viewProps:d.viewProps})})},api(d){return!(d.controller instanceof U)||!(d.controller.valueController instanceof D)?null:new w(d.controller)}};class $ extends Mt{constructor(o){super(o),this.value=o.value}}function St(){return new j({positions:B([],{equals:m})})}class dt extends j{constructor(o){super(o)}static create(o){const c={completed:!0,expanded:o,expandedHeight:null,shouldFixHeight:!1,temporaryExpanded:null},g=j.createCore(c);return new dt(g)}get styleExpanded(){var o;return(o=this.get("temporaryExpanded"))!==null&&o!==void 0?o:this.get("expanded")}get styleHeight(){if(!this.styleExpanded)return"0";const o=this.get("expandedHeight");return this.get("shouldFixHeight")&&!f(o)?`${o}px`:"auto"}bindExpandedClass(o,c){const g=()=>{this.styleExpanded?o.classList.add(c):o.classList.remove(c)};P(this,"expanded",g),P(this,"temporaryExpanded",g)}cleanUpTransition(){this.set("shouldFixHeight",!1),this.set("expandedHeight",null),this.set("completed",!0)}}function Ht(d,o){let c=0;return tt(o,()=>{d.set("expandedHeight",null),d.set("temporaryExpanded",!0),Nt(o),c=o.clientHeight,d.set("temporaryExpanded",null),Nt(o)}),c}function ee(d,o){o.style.height=d.styleHeight}function ge(d,o){d.value("expanded").emitter.on("beforechange",()=>{d.set("completed",!1),f(d.get("expandedHeight"))&&d.set("expandedHeight",Ht(d,o)),d.set("shouldFixHeight",!0),Nt(o)}),d.emitter.on("change",()=>{ee(d,o)}),ee(d,o),o.addEventListener("transitionend",c=>{c.propertyName==="height"&&d.cleanUpTransition()})}class Ke extends i{constructor(o,c){super(o),this.rackApi_=c}}function he(d,o){return d.addBlade(Object.assign(Object.assign({},o),{view:"button"}))}function $e(d,o){return d.addBlade(Object.assign(Object.assign({},o),{view:"folder"}))}function ze(d,o){const c=o!=null?o:{};return d.addBlade(Object.assign(Object.assign({},c),{view:"separator"}))}function xa(d,o){return d.addBlade(Object.assign(Object.assign({},o),{view:"tab"}))}class Oi{constructor(o){this.emitter=new _,this.items_=[],this.cache_=new Set,this.onSubListAdd_=this.onSubListAdd_.bind(this),this.onSubListRemove_=this.onSubListRemove_.bind(this),this.extract_=o}get items(){return this.items_}allItems(){return Array.from(this.cache_)}find(o){for(const c of this.allItems())if(o(c))return c;return null}includes(o){return this.cache_.has(o)}add(o,c){if(this.includes(o))throw x.shouldNeverHappen();const g=c!==void 0?c:this.items_.length;this.items_.splice(g,0,o),this.cache_.add(o);const S=this.extract_(o);S&&(S.emitter.on("add",this.onSubListAdd_),S.emitter.on("remove",this.onSubListRemove_),S.allItems().forEach(k=>{this.cache_.add(k)})),this.emitter.emit("add",{index:g,item:o,root:this,target:this})}remove(o){const c=this.items_.indexOf(o);if(c<0)return;this.items_.splice(c,1),this.cache_.delete(o);const g=this.extract_(o);g&&(g.emitter.off("add",this.onSubListAdd_),g.emitter.off("remove",this.onSubListRemove_)),this.emitter.emit("remove",{index:c,item:o,root:this,target:this})}onSubListAdd_(o){this.cache_.add(o.item),this.emitter.emit("add",{index:o.index,item:o.item,root:this,target:o.target})}onSubListRemove_(o){this.cache_.delete(o.item),this.emitter.emit("remove",{index:o.index,item:o.item,root:this,target:o.target})}}class Vi extends i{constructor(o){super(o),this.onBindingChange_=this.onBindingChange_.bind(this),this.emitter_=new _,this.controller_.binding.emitter.on("change",this.onBindingChange_)}get label(){return this.controller_.props.get("label")}set label(o){this.controller_.props.set("label",o)}on(o,c){const g=c.bind(this);return this.emitter_.on(o,S=>{g(S.event)}),this}refresh(){this.controller_.binding.read()}onBindingChange_(o){const c=o.sender.target.read();this.emitter_.emit("change",{event:new a(this,c,this.controller_.binding.target.presetKey,o.options.last)})}}class be extends U{constructor(o,c){super(o,c),this.binding=c.binding}}class zi extends i{constructor(o){super(o),this.onBindingUpdate_=this.onBindingUpdate_.bind(this),this.emitter_=new _,this.controller_.binding.emitter.on("update",this.onBindingUpdate_)}get label(){return this.controller_.props.get("label")}set label(o){this.controller_.props.set("label",o)}on(o,c){const g=c.bind(this);return this.emitter_.on(o,S=>{g(S.event)}),this}refresh(){this.controller_.binding.read()}onBindingUpdate_(o){const c=o.sender.target.read();this.emitter_.emit("update",{event:new l(this,c,this.controller_.binding.target.presetKey)})}}class an extends U{constructor(o,c){super(o,c),this.binding=c.binding,this.viewProps.bindDisabled(this.binding.ticker),this.viewProps.handleDispose(()=>{this.binding.dispose()})}}function Ui(d){return d instanceof gi?d.apiSet_:d instanceof Ke?d.rackApi_.apiSet_:null}function Hn(d,o){const c=d.find(g=>g.controller_===o);if(!c)throw x.shouldNeverHappen();return c}function Hi(d,o,c){if(!b.isBindable(d))throw x.notBindable();return new b(d,o,c)}class gi extends i{constructor(o,c){super(o),this.onRackAdd_=this.onRackAdd_.bind(this),this.onRackRemove_=this.onRackRemove_.bind(this),this.onRackInputChange_=this.onRackInputChange_.bind(this),this.onRackMonitorUpdate_=this.onRackMonitorUpdate_.bind(this),this.emitter_=new _,this.apiSet_=new Oi(Ui),this.pool_=c;const g=this.controller_.rack;g.emitter.on("add",this.onRackAdd_),g.emitter.on("remove",this.onRackRemove_),g.emitter.on("inputchange",this.onRackInputChange_),g.emitter.on("monitorupdate",this.onRackMonitorUpdate_),g.children.forEach(S=>{this.setUpApi_(S)})}get children(){return this.controller_.rack.children.map(o=>Hn(this.apiSet_,o))}addInput(o,c,g){const S=g!=null?g:{},k=this.controller_.view.element.ownerDocument,X=this.pool_.createInput(k,Hi(o,c,S.presetKey),S),st=new Vi(X);return this.add(st,S.index)}addMonitor(o,c,g){const S=g!=null?g:{},k=this.controller_.view.element.ownerDocument,X=this.pool_.createMonitor(k,Hi(o,c),S),st=new zi(X);return this.add(st,S.index)}addFolder(o){return $e(this,o)}addButton(o){return he(this,o)}addSeparator(o){return ze(this,o)}addTab(o){return xa(this,o)}add(o,c){this.controller_.rack.add(o.controller_,c);const g=this.apiSet_.find(S=>S.controller_===o.controller_);return g&&this.apiSet_.remove(g),this.apiSet_.add(o),o}remove(o){this.controller_.rack.remove(o.controller_)}addBlade(o){const c=this.controller_.view.element.ownerDocument,g=this.pool_.createBlade(c,o),S=this.pool_.createBladeApi(g);return this.add(S,o.index)}on(o,c){const g=c.bind(this);return this.emitter_.on(o,S=>{g(S.event)}),this}setUpApi_(o){this.apiSet_.find(g=>g.controller_===o)||this.apiSet_.add(this.pool_.createBladeApi(o))}onRackAdd_(o){this.setUpApi_(o.bladeController)}onRackRemove_(o){if(o.isRoot){const c=Hn(this.apiSet_,o.bladeController);this.apiSet_.remove(c)}}onRackInputChange_(o){const c=o.bladeController;if(c instanceof be){const g=Hn(this.apiSet_,c),S=c.binding;this.emitter_.emit("change",{event:new a(g,S.target.read(),S.target.presetKey,o.options.last)})}else if(c instanceof $){const g=Hn(this.apiSet_,c);this.emitter_.emit("change",{event:new a(g,c.value.rawValue,void 0,o.options.last)})}}onRackMonitorUpdate_(o){if(!(o.bladeController instanceof an))throw x.shouldNeverHappen();const c=Hn(this.apiSet_,o.bladeController),g=o.bladeController.binding;this.emitter_.emit("update",{event:new l(c,g.target.read(),g.target.presetKey)})}}class Gi extends Ke{constructor(o,c){super(o,new gi(o.rackController,c)),this.emitter_=new _,this.controller_.foldable.value("expanded").emitter.on("change",g=>{this.emitter_.emit("fold",{event:new u(this,g.sender.rawValue)})}),this.rackApi_.on("change",g=>{this.emitter_.emit("change",{event:g})}),this.rackApi_.on("update",g=>{this.emitter_.emit("update",{event:g})})}get expanded(){return this.controller_.foldable.get("expanded")}set expanded(o){this.controller_.foldable.set("expanded",o)}get title(){return this.controller_.props.get("title")}set title(o){this.controller_.props.set("title",o)}get children(){return this.rackApi_.children}addInput(o,c,g){return this.rackApi_.addInput(o,c,g)}addMonitor(o,c,g){return this.rackApi_.addMonitor(o,c,g)}addFolder(o){return this.rackApi_.addFolder(o)}addButton(o){return this.rackApi_.addButton(o)}addSeparator(o){return this.rackApi_.addSeparator(o)}addTab(o){return this.rackApi_.addTab(o)}add(o,c){return this.rackApi_.add(o,c)}remove(o){this.rackApi_.remove(o)}addBlade(o){return this.rackApi_.addBlade(o)}on(o,c){const g=c.bind(this);return this.emitter_.on(o,S=>{g(S.event)}),this}}class Ws extends Mt{constructor(o){super({blade:o.blade,view:o.view,viewProps:o.rackController.viewProps}),this.rackController=o.rackController}}class ya{constructor(o,c){const g=M(c.viewName);this.element=o.createElement("div"),this.element.classList.add(g()),c.viewProps.bindClassModifiers(this.element)}}function L(d,o){for(let c=0;c<d.length;c++){const g=d[c];if(g instanceof be&&g.binding===o)return g}return null}function Y(d,o){for(let c=0;c<d.length;c++){const g=d[c];if(g instanceof an&&g.binding===o)return g}return null}function q(d,o){for(let c=0;c<d.length;c++){const g=d[c];if(g instanceof $&&g.value===o)return g}return null}function Z(d){return d instanceof kt?d.rack:d instanceof Ws?d.rackController.rack:null}function pt(d){const o=Z(d);return o?o.bcSet_:null}class jt{constructor(o){var c;this.onBladePositionsChange_=this.onBladePositionsChange_.bind(this),this.onSetAdd_=this.onSetAdd_.bind(this),this.onSetRemove_=this.onSetRemove_.bind(this),this.onChildDispose_=this.onChildDispose_.bind(this),this.onChildPositionsChange_=this.onChildPositionsChange_.bind(this),this.onChildInputChange_=this.onChildInputChange_.bind(this),this.onChildMonitorUpdate_=this.onChildMonitorUpdate_.bind(this),this.onChildValueChange_=this.onChildValueChange_.bind(this),this.onChildViewPropsChange_=this.onChildViewPropsChange_.bind(this),this.onDescendantLayout_=this.onDescendantLayout_.bind(this),this.onDescendantInputChange_=this.onDescendantInputChange_.bind(this),this.onDescendantMonitorUpdate_=this.onDescendantMonitorUpdate_.bind(this),this.emitter=new _,this.blade_=o!=null?o:null,(c=this.blade_)===null||c===void 0||c.value("positions").emitter.on("change",this.onBladePositionsChange_),this.bcSet_=new Oi(pt),this.bcSet_.emitter.on("add",this.onSetAdd_),this.bcSet_.emitter.on("remove",this.onSetRemove_)}get children(){return this.bcSet_.items}add(o,c){o.parent&&o.parent.remove(o),o.parent_=this,this.bcSet_.add(o,c)}remove(o){o.parent_=null,this.bcSet_.remove(o)}find(o){return this.bcSet_.allItems().filter(c=>c instanceof o)}onSetAdd_(o){this.updatePositions_();const c=o.target===o.root;if(this.emitter.emit("add",{bladeController:o.item,index:o.index,isRoot:c,sender:this}),!c)return;const g=o.item;if(g.viewProps.emitter.on("change",this.onChildViewPropsChange_),g.blade.value("positions").emitter.on("change",this.onChildPositionsChange_),g.viewProps.handleDispose(this.onChildDispose_),g instanceof be)g.binding.emitter.on("change",this.onChildInputChange_);else if(g instanceof an)g.binding.emitter.on("update",this.onChildMonitorUpdate_);else if(g instanceof $)g.value.emitter.on("change",this.onChildValueChange_);else{const S=Z(g);if(S){const k=S.emitter;k.on("layout",this.onDescendantLayout_),k.on("inputchange",this.onDescendantInputChange_),k.on("monitorupdate",this.onDescendantMonitorUpdate_)}}}onSetRemove_(o){this.updatePositions_();const c=o.target===o.root;if(this.emitter.emit("remove",{bladeController:o.item,isRoot:c,sender:this}),!c)return;const g=o.item;if(g instanceof be)g.binding.emitter.off("change",this.onChildInputChange_);else if(g instanceof an)g.binding.emitter.off("update",this.onChildMonitorUpdate_);else if(g instanceof $)g.value.emitter.off("change",this.onChildValueChange_);else{const S=Z(g);if(S){const k=S.emitter;k.off("layout",this.onDescendantLayout_),k.off("inputchange",this.onDescendantInputChange_),k.off("monitorupdate",this.onDescendantMonitorUpdate_)}}}updatePositions_(){const o=this.bcSet_.items.filter(S=>!S.viewProps.get("hidden")),c=o[0],g=o[o.length-1];this.bcSet_.items.forEach(S=>{const k=[];S===c&&(k.push("first"),(!this.blade_||this.blade_.get("positions").includes("veryfirst"))&&k.push("veryfirst")),S===g&&(k.push("last"),(!this.blade_||this.blade_.get("positions").includes("verylast"))&&k.push("verylast")),S.blade.set("positions",k)})}onChildPositionsChange_(){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onChildViewPropsChange_(o){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onChildDispose_(){this.bcSet_.items.filter(c=>c.viewProps.get("disposed")).forEach(c=>{this.bcSet_.remove(c)})}onChildInputChange_(o){const c=L(this.find(be),o.sender);if(!c)throw x.shouldNeverHappen();this.emitter.emit("inputchange",{bladeController:c,options:o.options,sender:this})}onChildMonitorUpdate_(o){const c=Y(this.find(an),o.sender);if(!c)throw x.shouldNeverHappen();this.emitter.emit("monitorupdate",{bladeController:c,sender:this})}onChildValueChange_(o){const c=q(this.find($),o.sender);if(!c)throw x.shouldNeverHappen();this.emitter.emit("inputchange",{bladeController:c,options:o.options,sender:this})}onDescendantLayout_(o){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onDescendantInputChange_(o){this.emitter.emit("inputchange",{bladeController:o.bladeController,options:o.options,sender:this})}onDescendantMonitorUpdate_(o){this.emitter.emit("monitorupdate",{bladeController:o.bladeController,sender:this})}onBladePositionsChange_(){this.updatePositions_()}}class kt extends Mt{constructor(o,c){super(Object.assign(Object.assign({},c),{view:new ya(o,{viewName:"brk",viewProps:c.viewProps})})),this.onRackAdd_=this.onRackAdd_.bind(this),this.onRackRemove_=this.onRackRemove_.bind(this);const g=new jt(c.root?void 0:c.blade);g.emitter.on("add",this.onRackAdd_),g.emitter.on("remove",this.onRackRemove_),this.rack=g,this.viewProps.handleDispose(()=>{for(let S=this.rack.children.length-1;S>=0;S--)this.rack.children[S].viewProps.set("disposed",!0)})}onRackAdd_(o){!o.isRoot||J(this.view.element,o.bladeController.view.element,o.index)}onRackRemove_(o){!o.isRoot||it(o.bladeController.view.element)}}const It=M("cnt");class Vt{constructor(o,c){var g;this.className_=M((g=c.viewName)!==null&&g!==void 0?g:"fld"),this.element=o.createElement("div"),this.element.classList.add(this.className_(),It()),c.viewProps.bindClassModifiers(this.element),this.foldable_=c.foldable,this.foldable_.bindExpandedClass(this.element,this.className_(void 0,"expanded")),P(this.foldable_,"completed",N(this.element,this.className_(void 0,"cpl")));const S=o.createElement("button");S.classList.add(this.className_("b")),P(c.props,"title",Ct=>{f(Ct)?this.element.classList.add(this.className_(void 0,"not")):this.element.classList.remove(this.className_(void 0,"not"))}),c.viewProps.bindDisabled(S),this.element.appendChild(S),this.buttonElement=S;const k=o.createElement("div");k.classList.add(this.className_("t")),z(c.props.value("title"),k),this.buttonElement.appendChild(k),this.titleElement=k;const X=o.createElement("div");X.classList.add(this.className_("m")),this.buttonElement.appendChild(X);const st=c.containerElement;st.classList.add(this.className_("c")),this.element.appendChild(st),this.containerElement=st}}class Lt extends Ws{constructor(o,c){var g;const S=dt.create((g=c.expanded)!==null&&g!==void 0?g:!0),k=new kt(o,{blade:c.blade,root:c.root,viewProps:c.viewProps});super(Object.assign(Object.assign({},c),{rackController:k,view:new Vt(o,{containerElement:k.view.element,foldable:S,props:c.props,viewName:c.root?"rot":void 0,viewProps:c.viewProps})})),this.onTitleClick_=this.onTitleClick_.bind(this),this.props=c.props,this.foldable=S,ge(this.foldable,this.view.containerElement),this.rackController.rack.emitter.on("add",()=>{this.foldable.cleanUpTransition()}),this.rackController.rack.emitter.on("remove",()=>{this.foldable.cleanUpTransition()}),this.view.buttonElement.addEventListener("click",this.onTitleClick_)}get document(){return this.view.element.ownerDocument}onTitleClick_(){this.foldable.set("expanded",!this.foldable.get("expanded"))}}const Gt={id:"folder",type:"blade",accept(d){const o=ct,c=ft(d,{title:o.required.string,view:o.required.constant("folder"),expanded:o.optional.boolean});return c?{params:c}:null},controller(d){return new Lt(d.document,{blade:d.blade,expanded:d.params.expanded,props:j.fromObject({title:d.params.title}),viewProps:d.viewProps})},api(d){return d.controller instanceof Lt?new Gi(d.controller,d.pool):null}};class Rt extends ${constructor(o,c){const g=c.valueController.viewProps;super(Object.assign(Object.assign({},c),{value:c.valueController.value,view:new ht(o,{props:c.props,viewProps:g}),viewProps:g})),this.props=c.props,this.valueController=c.valueController,this.view.valueElement.appendChild(this.valueController.view.element)}}class Zt extends i{}const Ue=M("spr");class Ee{constructor(o,c){this.element=o.createElement("div"),this.element.classList.add(Ue()),c.viewProps.bindClassModifiers(this.element);const g=o.createElement("hr");g.classList.add(Ue("r")),this.element.appendChild(g)}}class ln extends Mt{constructor(o,c){super(Object.assign(Object.assign({},c),{view:new Ee(o,{viewProps:c.viewProps})}))}}const fe={id:"separator",type:"blade",accept(d){const c=ft(d,{view:ct.required.constant("separator")});return c?{params:c}:null},controller(d){return new ln(d.document,{blade:d.blade,viewProps:d.viewProps})},api(d){return d.controller instanceof ln?new Zt(d.controller):null}},Sn=M("");function _e(d,o){return N(d,Sn(void 0,o))}class cn extends j{constructor(o){super(o)}static create(o){var c,g;const S=o!=null?o:{},k={disabled:(c=S.disabled)!==null&&c!==void 0?c:!1,disposed:!1,hidden:(g=S.hidden)!==null&&g!==void 0?g:!1},X=j.createCore(k);return new cn(X)}bindClassModifiers(o){P(this,"disabled",_e(o,"disabled")),P(this,"hidden",_e(o,"hidden"))}bindDisabled(o){P(this,"disabled",c=>{o.disabled=c})}bindTabIndex(o){P(this,"disabled",c=>{o.tabIndex=c?-1:0})}handleDispose(o){this.value("disposed").emitter.on("change",c=>{c&&o()})}}const un=M("tbi");class vi{constructor(o,c){this.element=o.createElement("div"),this.element.classList.add(un()),c.viewProps.bindClassModifiers(this.element),P(c.props,"selected",k=>{k?this.element.classList.add(un(void 0,"sel")):this.element.classList.remove(un(void 0,"sel"))});const g=o.createElement("button");g.classList.add(un("b")),c.viewProps.bindDisabled(g),this.element.appendChild(g),this.buttonElement=g;const S=o.createElement("div");S.classList.add(un("t")),z(c.props.value("title"),S),this.buttonElement.appendChild(S),this.titleElement=S}}class cf{constructor(o,c){this.emitter=new _,this.onClick_=this.onClick_.bind(this),this.props=c.props,this.viewProps=c.viewProps,this.view=new vi(o,{props:c.props,viewProps:c.viewProps}),this.view.buttonElement.addEventListener("click",this.onClick_)}onClick_(){this.emitter.emit("click",{sender:this})}}class Fc{constructor(o,c){this.onItemClick_=this.onItemClick_.bind(this),this.ic_=new cf(o,{props:c.itemProps,viewProps:cn.create()}),this.ic_.emitter.on("click",this.onItemClick_),this.cc_=new kt(o,{blade:St(),viewProps:cn.create()}),this.props=c.props,P(this.props,"selected",g=>{this.itemController.props.set("selected",g),this.contentController.viewProps.set("hidden",!g)})}get itemController(){return this.ic_}get contentController(){return this.cc_}onItemClick_(){this.props.set("selected",!0)}}class kc{constructor(o,c){this.controller_=o,this.rackApi_=c}get title(){var o;return(o=this.controller_.itemController.props.get("title"))!==null&&o!==void 0?o:""}set title(o){this.controller_.itemController.props.set("title",o)}get selected(){return this.controller_.props.get("selected")}set selected(o){this.controller_.props.set("selected",o)}get children(){return this.rackApi_.children}addButton(o){return this.rackApi_.addButton(o)}addFolder(o){return this.rackApi_.addFolder(o)}addSeparator(o){return this.rackApi_.addSeparator(o)}addTab(o){return this.rackApi_.addTab(o)}add(o,c){this.rackApi_.add(o,c)}remove(o){this.rackApi_.remove(o)}addInput(o,c,g){return this.rackApi_.addInput(o,c,g)}addMonitor(o,c,g){return this.rackApi_.addMonitor(o,c,g)}addBlade(o){return this.rackApi_.addBlade(o)}}class Bc extends Ke{constructor(o,c){super(o,new gi(o.rackController,c)),this.onPageAdd_=this.onPageAdd_.bind(this),this.onPageRemove_=this.onPageRemove_.bind(this),this.onSelect_=this.onSelect_.bind(this),this.emitter_=new _,this.pageApiMap_=new Map,this.rackApi_.on("change",g=>{this.emitter_.emit("change",{event:g})}),this.rackApi_.on("update",g=>{this.emitter_.emit("update",{event:g})}),this.controller_.tab.selectedIndex.emitter.on("change",this.onSelect_),this.controller_.pageSet.emitter.on("add",this.onPageAdd_),this.controller_.pageSet.emitter.on("remove",this.onPageRemove_),this.controller_.pageSet.items.forEach(g=>{this.setUpPageApi_(g)})}get pages(){return this.controller_.pageSet.items.map(o=>{const c=this.pageApiMap_.get(o);if(!c)throw x.shouldNeverHappen();return c})}addPage(o){const c=this.controller_.view.element.ownerDocument,g=new Fc(c,{itemProps:j.fromObject({selected:!1,title:o.title}),props:j.fromObject({selected:!1})});this.controller_.add(g,o.index);const S=this.pageApiMap_.get(g);if(!S)throw x.shouldNeverHappen();return S}removePage(o){this.controller_.remove(o)}on(o,c){const g=c.bind(this);return this.emitter_.on(o,S=>{g(S.event)}),this}setUpPageApi_(o){const c=this.rackApi_.apiSet_.find(S=>S.controller_===o.contentController);if(!c)throw x.shouldNeverHappen();const g=new kc(o,c);this.pageApiMap_.set(o,g)}onPageAdd_(o){this.setUpPageApi_(o.item)}onPageRemove_(o){if(!this.pageApiMap_.get(o.item))throw x.shouldNeverHappen();this.pageApiMap_.delete(o.item)}onSelect_(o){this.emitter_.emit("select",{event:new h(this,o.rawValue)})}}const Oc=-1;class uf{constructor(){this.onItemSelectedChange_=this.onItemSelectedChange_.bind(this),this.empty=B(!0),this.selectedIndex=B(Oc),this.items_=[]}add(o,c){const g=c!=null?c:this.items_.length;this.items_.splice(g,0,o),o.emitter.on("change",this.onItemSelectedChange_),this.keepSelection_()}remove(o){const c=this.items_.indexOf(o);c<0||(this.items_.splice(c,1),o.emitter.off("change",this.onItemSelectedChange_),this.keepSelection_())}keepSelection_(){if(this.items_.length===0){this.selectedIndex.rawValue=Oc,this.empty.rawValue=!0;return}const o=this.items_.findIndex(c=>c.rawValue);o<0?(this.items_.forEach((c,g)=>{c.rawValue=g===0}),this.selectedIndex.rawValue=0):(this.items_.forEach((c,g)=>{c.rawValue=g===o}),this.selectedIndex.rawValue=o),this.empty.rawValue=!1}onItemSelectedChange_(o){if(o.rawValue){const c=this.items_.findIndex(g=>g===o.sender);this.items_.forEach((g,S)=>{g.rawValue=S===c}),this.selectedIndex.rawValue=c}else this.keepSelection_()}}const Jr=M("tab");class hf{constructor(o,c){this.element=o.createElement("div"),this.element.classList.add(Jr(),It()),c.viewProps.bindClassModifiers(this.element),E(c.empty,N(this.element,Jr(void 0,"nop")));const g=o.createElement("div");g.classList.add(Jr("i")),this.element.appendChild(g),this.itemsElement=g;const S=c.contentsElement;S.classList.add(Jr("c")),this.element.appendChild(S),this.contentsElement=S}}class Vc extends Ws{constructor(o,c){const g=new kt(o,{blade:c.blade,viewProps:c.viewProps}),S=new uf;super({blade:c.blade,rackController:g,view:new hf(o,{contentsElement:g.view.element,empty:S.empty,viewProps:c.viewProps})}),this.onPageAdd_=this.onPageAdd_.bind(this),this.onPageRemove_=this.onPageRemove_.bind(this),this.pageSet_=new Oi(()=>null),this.pageSet_.emitter.on("add",this.onPageAdd_),this.pageSet_.emitter.on("remove",this.onPageRemove_),this.tab=S}get pageSet(){return this.pageSet_}add(o,c){this.pageSet_.add(o,c)}remove(o){this.pageSet_.remove(this.pageSet_.items[o])}onPageAdd_(o){const c=o.item;J(this.view.itemsElement,c.itemController.view.element,o.index),this.rackController.rack.add(c.contentController,o.index),this.tab.add(c.props.value("selected"))}onPageRemove_(o){const c=o.item;it(c.itemController.view.element),this.rackController.rack.remove(c.contentController),this.tab.remove(c.props.value("selected"))}}const zc={id:"tab",type:"blade",accept(d){const o=ct,c=ft(d,{pages:o.required.array(o.required.object({title:o.required.string})),view:o.required.constant("tab")});return!c||c.pages.length===0?null:{params:c}},controller(d){const o=new Vc(d.document,{blade:d.blade,viewProps:d.viewProps});return d.params.pages.forEach(c=>{const g=new Fc(d.document,{itemProps:j.fromObject({selected:!1,title:c.title}),props:j.fromObject({selected:!1})});o.add(g)}),o},api(d){return d.controller instanceof Vc?new Bc(d.controller,d.pool):null}};function df(d,o){const c=d.accept(o.params);if(!c)return null;const g=ct.optional.boolean(o.params.disabled).value,S=ct.optional.boolean(o.params.hidden).value;return d.controller({blade:St(),document:o.document,params:Object.assign(Object.assign({},c.params),{disabled:g,hidden:S}),viewProps:cn.create({disabled:g,hidden:S})})}class pf{constructor(){this.disabled=!1,this.emitter=new _}dispose(){}tick(){this.disabled||this.emitter.emit("tick",{sender:this})}}class ff{constructor(o,c){this.disabled_=!1,this.timerId_=null,this.onTick_=this.onTick_.bind(this),this.doc_=o,this.emitter=new _,this.interval_=c,this.setTimer_()}get disabled(){return this.disabled_}set disabled(o){this.disabled_=o,this.disabled_?this.clearTimer_():this.setTimer_()}dispose(){this.clearTimer_()}clearTimer_(){if(this.timerId_===null)return;const o=this.doc_.defaultView;o&&o.clearInterval(this.timerId_),this.timerId_=null}setTimer_(){if(this.clearTimer_(),this.interval_<=0)return;const o=this.doc_.defaultView;o&&(this.timerId_=o.setInterval(this.onTick_,this.interval_))}onTick_(){this.disabled_||this.emitter.emit("tick",{sender:this})}}class js{constructor(o){this.constraints=o}constrain(o){return this.constraints.reduce((c,g)=>g.constrain(c),o)}}function hn(d,o){if(d instanceof o)return d;if(d instanceof js){const c=d.constraints.reduce((g,S)=>g||(S instanceof o?S:null),null);if(c)return c}return null}class Xs{constructor(o){this.options=o}constrain(o){const c=this.options;return c.length===0||c.filter(S=>S.value===o).length>0?o:c[0].value}}class Wi{constructor(o){this.maxValue=o.max,this.minValue=o.min}constrain(o){let c=o;return f(this.minValue)||(c=Math.max(c,this.minValue)),f(this.maxValue)||(c=Math.min(c,this.maxValue)),c}}class Qr{constructor(o,c=0){this.step=o,this.origin=c}constrain(o){const c=this.origin%this.step,g=Math.round((o-c)/this.step);return c+g*this.step}}const ba=M("lst");class mf{constructor(o,c){this.onValueChange_=this.onValueChange_.bind(this),this.props_=c.props,this.element=o.createElement("div"),this.element.classList.add(ba()),c.viewProps.bindClassModifiers(this.element);const g=o.createElement("select");g.classList.add(ba("s")),P(this.props_,"options",k=>{gt(g),k.forEach((X,st)=>{const Ct=o.createElement("option");Ct.dataset.index=String(st),Ct.textContent=X.text,Ct.value=String(X.value),g.appendChild(Ct)})}),c.viewProps.bindDisabled(g),this.element.appendChild(g),this.selectElement=g;const S=o.createElement("div");S.classList.add(ba("m")),S.appendChild(R(o,"dropdown")),this.element.appendChild(S),c.value.emitter.on("change",this.onValueChange_),this.value_=c.value,this.update_()}update_(){this.selectElement.value=String(this.value_.rawValue)}onValueChange_(){this.update_()}}class qs{constructor(o,c){this.onSelectChange_=this.onSelectChange_.bind(this),this.props=c.props,this.value=c.value,this.viewProps=c.viewProps,this.view=new mf(o,{props:this.props,value:this.value,viewProps:this.viewProps}),this.view.selectElement.addEventListener("change",this.onSelectChange_)}onSelectChange_(o){const g=o.currentTarget.selectedOptions.item(0);if(!g)return;const S=Number(g.dataset.index);this.value.rawValue=this.props.get("options")[S].value}}const Uc=M("pop");class gf{constructor(o,c){this.element=o.createElement("div"),this.element.classList.add(Uc()),c.viewProps.bindClassModifiers(this.element),E(c.shows,N(this.element,Uc(void 0,"v")))}}class Hc{constructor(o,c){this.shows=B(!1),this.viewProps=c.viewProps,this.view=new gf(o,{shows:this.shows,viewProps:this.viewProps})}}const Gc=M("txt");class vf{constructor(o,c){this.onChange_=this.onChange_.bind(this),this.element=o.createElement("div"),this.element.classList.add(Gc()),c.viewProps.bindClassModifiers(this.element),this.props_=c.props,this.props_.emitter.on("change",this.onChange_);const g=o.createElement("input");g.classList.add(Gc("i")),g.type="text",c.viewProps.bindDisabled(g),this.element.appendChild(g),this.inputElement=g,c.value.emitter.on("change",this.onChange_),this.value_=c.value,this.refresh()}refresh(){const o=this.props_.get("formatter");this.inputElement.value=o(this.value_.rawValue)}onChange_(){this.refresh()}}class to{constructor(o,c){this.onInputChange_=this.onInputChange_.bind(this),this.parser_=c.parser,this.props=c.props,this.value=c.value,this.viewProps=c.viewProps,this.view=new vf(o,{props:c.props,value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_)}onInputChange_(o){const g=o.currentTarget.value,S=this.parser_(g);f(S)||(this.value.rawValue=S),this.view.refresh()}}function _f(d){return String(d)}function Wc(d){return d==="false"?!1:!!d}function jc(d){return _f(d)}class xf{constructor(o){this.text=o}evaluate(){return Number(this.text)}toString(){return this.text}}const yf={"**":(d,o)=>Math.pow(d,o),"*":(d,o)=>d*o,"/":(d,o)=>d/o,"%":(d,o)=>d%o,"+":(d,o)=>d+o,"-":(d,o)=>d-o,"<<":(d,o)=>d<<o,">>":(d,o)=>d>>o,">>>":(d,o)=>d>>>o,"&":(d,o)=>d&o,"^":(d,o)=>d^o,"|":(d,o)=>d|o};class bf{constructor(o,c,g){this.left=c,this.operator=o,this.right=g}evaluate(){const o=yf[this.operator];if(!o)throw new Error(`unexpected binary operator: '${this.operator}`);return o(this.left.evaluate(),this.right.evaluate())}toString(){return["b(",this.left.toString(),this.operator,this.right.toString(),")"].join(" ")}}const wf={"+":d=>d,"-":d=>-d,"~":d=>~d};class Mf{constructor(o,c){this.operator=o,this.expression=c}evaluate(){const o=wf[this.operator];if(!o)throw new Error(`unexpected unary operator: '${this.operator}`);return o(this.expression.evaluate())}toString(){return["u(",this.operator,this.expression.toString(),")"].join(" ")}}function wa(d){return(o,c)=>{for(let g=0;g<d.length;g++){const S=d[g](o,c);if(S!=="")return S}return""}}function Ys(d,o){var c;const g=d.substr(o).match(/^\s+/);return(c=g&&g[0])!==null&&c!==void 0?c:""}function Ef(d,o){const c=d.substr(o,1);return c.match(/^[1-9]$/)?c:""}function Zs(d,o){var c;const g=d.substr(o).match(/^[0-9]+/);return(c=g&&g[0])!==null&&c!==void 0?c:""}function Sf(d,o){const c=Zs(d,o);if(c!=="")return c;const g=d.substr(o,1);if(o+=1,g!=="-"&&g!=="+")return"";const S=Zs(d,o);return S===""?"":g+S}function Ma(d,o){const c=d.substr(o,1);if(o+=1,c.toLowerCase()!=="e")return"";const g=Sf(d,o);return g===""?"":c+g}function Xc(d,o){const c=d.substr(o,1);if(c==="0")return c;const g=Ef(d,o);return o+=g.length,g===""?"":g+Zs(d,o)}function Tf(d,o){const c=Xc(d,o);if(o+=c.length,c==="")return"";const g=d.substr(o,1);if(o+=g.length,g!==".")return"";const S=Zs(d,o);return o+=S.length,c+g+S+Ma(d,o)}function Af(d,o){const c=d.substr(o,1);if(o+=c.length,c!==".")return"";const g=Zs(d,o);return o+=g.length,g===""?"":c+g+Ma(d,o)}function Cf(d,o){const c=Xc(d,o);return o+=c.length,c===""?"":c+Ma(d,o)}const Pf=wa([Tf,Af,Cf]);function Lf(d,o){var c;const g=d.substr(o).match(/^[01]+/);return(c=g&&g[0])!==null&&c!==void 0?c:""}function Rf(d,o){const c=d.substr(o,2);if(o+=c.length,c.toLowerCase()!=="0b")return"";const g=Lf(d,o);return g===""?"":c+g}function If(d,o){var c;const g=d.substr(o).match(/^[0-7]+/);return(c=g&&g[0])!==null&&c!==void 0?c:""}function Df(d,o){const c=d.substr(o,2);if(o+=c.length,c.toLowerCase()!=="0o")return"";const g=If(d,o);return g===""?"":c+g}function Nf(d,o){var c;const g=d.substr(o).match(/^[0-9a-f]+/i);return(c=g&&g[0])!==null&&c!==void 0?c:""}function Ff(d,o){const c=d.substr(o,2);if(o+=c.length,c.toLowerCase()!=="0x")return"";const g=Nf(d,o);return g===""?"":c+g}const kf=wa([Rf,Df,Ff]),Bf=wa([kf,Pf]);function Of(d,o){const c=Bf(d,o);return o+=c.length,c===""?null:{evaluable:new xf(c),cursor:o}}function Vf(d,o){const c=d.substr(o,1);if(o+=c.length,c!=="(")return null;const g=Yc(d,o);if(!g)return null;o=g.cursor,o+=Ys(d,o).length;const S=d.substr(o,1);return o+=S.length,S!==")"?null:{evaluable:g.evaluable,cursor:o}}function zf(d,o){var c;return(c=Of(d,o))!==null&&c!==void 0?c:Vf(d,o)}function qc(d,o){const c=zf(d,o);if(c)return c;const g=d.substr(o,1);if(o+=g.length,g!=="+"&&g!=="-"&&g!=="~")return null;const S=qc(d,o);return S?(o=S.cursor,{cursor:o,evaluable:new Mf(g,S.evaluable)}):null}function Uf(d,o,c){c+=Ys(o,c).length;const g=d.filter(S=>o.startsWith(S,c))[0];return g?(c+=g.length,c+=Ys(o,c).length,{cursor:c,operator:g}):null}function Hf(d,o){return(c,g)=>{const S=d(c,g);if(!S)return null;g=S.cursor;let k=S.evaluable;for(;;){const X=Uf(o,c,g);if(!X)break;g=X.cursor;const st=d(c,g);if(!st)return null;g=st.cursor,k=new bf(X.operator,k,st.evaluable)}return k?{cursor:g,evaluable:k}:null}}const Gf=[["**"],["*","/","%"],["+","-"],["<<",">>>",">>"],["&"],["^"],["|"]].reduce((d,o)=>Hf(d,o),qc);function Yc(d,o){return o+=Ys(d,o).length,Gf(d,o)}function Wf(d){const o=Yc(d,0);return!o||o.cursor+Ys(d,o.cursor).length!==d.length?null:o.evaluable}function Tn(d){var o;const c=Wf(d);return(o=c==null?void 0:c.evaluate())!==null&&o!==void 0?o:null}function Zc(d){if(typeof d=="number")return d;if(typeof d=="string"){const o=Tn(d);if(!f(o))return o}return 0}function jf(d){return String(d)}function Se(d){return o=>o.toFixed(Math.max(Math.min(d,20),0))}const Xf=Se(0);function eo(d){return Xf(d)+"%"}function Kc(d){return String(d)}function Ea(d){return d}function $c(d,o){for(;d.length<o;)d.push(void 0)}function qf(d){const o=[];return $c(o,d),B(o)}function Yf(d){const o=d.indexOf(void 0);return o<0?d:d.slice(0,o)}function Zf(d,o){const c=[...Yf(d),o];return c.length>d.length?c.splice(0,c.length-d.length):$c(c,d.length),c}function Ks({primary:d,secondary:o,forward:c,backward:g}){let S=!1;function k(X){S||(S=!0,X(),S=!1)}d.emitter.on("change",X=>{k(()=>{o.setRawValue(c(d,o),X.options)})}),o.emitter.on("change",X=>{k(()=>{d.setRawValue(g(d,o),X.options)}),k(()=>{o.setRawValue(c(d,o),X.options)})}),k(()=>{o.setRawValue(c(d,o),{forceEmit:!1,last:!0})})}function Be(d,o){const c=d*(o.altKey?.1:1)*(o.shiftKey?10:1);return o.upKey?+c:o.downKey?-c:0}function $s(d){return{altKey:d.altKey,downKey:d.key==="ArrowDown",shiftKey:d.shiftKey,upKey:d.key==="ArrowUp"}}function An(d){return{altKey:d.altKey,downKey:d.key==="ArrowLeft",shiftKey:d.shiftKey,upKey:d.key==="ArrowRight"}}function Kf(d){return d==="ArrowUp"||d==="ArrowDown"}function Jc(d){return Kf(d)||d==="ArrowLeft"||d==="ArrowRight"}function Sa(d,o){var c,g;const S=o.ownerDocument.defaultView,k=o.getBoundingClientRect();return{x:d.pageX-(((c=S&&S.scrollX)!==null&&c!==void 0?c:0)+k.left),y:d.pageY-(((g=S&&S.scrollY)!==null&&g!==void 0?g:0)+k.top)}}class _i{constructor(o){this.lastTouch_=null,this.onDocumentMouseMove_=this.onDocumentMouseMove_.bind(this),this.onDocumentMouseUp_=this.onDocumentMouseUp_.bind(this),this.onMouseDown_=this.onMouseDown_.bind(this),this.onTouchEnd_=this.onTouchEnd_.bind(this),this.onTouchMove_=this.onTouchMove_.bind(this),this.onTouchStart_=this.onTouchStart_.bind(this),this.elem_=o,this.emitter=new _,o.addEventListener("touchstart",this.onTouchStart_,{passive:!1}),o.addEventListener("touchmove",this.onTouchMove_,{passive:!0}),o.addEventListener("touchend",this.onTouchEnd_),o.addEventListener("mousedown",this.onMouseDown_)}computePosition_(o){const c=this.elem_.getBoundingClientRect();return{bounds:{width:c.width,height:c.height},point:o?{x:o.x,y:o.y}:null}}onMouseDown_(o){var c;o.preventDefault(),(c=o.currentTarget)===null||c===void 0||c.focus();const g=this.elem_.ownerDocument;g.addEventListener("mousemove",this.onDocumentMouseMove_),g.addEventListener("mouseup",this.onDocumentMouseUp_),this.emitter.emit("down",{altKey:o.altKey,data:this.computePosition_(Sa(o,this.elem_)),sender:this,shiftKey:o.shiftKey})}onDocumentMouseMove_(o){this.emitter.emit("move",{altKey:o.altKey,data:this.computePosition_(Sa(o,this.elem_)),sender:this,shiftKey:o.shiftKey})}onDocumentMouseUp_(o){const c=this.elem_.ownerDocument;c.removeEventListener("mousemove",this.onDocumentMouseMove_),c.removeEventListener("mouseup",this.onDocumentMouseUp_),this.emitter.emit("up",{altKey:o.altKey,data:this.computePosition_(Sa(o,this.elem_)),sender:this,shiftKey:o.shiftKey})}onTouchStart_(o){o.preventDefault();const c=o.targetTouches.item(0),g=this.elem_.getBoundingClientRect();this.emitter.emit("down",{altKey:o.altKey,data:this.computePosition_(c?{x:c.clientX-g.left,y:c.clientY-g.top}:void 0),sender:this,shiftKey:o.shiftKey}),this.lastTouch_=c}onTouchMove_(o){const c=o.targetTouches.item(0),g=this.elem_.getBoundingClientRect();this.emitter.emit("move",{altKey:o.altKey,data:this.computePosition_(c?{x:c.clientX-g.left,y:c.clientY-g.top}:void 0),sender:this,shiftKey:o.shiftKey}),this.lastTouch_=c}onTouchEnd_(o){var c;const g=(c=o.targetTouches.item(0))!==null&&c!==void 0?c:this.lastTouch_,S=this.elem_.getBoundingClientRect();this.emitter.emit("up",{altKey:o.altKey,data:this.computePosition_(g?{x:g.clientX-S.left,y:g.clientY-S.top}:void 0),sender:this,shiftKey:o.shiftKey})}}function le(d,o,c,g,S){const k=(d-o)/(c-o);return g+k*(S-g)}function Qc(d){return String(d.toFixed(10)).split(".")[1].replace(/0+$/,"").length}function xe(d,o,c){return Math.min(Math.max(d,o),c)}function tu(d,o){return(d%o+o)%o}const We=M("txt");class $f{constructor(o,c){this.onChange_=this.onChange_.bind(this),this.props_=c.props,this.props_.emitter.on("change",this.onChange_),this.element=o.createElement("div"),this.element.classList.add(We(),We(void 0,"num")),c.arrayPosition&&this.element.classList.add(We(void 0,c.arrayPosition)),c.viewProps.bindClassModifiers(this.element);const g=o.createElement("input");g.classList.add(We("i")),g.type="text",c.viewProps.bindDisabled(g),this.element.appendChild(g),this.inputElement=g,this.onDraggingChange_=this.onDraggingChange_.bind(this),this.dragging_=c.dragging,this.dragging_.emitter.on("change",this.onDraggingChange_),this.element.classList.add(We()),this.inputElement.classList.add(We("i"));const S=o.createElement("div");S.classList.add(We("k")),this.element.appendChild(S),this.knobElement=S;const k=o.createElementNS(bt,"svg");k.classList.add(We("g")),this.knobElement.appendChild(k);const X=o.createElementNS(bt,"path");X.classList.add(We("gb")),k.appendChild(X),this.guideBodyElem_=X;const st=o.createElementNS(bt,"path");st.classList.add(We("gh")),k.appendChild(st),this.guideHeadElem_=st;const Ct=o.createElement("div");Ct.classList.add(M("tt")()),this.knobElement.appendChild(Ct),this.tooltipElem_=Ct,c.value.emitter.on("change",this.onChange_),this.value=c.value,this.refresh()}onDraggingChange_(o){if(o.rawValue===null){this.element.classList.remove(We(void 0,"drg"));return}this.element.classList.add(We(void 0,"drg"));const c=o.rawValue/this.props_.get("draggingScale"),g=c+(c>0?-1:c<0?1:0),S=xe(-g,-4,4);this.guideHeadElem_.setAttributeNS(null,"d",[`M ${g+S},0 L${g},4 L${g+S},8`,`M ${c},-1 L${c},9`].join(" ")),this.guideBodyElem_.setAttributeNS(null,"d",`M 0,4 L${c},4`);const k=this.props_.get("formatter");this.tooltipElem_.textContent=k(this.value.rawValue),this.tooltipElem_.style.left=`${c}px`}refresh(){const o=this.props_.get("formatter");this.inputElement.value=o(this.value.rawValue)}onChange_(){this.refresh()}}class Js{constructor(o,c){var g;this.originRawValue_=0,this.onInputChange_=this.onInputChange_.bind(this),this.onInputKeyDown_=this.onInputKeyDown_.bind(this),this.onInputKeyUp_=this.onInputKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.baseStep_=c.baseStep,this.parser_=c.parser,this.props=c.props,this.sliderProps_=(g=c.sliderProps)!==null&&g!==void 0?g:null,this.value=c.value,this.viewProps=c.viewProps,this.dragging_=B(null),this.view=new $f(o,{arrayPosition:c.arrayPosition,dragging:this.dragging_,props:this.props,value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_),this.view.inputElement.addEventListener("keydown",this.onInputKeyDown_),this.view.inputElement.addEventListener("keyup",this.onInputKeyUp_);const S=new _i(this.view.knobElement);S.emitter.on("down",this.onPointerDown_),S.emitter.on("move",this.onPointerMove_),S.emitter.on("up",this.onPointerUp_)}constrainValue_(o){var c,g;const S=(c=this.sliderProps_)===null||c===void 0?void 0:c.get("minValue"),k=(g=this.sliderProps_)===null||g===void 0?void 0:g.get("maxValue");let X=o;return S!==void 0&&(X=Math.max(X,S)),k!==void 0&&(X=Math.min(X,k)),X}onInputChange_(o){const g=o.currentTarget.value,S=this.parser_(g);f(S)||(this.value.rawValue=this.constrainValue_(S)),this.view.refresh()}onInputKeyDown_(o){const c=Be(this.baseStep_,$s(o));c!==0&&this.value.setRawValue(this.constrainValue_(this.value.rawValue+c),{forceEmit:!1,last:!1})}onInputKeyUp_(o){Be(this.baseStep_,$s(o))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}onPointerDown_(){this.originRawValue_=this.value.rawValue,this.dragging_.rawValue=0}computeDraggingValue_(o){if(!o.point)return null;const c=o.point.x-o.bounds.width/2;return this.constrainValue_(this.originRawValue_+c*this.props.get("draggingScale"))}onPointerMove_(o){const c=this.computeDraggingValue_(o.data);c!==null&&(this.value.setRawValue(c,{forceEmit:!1,last:!1}),this.dragging_.rawValue=this.value.rawValue-this.originRawValue_)}onPointerUp_(o){const c=this.computeDraggingValue_(o.data);c!==null&&(this.value.setRawValue(c,{forceEmit:!0,last:!0}),this.dragging_.rawValue=null)}}const Ta=M("sld");class Jf{constructor(o,c){this.onChange_=this.onChange_.bind(this),this.props_=c.props,this.props_.emitter.on("change",this.onChange_),this.element=o.createElement("div"),this.element.classList.add(Ta()),c.viewProps.bindClassModifiers(this.element);const g=o.createElement("div");g.classList.add(Ta("t")),c.viewProps.bindTabIndex(g),this.element.appendChild(g),this.trackElement=g;const S=o.createElement("div");S.classList.add(Ta("k")),this.trackElement.appendChild(S),this.knobElement=S,c.value.emitter.on("change",this.onChange_),this.value=c.value,this.update_()}update_(){const o=xe(le(this.value.rawValue,this.props_.get("minValue"),this.props_.get("maxValue"),0,100),0,100);this.knobElement.style.width=`${o}%`}onChange_(){this.update_()}}class Qf{constructor(o,c){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDownOrMove_=this.onPointerDownOrMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.baseStep_=c.baseStep,this.value=c.value,this.viewProps=c.viewProps,this.props=c.props,this.view=new Jf(o,{props:this.props,value:this.value,viewProps:this.viewProps}),this.ptHandler_=new _i(this.view.trackElement),this.ptHandler_.emitter.on("down",this.onPointerDownOrMove_),this.ptHandler_.emitter.on("move",this.onPointerDownOrMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.trackElement.addEventListener("keydown",this.onKeyDown_),this.view.trackElement.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(o,c){!o.point||this.value.setRawValue(le(xe(o.point.x,0,o.bounds.width),0,o.bounds.width,this.props.get("minValue"),this.props.get("maxValue")),c)}onPointerDownOrMove_(o){this.handlePointerEvent_(o.data,{forceEmit:!1,last:!1})}onPointerUp_(o){this.handlePointerEvent_(o.data,{forceEmit:!0,last:!0})}onKeyDown_(o){const c=Be(this.baseStep_,An(o));c!==0&&this.value.setRawValue(this.value.rawValue+c,{forceEmit:!1,last:!1})}onKeyUp_(o){Be(this.baseStep_,An(o))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const Aa=M("sldtxt");class tm{constructor(o,c){this.element=o.createElement("div"),this.element.classList.add(Aa());const g=o.createElement("div");g.classList.add(Aa("s")),this.sliderView_=c.sliderView,g.appendChild(this.sliderView_.element),this.element.appendChild(g);const S=o.createElement("div");S.classList.add(Aa("t")),this.textView_=c.textView,S.appendChild(this.textView_.element),this.element.appendChild(S)}}class Ca{constructor(o,c){this.value=c.value,this.viewProps=c.viewProps,this.sliderC_=new Qf(o,{baseStep:c.baseStep,props:c.sliderProps,value:c.value,viewProps:this.viewProps}),this.textC_=new Js(o,{baseStep:c.baseStep,parser:c.parser,props:c.textProps,sliderProps:c.sliderProps,value:c.value,viewProps:c.viewProps}),this.view=new tm(o,{sliderView:this.sliderC_.view,textView:this.textC_.view})}get sliderController(){return this.sliderC_}get textController(){return this.textC_}}function Qs(d,o){d.write(o)}function no(d){const o=ct;if(Array.isArray(d))return o.required.array(o.required.object({text:o.required.string,value:o.required.raw}))(d).value;if(typeof d=="object")return o.required.raw(d).value}function eu(d){if(d==="inline"||d==="popup")return d}function Gn(d){const o=ct;return o.required.object({max:o.optional.number,min:o.optional.number,step:o.optional.number})(d).value}function nu(d){if(Array.isArray(d))return d;const o=[];return Object.keys(d).forEach(c=>{o.push({text:c,value:d[c]})}),o}function Pa(d){return f(d)?null:new Xs(nu(d))}function La(d){const o=d?hn(d,Xs):null;return o?o.options:null}function em(d){const o=d?hn(d,Qr):null;return o?o.step:null}function io(d,o){const c=d&&hn(d,Qr);return c?Qc(c.step):Math.max(Qc(o),2)}function ji(d){const o=em(d);return o!=null?o:1}function Xi(d,o){var c;const g=d&&hn(d,Qr),S=Math.abs((c=g==null?void 0:g.step)!==null&&c!==void 0?c:o);return S===0?.1:Math.pow(10,Math.floor(Math.log10(S))-1)}const so=M("ckb");class nm{constructor(o,c){this.onValueChange_=this.onValueChange_.bind(this),this.element=o.createElement("div"),this.element.classList.add(so()),c.viewProps.bindClassModifiers(this.element);const g=o.createElement("label");g.classList.add(so("l")),this.element.appendChild(g);const S=o.createElement("input");S.classList.add(so("i")),S.type="checkbox",g.appendChild(S),this.inputElement=S,c.viewProps.bindDisabled(this.inputElement);const k=o.createElement("div");k.classList.add(so("w")),g.appendChild(k);const X=R(o,"check");k.appendChild(X),c.value.emitter.on("change",this.onValueChange_),this.value=c.value,this.update_()}update_(){this.inputElement.checked=this.value.rawValue}onValueChange_(){this.update_()}}class im{constructor(o,c){this.onInputChange_=this.onInputChange_.bind(this),this.value=c.value,this.viewProps=c.viewProps,this.view=new nm(o,{value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_)}onInputChange_(o){const c=o.currentTarget;this.value.rawValue=c.checked}}function sm(d){const o=[],c=Pa(d.options);return c&&o.push(c),new js(o)}const rm={id:"input-bool",type:"input",accept:(d,o)=>{if(typeof d!="boolean")return null;const g=ft(o,{options:ct.optional.custom(no)});return g?{initialValue:d,params:g}:null},binding:{reader:d=>Wc,constraint:d=>sm(d.params),writer:d=>Qs},controller:d=>{var o;const c=d.document,g=d.value,S=d.constraint;return S&&hn(S,Xs)?new qs(c,{props:j.fromObject({options:(o=La(S))!==null&&o!==void 0?o:[]}),value:g,viewProps:d.viewProps}):new im(c,{value:g,viewProps:d.viewProps})}},xi=M("col");class om{constructor(o,c){this.element=o.createElement("div"),this.element.classList.add(xi()),c.foldable.bindExpandedClass(this.element,xi(void 0,"expanded")),P(c.foldable,"completed",N(this.element,xi(void 0,"cpl")));const g=o.createElement("div");g.classList.add(xi("h")),this.element.appendChild(g);const S=o.createElement("div");S.classList.add(xi("s")),g.appendChild(S),this.swatchElement=S;const k=o.createElement("div");if(k.classList.add(xi("t")),g.appendChild(k),this.textElement=k,c.pickerLayout==="inline"){const X=o.createElement("div");X.classList.add(xi("p")),this.element.appendChild(X),this.pickerElement=X}else this.pickerElement=null}}function am(d,o,c){const g=xe(d/255,0,1),S=xe(o/255,0,1),k=xe(c/255,0,1),X=Math.max(g,S,k),st=Math.min(g,S,k),Ct=X-st;let Bt=0,Kt=0;const $t=(st+X)/2;return Ct!==0&&(Kt=Ct/(1-Math.abs(X+st-1)),g===X?Bt=(S-k)/Ct:S===X?Bt=2+(k-g)/Ct:Bt=4+(g-S)/Ct,Bt=Bt/6+(Bt<0?1:0)),[Bt*360,Kt*100,$t*100]}function lm(d,o,c){const g=(d%360+360)%360,S=xe(o/100,0,1),k=xe(c/100,0,1),X=(1-Math.abs(2*k-1))*S,st=X*(1-Math.abs(g/60%2-1)),Ct=k-X/2;let Bt,Kt,$t;return g>=0&&g<60?[Bt,Kt,$t]=[X,st,0]:g>=60&&g<120?[Bt,Kt,$t]=[st,X,0]:g>=120&&g<180?[Bt,Kt,$t]=[0,X,st]:g>=180&&g<240?[Bt,Kt,$t]=[0,st,X]:g>=240&&g<300?[Bt,Kt,$t]=[st,0,X]:[Bt,Kt,$t]=[X,0,st],[(Bt+Ct)*255,(Kt+Ct)*255,($t+Ct)*255]}function cm(d,o,c){const g=xe(d/255,0,1),S=xe(o/255,0,1),k=xe(c/255,0,1),X=Math.max(g,S,k),st=Math.min(g,S,k),Ct=X-st;let Bt;Ct===0?Bt=0:X===g?Bt=60*(((S-k)/Ct%6+6)%6):X===S?Bt=60*((k-g)/Ct+2):Bt=60*((g-S)/Ct+4);const Kt=X===0?0:Ct/X,$t=X;return[Bt,Kt*100,$t*100]}function iu(d,o,c){const g=tu(d,360),S=xe(o/100,0,1),k=xe(c/100,0,1),X=k*S,st=X*(1-Math.abs(g/60%2-1)),Ct=k-X;let Bt,Kt,$t;return g>=0&&g<60?[Bt,Kt,$t]=[X,st,0]:g>=60&&g<120?[Bt,Kt,$t]=[st,X,0]:g>=120&&g<180?[Bt,Kt,$t]=[0,X,st]:g>=180&&g<240?[Bt,Kt,$t]=[0,st,X]:g>=240&&g<300?[Bt,Kt,$t]=[st,0,X]:[Bt,Kt,$t]=[X,0,st],[(Bt+Ct)*255,(Kt+Ct)*255,($t+Ct)*255]}function um(d,o,c){const g=c+o*(100-Math.abs(2*c-100))/200;return[d,g!==0?o*(100-Math.abs(2*c-100))/g:0,c+o*(100-Math.abs(2*c-100))/(2*100)]}function hm(d,o,c){const g=100-Math.abs(c*(200-o)/100-100);return[d,g!==0?o*c/g:0,c*(200-o)/(2*100)]}function yi(d){return[d[0],d[1],d[2]]}function su(d,o){return[d[0],d[1],d[2],o]}const dm={hsl:{hsl:(d,o,c)=>[d,o,c],hsv:um,rgb:lm},hsv:{hsl:hm,hsv:(d,o,c)=>[d,o,c],rgb:iu},rgb:{hsl:am,hsv:cm,rgb:(d,o,c)=>[d,o,c]}};function ro(d,o){return[o==="float"?1:d==="rgb"?255:360,o==="float"?1:d==="rgb"?255:100,o==="float"?1:d==="rgb"?255:100]}function pm(d,o,c){var g;const S=ro(o,c);return[o==="rgb"?xe(d[0],0,S[0]):tu(d[0],S[0]),xe(d[1],0,S[1]),xe(d[2],0,S[2]),xe((g=d[3])!==null&&g!==void 0?g:1,0,1)]}function ru(d,o,c,g){const S=ro(o,c),k=ro(o,g);return d.map((X,st)=>X/S[st]*k[st])}function fm(d,o,c){const g=ru(d,o.mode,o.type,"int"),S=dm[o.mode][c.mode](...g);return ru(S,c.mode,"int",c.type)}function oo(d,o){return typeof d!="object"||f(d)?!1:o in d&&typeof d[o]=="number"}class zt{constructor(o,c,g="int"){this.mode=c,this.type=g,this.comps_=pm(o,c,g)}static black(o="int"){return new zt([0,0,0],"rgb",o)}static fromObject(o,c="int"){const g="a"in o?[o.r,o.g,o.b,o.a]:[o.r,o.g,o.b];return new zt(g,"rgb",c)}static toRgbaObject(o,c="int"){return o.toRgbaObject(c)}static isRgbColorObject(o){return oo(o,"r")&&oo(o,"g")&&oo(o,"b")}static isRgbaColorObject(o){return this.isRgbColorObject(o)&&oo(o,"a")}static isColorObject(o){return this.isRgbColorObject(o)}static equals(o,c){if(o.mode!==c.mode)return!1;const g=o.comps_,S=c.comps_;for(let k=0;k<g.length;k++)if(g[k]!==S[k])return!1;return!0}getComponents(o,c="int"){return su(fm(yi(this.comps_),{mode:this.mode,type:this.type},{mode:o!=null?o:this.mode,type:c}),this.comps_[3])}toRgbaObject(o="int"){const c=this.getComponents("rgb",o);return{r:c[0],g:c[1],b:c[2],a:c[3]}}}const Wn=M("colp");class mm{constructor(o,c){this.alphaViews_=null,this.element=o.createElement("div"),this.element.classList.add(Wn());const g=o.createElement("div");g.classList.add(Wn("hsv"));const S=o.createElement("div");S.classList.add(Wn("sv")),this.svPaletteView_=c.svPaletteView,S.appendChild(this.svPaletteView_.element),g.appendChild(S);const k=o.createElement("div");k.classList.add(Wn("h")),this.hPaletteView_=c.hPaletteView,k.appendChild(this.hPaletteView_.element),g.appendChild(k),this.element.appendChild(g);const X=o.createElement("div");if(X.classList.add(Wn("rgb")),this.textView_=c.textView,X.appendChild(this.textView_.element),this.element.appendChild(X),c.alphaViews){this.alphaViews_={palette:c.alphaViews.palette,text:c.alphaViews.text};const st=o.createElement("div");st.classList.add(Wn("a"));const Ct=o.createElement("div");Ct.classList.add(Wn("ap")),Ct.appendChild(this.alphaViews_.palette.element),st.appendChild(Ct);const Bt=o.createElement("div");Bt.classList.add(Wn("at")),Bt.appendChild(this.alphaViews_.text.element),st.appendChild(Bt),this.element.appendChild(st)}}get allFocusableElements(){const o=[this.svPaletteView_.element,this.hPaletteView_.element,this.textView_.modeSelectElement,...this.textView_.textViews.map(c=>c.inputElement)];return this.alphaViews_&&o.push(this.alphaViews_.palette.element,this.alphaViews_.text.inputElement),o}}function gm(d){return d==="int"?"int":d==="float"?"float":void 0}function Ra(d){const o=ct;return ft(d,{alpha:o.optional.boolean,color:o.optional.object({alpha:o.optional.boolean,type:o.optional.custom(gm)}),expanded:o.optional.boolean,picker:o.optional.custom(eu)})}function bi(d){return d?.1:1}function wi(d){var o;return(o=d.color)===null||o===void 0?void 0:o.type}function vm(d,o){return d.alpha===o.alpha&&d.mode===o.mode&&d.notation===o.notation&&d.type===o.type}function je(d,o){const c=d.match(/^(.+)%$/);return Math.min(c?parseFloat(c[1])*.01*o:parseFloat(d),o)}const _m={deg:d=>d,grad:d=>d*360/400,rad:d=>d*360/(2*Math.PI),turn:d=>d*360};function ou(d){const o=d.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);if(!o)return parseFloat(d);const c=parseFloat(o[1]),g=o[2];return _m[g](c)}function au(d){const o=d.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!o)return null;const c=[je(o[1],255),je(o[2],255),je(o[3],255)];return isNaN(c[0])||isNaN(c[1])||isNaN(c[2])?null:c}function lu(d){return o=>{const c=au(o);return c?new zt(c,"rgb",d):null}}function cu(d){const o=d.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!o)return null;const c=[je(o[1],255),je(o[2],255),je(o[3],255),je(o[4],1)];return isNaN(c[0])||isNaN(c[1])||isNaN(c[2])||isNaN(c[3])?null:c}function uu(d){return o=>{const c=cu(o);return c?new zt(c,"rgb",d):null}}function hu(d){const o=d.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!o)return null;const c=[ou(o[1]),je(o[2],100),je(o[3],100)];return isNaN(c[0])||isNaN(c[1])||isNaN(c[2])?null:c}function du(d){return o=>{const c=hu(o);return c?new zt(c,"hsl",d):null}}function pu(d){const o=d.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!o)return null;const c=[ou(o[1]),je(o[2],100),je(o[3],100),je(o[4],1)];return isNaN(c[0])||isNaN(c[1])||isNaN(c[2])||isNaN(c[3])?null:c}function fu(d){return o=>{const c=pu(o);return c?new zt(c,"hsl",d):null}}function mu(d){const o=d.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);if(o)return[parseInt(o[1]+o[1],16),parseInt(o[2]+o[2],16),parseInt(o[3]+o[3],16)];const c=d.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);return c?[parseInt(c[1],16),parseInt(c[2],16),parseInt(c[3],16)]:null}function xm(d){const o=mu(d);return o?new zt(o,"rgb","int"):null}function gu(d){const o=d.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);if(o)return[parseInt(o[1]+o[1],16),parseInt(o[2]+o[2],16),parseInt(o[3]+o[3],16),le(parseInt(o[4]+o[4],16),0,255,0,1)];const c=d.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);return c?[parseInt(c[1],16),parseInt(c[2],16),parseInt(c[3],16),le(parseInt(c[4],16),0,255,0,1)]:null}function ym(d){const o=gu(d);return o?new zt(o,"rgb","int"):null}function vu(d){const o=d.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);if(!o)return null;const c=[parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3])];return isNaN(c[0])||isNaN(c[1])||isNaN(c[2])?null:c}function _u(d){return o=>{const c=vu(o);return c?new zt(c,"rgb",d):null}}function xu(d){const o=d.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);if(!o)return null;const c=[parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3]),parseFloat(o[4])];return isNaN(c[0])||isNaN(c[1])||isNaN(c[2])||isNaN(c[3])?null:c}function yu(d){return o=>{const c=xu(o);return c?new zt(c,"rgb",d):null}}const bm=[{parser:mu,result:{alpha:!1,mode:"rgb",notation:"hex"}},{parser:gu,result:{alpha:!0,mode:"rgb",notation:"hex"}},{parser:au,result:{alpha:!1,mode:"rgb",notation:"func"}},{parser:cu,result:{alpha:!0,mode:"rgb",notation:"func"}},{parser:hu,result:{alpha:!1,mode:"hsl",notation:"func"}},{parser:pu,result:{alpha:!0,mode:"hsl",notation:"func"}},{parser:vu,result:{alpha:!1,mode:"rgb",notation:"object"}},{parser:xu,result:{alpha:!0,mode:"rgb",notation:"object"}}];function wm(d){return bm.reduce((o,{parser:c,result:g})=>o||(c(d)?g:null),null)}function Ia(d,o="int"){const c=wm(d);return c?c.notation==="hex"&&o!=="float"?Object.assign(Object.assign({},c),{type:"int"}):c.notation==="func"?Object.assign(Object.assign({},c),{type:o}):null:null}const bu={int:[xm,ym,lu("int"),uu("int"),du("int"),fu("int"),_u("int"),yu("int")],float:[lu("float"),uu("float"),du("float"),fu("float"),_u("float"),yu("float")]};function Mm(d){const o=bu[d];return c=>{if(typeof c!="string")return zt.black(d);const g=o.reduce((S,k)=>S||k(c),null);return g!=null?g:zt.black(d)}}function Da(d){const o=bu[d];return c=>o.reduce((g,S)=>g||S(c),null)}function wu(d){const o=xe(Math.floor(d),0,255).toString(16);return o.length===1?`0${o}`:o}function Mu(d,o="#"){const c=yi(d.getComponents("rgb")).map(wu).join("");return`${o}${c}`}function Na(d,o="#"){const c=d.getComponents("rgb"),g=[c[0],c[1],c[2],c[3]*255].map(wu).join("");return`${o}${g}`}function Eu(d,o){const c=Se(o==="float"?2:0);return`rgb(${yi(d.getComponents("rgb",o)).map(S=>c(S)).join(", ")})`}function Em(d){return o=>Eu(o,d)}function ao(d,o){const c=Se(2),g=Se(o==="float"?2:0);return`rgba(${d.getComponents("rgb",o).map((k,X)=>(X===3?c:g)(k)).join(", ")})`}function Sm(d){return o=>ao(o,d)}function Tm(d){const o=[Se(0),eo,eo];return`hsl(${yi(d.getComponents("hsl")).map((g,S)=>o[S](g)).join(", ")})`}function Am(d){const o=[Se(0),eo,eo,Se(2)];return`hsla(${d.getComponents("hsl").map((g,S)=>o[S](g)).join(", ")})`}function Su(d,o){const c=Se(o==="float"?2:0),g=["r","g","b"];return`{${yi(d.getComponents("rgb",o)).map((k,X)=>`${g[X]}: ${c(k)}`).join(", ")}}`}function Cm(d){return o=>Su(o,d)}function Tu(d,o){const c=Se(2),g=Se(o==="float"?2:0),S=["r","g","b","a"];return`{${d.getComponents("rgb",o).map((X,st)=>{const Ct=st===3?c:g;return`${S[st]}: ${Ct(X)}`}).join(", ")}}`}function Pm(d){return o=>Tu(o,d)}const Lm=[{format:{alpha:!1,mode:"rgb",notation:"hex",type:"int"},stringifier:Mu},{format:{alpha:!0,mode:"rgb",notation:"hex",type:"int"},stringifier:Na},{format:{alpha:!1,mode:"hsl",notation:"func",type:"int"},stringifier:Tm},{format:{alpha:!0,mode:"hsl",notation:"func",type:"int"},stringifier:Am},...["int","float"].reduce((d,o)=>[...d,{format:{alpha:!1,mode:"rgb",notation:"func",type:o},stringifier:Em(o)},{format:{alpha:!0,mode:"rgb",notation:"func",type:o},stringifier:Sm(o)},{format:{alpha:!1,mode:"rgb",notation:"object",type:o},stringifier:Cm(o)},{format:{alpha:!0,mode:"rgb",notation:"object",type:o},stringifier:Pm(o)}],[])];function Fa(d){return Lm.reduce((o,c)=>o||(vm(c.format,d)?c.stringifier:null),null)}const tr=M("apl");class Rm{constructor(o,c){this.onValueChange_=this.onValueChange_.bind(this),this.value=c.value,this.value.emitter.on("change",this.onValueChange_),this.element=o.createElement("div"),this.element.classList.add(tr()),c.viewProps.bindTabIndex(this.element);const g=o.createElement("div");g.classList.add(tr("b")),this.element.appendChild(g);const S=o.createElement("div");S.classList.add(tr("c")),g.appendChild(S),this.colorElem_=S;const k=o.createElement("div");k.classList.add(tr("m")),this.element.appendChild(k),this.markerElem_=k;const X=o.createElement("div");X.classList.add(tr("p")),this.markerElem_.appendChild(X),this.previewElem_=X,this.update_()}update_(){const o=this.value.rawValue,c=o.getComponents("rgb"),g=new zt([c[0],c[1],c[2],0],"rgb"),S=new zt([c[0],c[1],c[2],255],"rgb"),k=["to right",ao(g),ao(S)];this.colorElem_.style.background=`linear-gradient(${k.join(",")})`,this.previewElem_.style.backgroundColor=ao(o);const X=le(c[3],0,1,0,100);this.markerElem_.style.left=`${X}%`}onValueChange_(){this.update_()}}class Im{constructor(o,c){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=c.value,this.viewProps=c.viewProps,this.view=new Rm(o,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new _i(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(o,c){if(!o.point)return;const g=o.point.x/o.bounds.width,S=this.value.rawValue,[k,X,st]=S.getComponents("hsv");this.value.setRawValue(new zt([k,X,st,g],"hsv"),c)}onPointerDown_(o){this.handlePointerEvent_(o.data,{forceEmit:!1,last:!1})}onPointerMove_(o){this.handlePointerEvent_(o.data,{forceEmit:!1,last:!1})}onPointerUp_(o){this.handlePointerEvent_(o.data,{forceEmit:!0,last:!0})}onKeyDown_(o){const c=Be(bi(!0),An(o));if(c===0)return;const g=this.value.rawValue,[S,k,X,st]=g.getComponents("hsv");this.value.setRawValue(new zt([S,k,X,st+c],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(o){Be(bi(!0),An(o))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const qi=M("coltxt");function Dm(d){const o=d.createElement("select"),c=[{text:"RGB",value:"rgb"},{text:"HSL",value:"hsl"},{text:"HSV",value:"hsv"}];return o.appendChild(c.reduce((g,S)=>{const k=d.createElement("option");return k.textContent=S.text,k.value=S.value,g.appendChild(k),g},d.createDocumentFragment())),o}class Nm{constructor(o,c){this.element=o.createElement("div"),this.element.classList.add(qi());const g=o.createElement("div");g.classList.add(qi("m")),this.modeElem_=Dm(o),this.modeElem_.classList.add(qi("ms")),g.appendChild(this.modeSelectElement);const S=o.createElement("div");S.classList.add(qi("mm")),S.appendChild(R(o,"dropdown")),g.appendChild(S),this.element.appendChild(g);const k=o.createElement("div");k.classList.add(qi("w")),this.element.appendChild(k),this.textsElem_=k,this.textViews_=c.textViews,this.applyTextViews_(),E(c.colorMode,X=>{this.modeElem_.value=X})}get modeSelectElement(){return this.modeElem_}get textViews(){return this.textViews_}set textViews(o){this.textViews_=o,this.applyTextViews_()}applyTextViews_(){gt(this.textsElem_);const o=this.element.ownerDocument;this.textViews_.forEach(c=>{const g=o.createElement("div");g.classList.add(qi("c")),g.appendChild(c.element),this.textsElem_.appendChild(g)})}}function Fm(d){return Se(d==="float"?2:0)}function km(d,o,c){const g=ro(d,o)[c];return new Wi({min:0,max:g})}function ka(d,o,c){return new Js(d,{arrayPosition:c===0?"fst":c===3-1?"lst":"mid",baseStep:bi(!1),parser:o.parser,props:j.fromObject({draggingScale:o.colorType==="float"?.01:1,formatter:Fm(o.colorType)}),value:B(0,{constraint:km(o.colorMode,o.colorType,c)}),viewProps:o.viewProps})}class Bm{constructor(o,c){this.onModeSelectChange_=this.onModeSelectChange_.bind(this),this.colorType_=c.colorType,this.parser_=c.parser,this.value=c.value,this.viewProps=c.viewProps,this.colorMode=B(this.value.rawValue.mode),this.ccs_=this.createComponentControllers_(o),this.view=new Nm(o,{colorMode:this.colorMode,textViews:[this.ccs_[0].view,this.ccs_[1].view,this.ccs_[2].view]}),this.view.modeSelectElement.addEventListener("change",this.onModeSelectChange_)}createComponentControllers_(o){const c={colorMode:this.colorMode.rawValue,colorType:this.colorType_,parser:this.parser_,viewProps:this.viewProps},g=[ka(o,c,0),ka(o,c,1),ka(o,c,2)];return g.forEach((S,k)=>{Ks({primary:this.value,secondary:S.value,forward:X=>X.rawValue.getComponents(this.colorMode.rawValue,this.colorType_)[k],backward:(X,st)=>{const Ct=this.colorMode.rawValue,Bt=X.rawValue.getComponents(Ct,this.colorType_);return Bt[k]=st.rawValue,new zt(su(yi(Bt),Bt[3]),Ct,this.colorType_)}})}),g}onModeSelectChange_(o){const c=o.currentTarget;this.colorMode.rawValue=c.value,this.ccs_=this.createComponentControllers_(this.view.element.ownerDocument),this.view.textViews=[this.ccs_[0].view,this.ccs_[1].view,this.ccs_[2].view]}}const Ba=M("hpl");class Om{constructor(o,c){this.onValueChange_=this.onValueChange_.bind(this),this.value=c.value,this.value.emitter.on("change",this.onValueChange_),this.element=o.createElement("div"),this.element.classList.add(Ba()),c.viewProps.bindTabIndex(this.element);const g=o.createElement("div");g.classList.add(Ba("c")),this.element.appendChild(g);const S=o.createElement("div");S.classList.add(Ba("m")),this.element.appendChild(S),this.markerElem_=S,this.update_()}update_(){const o=this.value.rawValue,[c]=o.getComponents("hsv");this.markerElem_.style.backgroundColor=Eu(new zt([c,100,100],"hsv"));const g=le(c,0,360,0,100);this.markerElem_.style.left=`${g}%`}onValueChange_(){this.update_()}}class Vm{constructor(o,c){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=c.value,this.viewProps=c.viewProps,this.view=new Om(o,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new _i(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(o,c){if(!o.point)return;const g=le(xe(o.point.x,0,o.bounds.width),0,o.bounds.width,0,359),S=this.value.rawValue,[,k,X,st]=S.getComponents("hsv");this.value.setRawValue(new zt([g,k,X,st],"hsv"),c)}onPointerDown_(o){this.handlePointerEvent_(o.data,{forceEmit:!1,last:!1})}onPointerMove_(o){this.handlePointerEvent_(o.data,{forceEmit:!1,last:!1})}onPointerUp_(o){this.handlePointerEvent_(o.data,{forceEmit:!0,last:!0})}onKeyDown_(o){const c=Be(bi(!1),An(o));if(c===0)return;const g=this.value.rawValue,[S,k,X,st]=g.getComponents("hsv");this.value.setRawValue(new zt([S+c,k,X,st],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(o){Be(bi(!1),An(o))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const Oa=M("svp"),Au=64;class zm{constructor(o,c){this.onValueChange_=this.onValueChange_.bind(this),this.value=c.value,this.value.emitter.on("change",this.onValueChange_),this.element=o.createElement("div"),this.element.classList.add(Oa()),c.viewProps.bindTabIndex(this.element);const g=o.createElement("canvas");g.height=Au,g.width=Au,g.classList.add(Oa("c")),this.element.appendChild(g),this.canvasElement=g;const S=o.createElement("div");S.classList.add(Oa("m")),this.element.appendChild(S),this.markerElem_=S,this.update_()}update_(){const o=_t(this.canvasElement);if(!o)return;const g=this.value.rawValue.getComponents("hsv"),S=this.canvasElement.width,k=this.canvasElement.height,X=o.getImageData(0,0,S,k),st=X.data;for(let Kt=0;Kt<k;Kt++)for(let $t=0;$t<S;$t++){const Pn=le($t,0,S,0,100),nr=le(Kt,0,k,100,0),ir=iu(g[0],Pn,nr),$i=(Kt*S+$t)*4;st[$i]=ir[0],st[$i+1]=ir[1],st[$i+2]=ir[2],st[$i+3]=255}o.putImageData(X,0,0);const Ct=le(g[1],0,100,0,100);this.markerElem_.style.left=`${Ct}%`;const Bt=le(g[2],0,100,100,0);this.markerElem_.style.top=`${Bt}%`}onValueChange_(){this.update_()}}class Um{constructor(o,c){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=c.value,this.viewProps=c.viewProps,this.view=new zm(o,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new _i(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(o,c){if(!o.point)return;const g=le(o.point.x,0,o.bounds.width,0,100),S=le(o.point.y,0,o.bounds.height,100,0),[k,,,X]=this.value.rawValue.getComponents("hsv");this.value.setRawValue(new zt([k,g,S,X],"hsv"),c)}onPointerDown_(o){this.handlePointerEvent_(o.data,{forceEmit:!1,last:!1})}onPointerMove_(o){this.handlePointerEvent_(o.data,{forceEmit:!1,last:!1})}onPointerUp_(o){this.handlePointerEvent_(o.data,{forceEmit:!0,last:!0})}onKeyDown_(o){Jc(o.key)&&o.preventDefault();const[c,g,S,k]=this.value.rawValue.getComponents("hsv"),X=bi(!1),st=Be(X,An(o)),Ct=Be(X,$s(o));st===0&&Ct===0||this.value.setRawValue(new zt([c,g+st,S+Ct,k],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(o){const c=bi(!1),g=Be(c,An(o)),S=Be(c,$s(o));g===0&&S===0||this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}class Hm{constructor(o,c){this.value=c.value,this.viewProps=c.viewProps,this.hPaletteC_=new Vm(o,{value:this.value,viewProps:this.viewProps}),this.svPaletteC_=new Um(o,{value:this.value,viewProps:this.viewProps}),this.alphaIcs_=c.supportsAlpha?{palette:new Im(o,{value:this.value,viewProps:this.viewProps}),text:new Js(o,{parser:Tn,baseStep:.1,props:j.fromObject({draggingScale:.01,formatter:Se(2)}),value:B(0,{constraint:new Wi({min:0,max:1})}),viewProps:this.viewProps})}:null,this.alphaIcs_&&Ks({primary:this.value,secondary:this.alphaIcs_.text.value,forward:g=>g.rawValue.getComponents()[3],backward:(g,S)=>{const k=g.rawValue.getComponents();return k[3]=S.rawValue,new zt(k,g.rawValue.mode)}}),this.textC_=new Bm(o,{colorType:c.colorType,parser:Tn,value:this.value,viewProps:this.viewProps}),this.view=new mm(o,{alphaViews:this.alphaIcs_?{palette:this.alphaIcs_.palette.view,text:this.alphaIcs_.text.view}:null,hPaletteView:this.hPaletteC_.view,supportsAlpha:c.supportsAlpha,svPaletteView:this.svPaletteC_.view,textView:this.textC_.view})}get textController(){return this.textC_}}const Va=M("colsw");class Gm{constructor(o,c){this.onValueChange_=this.onValueChange_.bind(this),c.value.emitter.on("change",this.onValueChange_),this.value=c.value,this.element=o.createElement("div"),this.element.classList.add(Va()),c.viewProps.bindClassModifiers(this.element);const g=o.createElement("div");g.classList.add(Va("sw")),this.element.appendChild(g),this.swatchElem_=g;const S=o.createElement("button");S.classList.add(Va("b")),c.viewProps.bindDisabled(S),this.element.appendChild(S),this.buttonElement=S,this.update_()}update_(){const o=this.value.rawValue;this.swatchElem_.style.backgroundColor=Na(o)}onValueChange_(){this.update_()}}class Wm{constructor(o,c){this.value=c.value,this.viewProps=c.viewProps,this.view=new Gm(o,{value:this.value,viewProps:this.viewProps})}}class za{constructor(o,c){this.onButtonBlur_=this.onButtonBlur_.bind(this),this.onButtonClick_=this.onButtonClick_.bind(this),this.onPopupChildBlur_=this.onPopupChildBlur_.bind(this),this.onPopupChildKeydown_=this.onPopupChildKeydown_.bind(this),this.value=c.value,this.viewProps=c.viewProps,this.foldable_=dt.create(c.expanded),this.swatchC_=new Wm(o,{value:this.value,viewProps:this.viewProps});const g=this.swatchC_.view.buttonElement;g.addEventListener("blur",this.onButtonBlur_),g.addEventListener("click",this.onButtonClick_),this.textC_=new to(o,{parser:c.parser,props:j.fromObject({formatter:c.formatter}),value:this.value,viewProps:this.viewProps}),this.view=new om(o,{foldable:this.foldable_,pickerLayout:c.pickerLayout}),this.view.swatchElement.appendChild(this.swatchC_.view.element),this.view.textElement.appendChild(this.textC_.view.element),this.popC_=c.pickerLayout==="popup"?new Hc(o,{viewProps:this.viewProps}):null;const S=new Hm(o,{colorType:c.colorType,supportsAlpha:c.supportsAlpha,value:this.value,viewProps:this.viewProps});S.view.allFocusableElements.forEach(k=>{k.addEventListener("blur",this.onPopupChildBlur_),k.addEventListener("keydown",this.onPopupChildKeydown_)}),this.pickerC_=S,this.popC_?(this.view.element.appendChild(this.popC_.view.element),this.popC_.view.element.appendChild(S.view.element),Ks({primary:this.foldable_.value("expanded"),secondary:this.popC_.shows,forward:k=>k.rawValue,backward:(k,X)=>X.rawValue})):this.view.pickerElement&&(this.view.pickerElement.appendChild(this.pickerC_.view.element),ge(this.foldable_,this.view.pickerElement))}get textController(){return this.textC_}onButtonBlur_(o){if(!this.popC_)return;const c=this.view.element,g=o.relatedTarget;(!g||!c.contains(g))&&(this.popC_.shows.rawValue=!1)}onButtonClick_(){this.foldable_.set("expanded",!this.foldable_.get("expanded")),this.foldable_.get("expanded")&&this.pickerC_.view.allFocusableElements[0].focus()}onPopupChildBlur_(o){if(!this.popC_)return;const c=this.popC_.view.element,g=Pt(o);g&&c.contains(g)||g&&g===this.swatchC_.view.buttonElement&&!et(c.ownerDocument)||(this.popC_.shows.rawValue=!1)}onPopupChildKeydown_(o){this.popC_?o.key==="Escape"&&(this.popC_.shows.rawValue=!1):this.view.pickerElement&&o.key==="Escape"&&this.swatchC_.view.buttonElement.focus()}}function jm(d,o){return zt.isColorObject(d)?zt.fromObject(d,o):zt.black(o)}function Xm(d){return yi(d.getComponents("rgb")).reduce((o,c)=>o<<8|Math.floor(c)&255,0)}function qm(d){return d.getComponents("rgb").reduce((o,c,g)=>{const S=Math.floor(g===3?c*255:c)&255;return o<<8|S},0)>>>0}function Ym(d){return new zt([d>>16&255,d>>8&255,d&255],"rgb")}function Zm(d){return new zt([d>>24&255,d>>16&255,d>>8&255,le(d&255,0,255,0,1)],"rgb")}function Km(d){return typeof d!="number"?zt.black():Ym(d)}function $m(d){return typeof d!="number"?zt.black():Zm(d)}function Jm(d){const o=Fa(d);return o?(c,g)=>{Qs(c,o(g))}:null}function Qm(d){const o=d?qm:Xm;return(c,g)=>{Qs(c,o(g))}}function tg(d,o,c){const g=o.toRgbaObject(c);d.writeProperty("r",g.r),d.writeProperty("g",g.g),d.writeProperty("b",g.b),d.writeProperty("a",g.a)}function eg(d,o,c){const g=o.toRgbaObject(c);d.writeProperty("r",g.r),d.writeProperty("g",g.g),d.writeProperty("b",g.b)}function ng(d,o){return(c,g)=>{d?tg(c,g,o):eg(c,g,o)}}function Ua(d){var o;return!!((d==null?void 0:d.alpha)||((o=d==null?void 0:d.color)===null||o===void 0?void 0:o.alpha))}function ig(d){return d?o=>Na(o,"0x"):o=>Mu(o,"0x")}function sg(d){return"color"in d||"view"in d&&d.view==="color"}const rg={id:"input-color-number",type:"input",accept:(d,o)=>{if(typeof d!="number"||!sg(o))return null;const c=Ra(o);return c?{initialValue:d,params:c}:null},binding:{reader:d=>Ua(d.params)?$m:Km,equals:zt.equals,writer:d=>Qm(Ua(d.params))},controller:d=>{const o=Ua(d.params),c="expanded"in d.params?d.params.expanded:void 0,g="picker"in d.params?d.params.picker:void 0;return new za(d.document,{colorType:"int",expanded:c!=null?c:!1,formatter:ig(o),parser:Da("int"),pickerLayout:g!=null?g:"popup",supportsAlpha:o,value:d.value,viewProps:d.viewProps})}};function og(d){return zt.isRgbaColorObject(d)}function ag(d){return o=>jm(o,d)}function lg(d,o){return c=>d?Tu(c,o):Su(c,o)}const cg={id:"input-color-object",type:"input",accept:(d,o)=>{if(!zt.isColorObject(d))return null;const c=Ra(o);return c?{initialValue:d,params:c}:null},binding:{reader:d=>ag(wi(d.params)),equals:zt.equals,writer:d=>ng(og(d.initialValue),wi(d.params))},controller:d=>{var o;const c=zt.isRgbaColorObject(d.initialValue),g="expanded"in d.params?d.params.expanded:void 0,S="picker"in d.params?d.params.picker:void 0,k=(o=wi(d.params))!==null&&o!==void 0?o:"int";return new za(d.document,{colorType:k,expanded:g!=null?g:!1,formatter:lg(c,k),parser:Da(k),pickerLayout:S!=null?S:"popup",supportsAlpha:c,value:d.value,viewProps:d.viewProps})}},ug={id:"input-color-string",type:"input",accept:(d,o)=>{if(typeof d!="string"||"view"in o&&o.view==="text")return null;const c=Ia(d,wi(o));if(!c||!Fa(c))return null;const S=Ra(o);return S?{initialValue:d,params:S}:null},binding:{reader:d=>{var o;return Mm((o=wi(d.params))!==null&&o!==void 0?o:"int")},equals:zt.equals,writer:d=>{const o=Ia(d.initialValue,wi(d.params));if(!o)throw x.shouldNeverHappen();const c=Jm(o);if(!c)throw x.notBindable();return c}},controller:d=>{const o=Ia(d.initialValue,wi(d.params));if(!o)throw x.shouldNeverHappen();const c=Fa(o);if(!c)throw x.shouldNeverHappen();const g="expanded"in d.params?d.params.expanded:void 0,S="picker"in d.params?d.params.picker:void 0;return new za(d.document,{colorType:o.type,expanded:g!=null?g:!1,formatter:c,parser:Da(o.type),pickerLayout:S!=null?S:"popup",supportsAlpha:o.alpha,value:d.value,viewProps:d.viewProps})}};class jn{constructor(o){this.components=o.components,this.asm_=o.assembly}constrain(o){const c=this.asm_.toComponents(o).map((g,S)=>{var k,X;return(X=(k=this.components[S])===null||k===void 0?void 0:k.constrain(g))!==null&&X!==void 0?X:g});return this.asm_.fromComponents(c)}}const Cu=M("pndtxt");class hg{constructor(o,c){this.textViews=c.textViews,this.element=o.createElement("div"),this.element.classList.add(Cu()),this.textViews.forEach(g=>{const S=o.createElement("div");S.classList.add(Cu("a")),S.appendChild(g.element),this.element.appendChild(S)})}}function dg(d,o,c){return new Js(d,{arrayPosition:c===0?"fst":c===o.axes.length-1?"lst":"mid",baseStep:o.axes[c].baseStep,parser:o.parser,props:o.axes[c].textProps,value:B(0,{constraint:o.axes[c].constraint}),viewProps:o.viewProps})}class Ha{constructor(o,c){this.value=c.value,this.viewProps=c.viewProps,this.acs_=c.axes.map((g,S)=>dg(o,c,S)),this.acs_.forEach((g,S)=>{Ks({primary:this.value,secondary:g.value,forward:k=>c.assembly.toComponents(k.rawValue)[S],backward:(k,X)=>{const st=c.assembly.toComponents(k.rawValue);return st[S]=X.rawValue,c.assembly.fromComponents(st)}})}),this.view=new hg(o,{textViews:this.acs_.map(g=>g.view)})}}function Pu(d,o){return"step"in d&&!f(d.step)?new Qr(d.step,o):null}function Lu(d){return"max"in d&&!f(d.max)||"min"in d&&!f(d.min)?new Wi({max:d.max,min:d.min}):null}function pg(d,o){const c=[],g=Pu(d,o);g&&c.push(g);const S=Lu(d);S&&c.push(S);const k=Pa(d.options);return k&&c.push(k),new js(c)}function fg(d){const o=d?hn(d,Wi):null;return o?[o.minValue,o.maxValue]:[void 0,void 0]}function mg(d){const[o,c]=fg(d);return[o!=null?o:0,c!=null?c:100]}const gg={id:"input-number",type:"input",accept:(d,o)=>{if(typeof d!="number")return null;const c=ct,g=ft(o,{format:c.optional.function,max:c.optional.number,min:c.optional.number,options:c.optional.custom(no),step:c.optional.number});return g?{initialValue:d,params:g}:null},binding:{reader:d=>Zc,constraint:d=>pg(d.params,d.initialValue),writer:d=>Qs},controller:d=>{var o,c;const g=d.value,S=d.constraint;if(S&&hn(S,Xs))return new qs(d.document,{props:j.fromObject({options:(o=La(S))!==null&&o!==void 0?o:[]}),value:g,viewProps:d.viewProps});const k=(c="format"in d.params?d.params.format:void 0)!==null&&c!==void 0?c:Se(io(S,g.rawValue));if(S&&hn(S,Wi)){const[X,st]=mg(S);return new Ca(d.document,{baseStep:ji(S),parser:Tn,sliderProps:j.fromObject({maxValue:st,minValue:X}),textProps:j.fromObject({draggingScale:Xi(S,g.rawValue),formatter:k}),value:g,viewProps:d.viewProps})}return new Js(d.document,{baseStep:ji(S),parser:Tn,props:j.fromObject({draggingScale:Xi(S,g.rawValue),formatter:k}),value:g,viewProps:d.viewProps})}};class Xn{constructor(o=0,c=0){this.x=o,this.y=c}getComponents(){return[this.x,this.y]}static isObject(o){if(f(o))return!1;const c=o.x,g=o.y;return!(typeof c!="number"||typeof g!="number")}static equals(o,c){return o.x===c.x&&o.y===c.y}toObject(){return{x:this.x,y:this.y}}}const Ru={toComponents:d=>d.getComponents(),fromComponents:d=>new Xn(...d)},Yi=M("p2d");class vg{constructor(o,c){this.element=o.createElement("div"),this.element.classList.add(Yi()),c.viewProps.bindClassModifiers(this.element),E(c.expanded,N(this.element,Yi(void 0,"expanded")));const g=o.createElement("div");g.classList.add(Yi("h")),this.element.appendChild(g);const S=o.createElement("button");S.classList.add(Yi("b")),S.appendChild(R(o,"p2dpad")),c.viewProps.bindDisabled(S),g.appendChild(S),this.buttonElement=S;const k=o.createElement("div");if(k.classList.add(Yi("t")),g.appendChild(k),this.textElement=k,c.pickerLayout==="inline"){const X=o.createElement("div");X.classList.add(Yi("p")),this.element.appendChild(X),this.pickerElement=X}else this.pickerElement=null}}const qn=M("p2dp");class _g{constructor(o,c){this.onFoldableChange_=this.onFoldableChange_.bind(this),this.onValueChange_=this.onValueChange_.bind(this),this.invertsY_=c.invertsY,this.maxValue_=c.maxValue,this.element=o.createElement("div"),this.element.classList.add(qn()),c.layout==="popup"&&this.element.classList.add(qn(void 0,"p"));const g=o.createElement("div");g.classList.add(qn("p")),c.viewProps.bindTabIndex(g),this.element.appendChild(g),this.padElement=g;const S=o.createElementNS(bt,"svg");S.classList.add(qn("g")),this.padElement.appendChild(S),this.svgElem_=S;const k=o.createElementNS(bt,"line");k.classList.add(qn("ax")),k.setAttributeNS(null,"x1","0"),k.setAttributeNS(null,"y1","50%"),k.setAttributeNS(null,"x2","100%"),k.setAttributeNS(null,"y2","50%"),this.svgElem_.appendChild(k);const X=o.createElementNS(bt,"line");X.classList.add(qn("ax")),X.setAttributeNS(null,"x1","50%"),X.setAttributeNS(null,"y1","0"),X.setAttributeNS(null,"x2","50%"),X.setAttributeNS(null,"y2","100%"),this.svgElem_.appendChild(X);const st=o.createElementNS(bt,"line");st.classList.add(qn("l")),st.setAttributeNS(null,"x1","50%"),st.setAttributeNS(null,"y1","50%"),this.svgElem_.appendChild(st),this.lineElem_=st;const Ct=o.createElement("div");Ct.classList.add(qn("m")),this.padElement.appendChild(Ct),this.markerElem_=Ct,c.value.emitter.on("change",this.onValueChange_),this.value=c.value,this.update_()}get allFocusableElements(){return[this.padElement]}update_(){const[o,c]=this.value.rawValue.getComponents(),g=this.maxValue_,S=le(o,-g,+g,0,100),k=le(c,-g,+g,0,100),X=this.invertsY_?100-k:k;this.lineElem_.setAttributeNS(null,"x2",`${S}%`),this.lineElem_.setAttributeNS(null,"y2",`${X}%`),this.markerElem_.style.left=`${S}%`,this.markerElem_.style.top=`${X}%`}onValueChange_(){this.update_()}onFoldableChange_(){this.update_()}}function Iu(d,o,c){return[Be(o[0],An(d)),Be(o[1],$s(d))*(c?1:-1)]}class xg{constructor(o,c){this.onPadKeyDown_=this.onPadKeyDown_.bind(this),this.onPadKeyUp_=this.onPadKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=c.value,this.viewProps=c.viewProps,this.baseSteps_=c.baseSteps,this.maxValue_=c.maxValue,this.invertsY_=c.invertsY,this.view=new _g(o,{invertsY:this.invertsY_,layout:c.layout,maxValue:this.maxValue_,value:this.value,viewProps:this.viewProps}),this.ptHandler_=new _i(this.view.padElement),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.padElement.addEventListener("keydown",this.onPadKeyDown_),this.view.padElement.addEventListener("keyup",this.onPadKeyUp_)}handlePointerEvent_(o,c){if(!o.point)return;const g=this.maxValue_,S=le(o.point.x,0,o.bounds.width,-g,+g),k=le(this.invertsY_?o.bounds.height-o.point.y:o.point.y,0,o.bounds.height,-g,+g);this.value.setRawValue(new Xn(S,k),c)}onPointerDown_(o){this.handlePointerEvent_(o.data,{forceEmit:!1,last:!1})}onPointerMove_(o){this.handlePointerEvent_(o.data,{forceEmit:!1,last:!1})}onPointerUp_(o){this.handlePointerEvent_(o.data,{forceEmit:!0,last:!0})}onPadKeyDown_(o){Jc(o.key)&&o.preventDefault();const[c,g]=Iu(o,this.baseSteps_,this.invertsY_);c===0&&g===0||this.value.setRawValue(new Xn(this.value.rawValue.x+c,this.value.rawValue.y+g),{forceEmit:!1,last:!1})}onPadKeyUp_(o){const[c,g]=Iu(o,this.baseSteps_,this.invertsY_);c===0&&g===0||this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}class yg{constructor(o,c){var g,S;this.onPopupChildBlur_=this.onPopupChildBlur_.bind(this),this.onPopupChildKeydown_=this.onPopupChildKeydown_.bind(this),this.onPadButtonBlur_=this.onPadButtonBlur_.bind(this),this.onPadButtonClick_=this.onPadButtonClick_.bind(this),this.value=c.value,this.viewProps=c.viewProps,this.foldable_=dt.create(c.expanded),this.popC_=c.pickerLayout==="popup"?new Hc(o,{viewProps:this.viewProps}):null;const k=new xg(o,{baseSteps:[c.axes[0].baseStep,c.axes[1].baseStep],invertsY:c.invertsY,layout:c.pickerLayout,maxValue:c.maxValue,value:this.value,viewProps:this.viewProps});k.view.allFocusableElements.forEach(X=>{X.addEventListener("blur",this.onPopupChildBlur_),X.addEventListener("keydown",this.onPopupChildKeydown_)}),this.pickerC_=k,this.textC_=new Ha(o,{assembly:Ru,axes:c.axes,parser:c.parser,value:this.value,viewProps:this.viewProps}),this.view=new vg(o,{expanded:this.foldable_.value("expanded"),pickerLayout:c.pickerLayout,viewProps:this.viewProps}),this.view.textElement.appendChild(this.textC_.view.element),(g=this.view.buttonElement)===null||g===void 0||g.addEventListener("blur",this.onPadButtonBlur_),(S=this.view.buttonElement)===null||S===void 0||S.addEventListener("click",this.onPadButtonClick_),this.popC_?(this.view.element.appendChild(this.popC_.view.element),this.popC_.view.element.appendChild(this.pickerC_.view.element),Ks({primary:this.foldable_.value("expanded"),secondary:this.popC_.shows,forward:X=>X.rawValue,backward:(X,st)=>st.rawValue})):this.view.pickerElement&&(this.view.pickerElement.appendChild(this.pickerC_.view.element),ge(this.foldable_,this.view.pickerElement))}onPadButtonBlur_(o){if(!this.popC_)return;const c=this.view.element,g=o.relatedTarget;(!g||!c.contains(g))&&(this.popC_.shows.rawValue=!1)}onPadButtonClick_(){this.foldable_.set("expanded",!this.foldable_.get("expanded")),this.foldable_.get("expanded")&&this.pickerC_.view.allFocusableElements[0].focus()}onPopupChildBlur_(o){if(!this.popC_)return;const c=this.popC_.view.element,g=Pt(o);g&&c.contains(g)||g&&g===this.view.buttonElement&&!et(c.ownerDocument)||(this.popC_.shows.rawValue=!1)}onPopupChildKeydown_(o){this.popC_?o.key==="Escape"&&(this.popC_.shows.rawValue=!1):this.view.pickerElement&&o.key==="Escape"&&this.view.buttonElement.focus()}}function bg(d){return Xn.isObject(d)?new Xn(d.x,d.y):new Xn}function wg(d,o){d.writeProperty("x",o.x),d.writeProperty("y",o.y)}function Cn(d,o){if(!d)return;const c=[],g=Pu(d,o);g&&c.push(g);const S=Lu(d);return S&&c.push(S),new js(c)}function Mg(d,o){return new jn({assembly:Ru,components:[Cn("x"in d?d.x:void 0,o.x),Cn("y"in d?d.y:void 0,o.y)]})}function Du(d,o){var c,g;const S=d&&hn(d,Wi);if(S)return Math.max(Math.abs((c=S.minValue)!==null&&c!==void 0?c:0),Math.abs((g=S.maxValue)!==null&&g!==void 0?g:0));const k=ji(d);return Math.max(Math.abs(k)*10,Math.abs(o)*10)}function Eg(d,o){const c=o instanceof jn?o.components[0]:void 0,g=o instanceof jn?o.components[1]:void 0,S=Du(c,d.x),k=Du(g,d.y);return Math.max(S,k)}function Nu(d,o){return{baseStep:ji(o),constraint:o,textProps:j.fromObject({draggingScale:Xi(o,d),formatter:Se(io(o,d))})}}function Sg(d){if(!("y"in d))return!1;const o=d.y;return o&&"inverted"in o?!!o.inverted:!1}const Tg={id:"input-point2d",type:"input",accept:(d,o)=>{if(!Xn.isObject(d))return null;const c=ct,g=ft(o,{expanded:c.optional.boolean,picker:c.optional.custom(eu),x:c.optional.custom(Gn),y:c.optional.object({inverted:c.optional.boolean,max:c.optional.number,min:c.optional.number,step:c.optional.number})});return g?{initialValue:d,params:g}:null},binding:{reader:d=>bg,constraint:d=>Mg(d.params,d.initialValue),equals:Xn.equals,writer:d=>wg},controller:d=>{const o=d.document,c=d.value,g=d.constraint;if(!(g instanceof jn))throw x.shouldNeverHappen();const S="expanded"in d.params?d.params.expanded:void 0,k="picker"in d.params?d.params.picker:void 0;return new yg(o,{axes:[Nu(c.rawValue.x,g.components[0]),Nu(c.rawValue.y,g.components[1])],expanded:S!=null?S:!1,invertsY:Sg(d.params),maxValue:Eg(c.rawValue,g),parser:Tn,pickerLayout:k!=null?k:"popup",value:c,viewProps:d.viewProps})}};class Zi{constructor(o=0,c=0,g=0){this.x=o,this.y=c,this.z=g}getComponents(){return[this.x,this.y,this.z]}static isObject(o){if(f(o))return!1;const c=o.x,g=o.y,S=o.z;return!(typeof c!="number"||typeof g!="number"||typeof S!="number")}static equals(o,c){return o.x===c.x&&o.y===c.y&&o.z===c.z}toObject(){return{x:this.x,y:this.y,z:this.z}}}const Fu={toComponents:d=>d.getComponents(),fromComponents:d=>new Zi(...d)};function Ag(d){return Zi.isObject(d)?new Zi(d.x,d.y,d.z):new Zi}function Cg(d,o){d.writeProperty("x",o.x),d.writeProperty("y",o.y),d.writeProperty("z",o.z)}function Pg(d,o){return new jn({assembly:Fu,components:[Cn("x"in d?d.x:void 0,o.x),Cn("y"in d?d.y:void 0,o.y),Cn("z"in d?d.z:void 0,o.z)]})}function Ga(d,o){return{baseStep:ji(o),constraint:o,textProps:j.fromObject({draggingScale:Xi(o,d),formatter:Se(io(o,d))})}}const Lg={id:"input-point3d",type:"input",accept:(d,o)=>{if(!Zi.isObject(d))return null;const c=ct,g=ft(o,{x:c.optional.custom(Gn),y:c.optional.custom(Gn),z:c.optional.custom(Gn)});return g?{initialValue:d,params:g}:null},binding:{reader:d=>Ag,constraint:d=>Pg(d.params,d.initialValue),equals:Zi.equals,writer:d=>Cg},controller:d=>{const o=d.value,c=d.constraint;if(!(c instanceof jn))throw x.shouldNeverHappen();return new Ha(d.document,{assembly:Fu,axes:[Ga(o.rawValue.x,c.components[0]),Ga(o.rawValue.y,c.components[1]),Ga(o.rawValue.z,c.components[2])],parser:Tn,value:o,viewProps:d.viewProps})}};class Ki{constructor(o=0,c=0,g=0,S=0){this.x=o,this.y=c,this.z=g,this.w=S}getComponents(){return[this.x,this.y,this.z,this.w]}static isObject(o){if(f(o))return!1;const c=o.x,g=o.y,S=o.z,k=o.w;return!(typeof c!="number"||typeof g!="number"||typeof S!="number"||typeof k!="number")}static equals(o,c){return o.x===c.x&&o.y===c.y&&o.z===c.z&&o.w===c.w}toObject(){return{x:this.x,y:this.y,z:this.z,w:this.w}}}const ku={toComponents:d=>d.getComponents(),fromComponents:d=>new Ki(...d)};function Rg(d){return Ki.isObject(d)?new Ki(d.x,d.y,d.z,d.w):new Ki}function Ig(d,o){d.writeProperty("x",o.x),d.writeProperty("y",o.y),d.writeProperty("z",o.z),d.writeProperty("w",o.w)}function Dg(d,o){return new jn({assembly:ku,components:[Cn("x"in d?d.x:void 0,o.x),Cn("y"in d?d.y:void 0,o.y),Cn("z"in d?d.z:void 0,o.z),Cn("w"in d?d.w:void 0,o.w)]})}function Ng(d,o){return{baseStep:ji(o),constraint:o,textProps:j.fromObject({draggingScale:Xi(o,d),formatter:Se(io(o,d))})}}const Fg={id:"input-point4d",type:"input",accept:(d,o)=>{if(!Ki.isObject(d))return null;const c=ct,g=ft(o,{x:c.optional.custom(Gn),y:c.optional.custom(Gn),z:c.optional.custom(Gn),w:c.optional.custom(Gn)});return g?{initialValue:d,params:g}:null},binding:{reader:d=>Rg,constraint:d=>Dg(d.params,d.initialValue),equals:Ki.equals,writer:d=>Ig},controller:d=>{const o=d.value,c=d.constraint;if(!(c instanceof jn))throw x.shouldNeverHappen();return new Ha(d.document,{assembly:ku,axes:o.rawValue.getComponents().map((g,S)=>Ng(g,c.components[S])),parser:Tn,value:o,viewProps:d.viewProps})}};function kg(d){const o=[],c=Pa(d.options);return c&&o.push(c),new js(o)}const Bg={id:"input-string",type:"input",accept:(d,o)=>{if(typeof d!="string")return null;const g=ft(o,{options:ct.optional.custom(no)});return g?{initialValue:d,params:g}:null},binding:{reader:d=>Kc,constraint:d=>kg(d.params),writer:d=>Qs},controller:d=>{var o;const c=d.document,g=d.value,S=d.constraint;return S&&hn(S,Xs)?new qs(c,{props:j.fromObject({options:(o=La(S))!==null&&o!==void 0?o:[]}),value:g,viewProps:d.viewProps}):new to(c,{parser:k=>k,props:j.fromObject({formatter:Ea}),value:g,viewProps:d.viewProps})}},er={monitor:{defaultInterval:200,defaultLineCount:3}},Bu=M("mll");class Og{constructor(o,c){this.onValueUpdate_=this.onValueUpdate_.bind(this),this.formatter_=c.formatter,this.element=o.createElement("div"),this.element.classList.add(Bu()),c.viewProps.bindClassModifiers(this.element);const g=o.createElement("textarea");g.classList.add(Bu("i")),g.style.height=`calc(var(--bld-us) * ${c.lineCount})`,g.readOnly=!0,c.viewProps.bindDisabled(g),this.element.appendChild(g),this.textareaElem_=g,c.value.emitter.on("change",this.onValueUpdate_),this.value=c.value,this.update_()}update_(){const o=this.textareaElem_,c=o.scrollTop===o.scrollHeight-o.clientHeight,g=[];this.value.rawValue.forEach(S=>{S!==void 0&&g.push(this.formatter_(S))}),o.textContent=g.join(`
`),c&&(o.scrollTop=o.scrollHeight)}onValueUpdate_(){this.update_()}}class Wa{constructor(o,c){this.value=c.value,this.viewProps=c.viewProps,this.view=new Og(o,{formatter:c.formatter,lineCount:c.lineCount,value:this.value,viewProps:this.viewProps})}}const Ou=M("sgl");class Vg{constructor(o,c){this.onValueUpdate_=this.onValueUpdate_.bind(this),this.formatter_=c.formatter,this.element=o.createElement("div"),this.element.classList.add(Ou()),c.viewProps.bindClassModifiers(this.element);const g=o.createElement("input");g.classList.add(Ou("i")),g.readOnly=!0,g.type="text",c.viewProps.bindDisabled(g),this.element.appendChild(g),this.inputElement=g,c.value.emitter.on("change",this.onValueUpdate_),this.value=c.value,this.update_()}update_(){const o=this.value.rawValue,c=o[o.length-1];this.inputElement.value=c!==void 0?this.formatter_(c):""}onValueUpdate_(){this.update_()}}class ja{constructor(o,c){this.value=c.value,this.viewProps=c.viewProps,this.view=new Vg(o,{formatter:c.formatter,value:this.value,viewProps:this.viewProps})}}const zg={id:"monitor-bool",type:"monitor",accept:(d,o)=>{if(typeof d!="boolean")return null;const g=ft(o,{lineCount:ct.optional.number});return g?{initialValue:d,params:g}:null},binding:{reader:d=>Wc},controller:d=>{var o;return d.value.rawValue.length===1?new ja(d.document,{formatter:jc,value:d.value,viewProps:d.viewProps}):new Wa(d.document,{formatter:jc,lineCount:(o=d.params.lineCount)!==null&&o!==void 0?o:er.monitor.defaultLineCount,value:d.value,viewProps:d.viewProps})}},Yn=M("grl");class Ug{constructor(o,c){this.onCursorChange_=this.onCursorChange_.bind(this),this.onValueUpdate_=this.onValueUpdate_.bind(this),this.element=o.createElement("div"),this.element.classList.add(Yn()),c.viewProps.bindClassModifiers(this.element),this.formatter_=c.formatter,this.props_=c.props,this.cursor_=c.cursor,this.cursor_.emitter.on("change",this.onCursorChange_);const g=o.createElementNS(bt,"svg");g.classList.add(Yn("g")),g.style.height=`calc(var(--bld-us) * ${c.lineCount})`,this.element.appendChild(g),this.svgElem_=g;const S=o.createElementNS(bt,"polyline");this.svgElem_.appendChild(S),this.lineElem_=S;const k=o.createElement("div");k.classList.add(Yn("t"),M("tt")()),this.element.appendChild(k),this.tooltipElem_=k,c.value.emitter.on("change",this.onValueUpdate_),this.value=c.value,this.update_()}get graphElement(){return this.svgElem_}update_(){const o=this.svgElem_.getBoundingClientRect(),c=this.value.rawValue.length-1,g=this.props_.get("minValue"),S=this.props_.get("maxValue"),k=[];this.value.rawValue.forEach((Kt,$t)=>{if(Kt===void 0)return;const Pn=le($t,0,c,0,o.width),nr=le(Kt,g,S,o.height,0);k.push([Pn,nr].join(","))}),this.lineElem_.setAttributeNS(null,"points",k.join(" "));const X=this.tooltipElem_,st=this.value.rawValue[this.cursor_.rawValue];if(st===void 0){X.classList.remove(Yn("t","a"));return}const Ct=le(this.cursor_.rawValue,0,c,0,o.width),Bt=le(st,g,S,o.height,0);X.style.left=`${Ct}px`,X.style.top=`${Bt}px`,X.textContent=`${this.formatter_(st)}`,X.classList.contains(Yn("t","a"))||(X.classList.add(Yn("t","a"),Yn("t","in")),Nt(X),X.classList.remove(Yn("t","in")))}onValueUpdate_(){this.update_()}onCursorChange_(){this.update_()}}class Hg{constructor(o,c){if(this.onGraphMouseMove_=this.onGraphMouseMove_.bind(this),this.onGraphMouseLeave_=this.onGraphMouseLeave_.bind(this),this.onGraphPointerDown_=this.onGraphPointerDown_.bind(this),this.onGraphPointerMove_=this.onGraphPointerMove_.bind(this),this.onGraphPointerUp_=this.onGraphPointerUp_.bind(this),this.props_=c.props,this.value=c.value,this.viewProps=c.viewProps,this.cursor_=B(-1),this.view=new Ug(o,{cursor:this.cursor_,formatter:c.formatter,lineCount:c.lineCount,props:this.props_,value:this.value,viewProps:this.viewProps}),!et(o))this.view.element.addEventListener("mousemove",this.onGraphMouseMove_),this.view.element.addEventListener("mouseleave",this.onGraphMouseLeave_);else{const g=new _i(this.view.element);g.emitter.on("down",this.onGraphPointerDown_),g.emitter.on("move",this.onGraphPointerMove_),g.emitter.on("up",this.onGraphPointerUp_)}}onGraphMouseLeave_(){this.cursor_.rawValue=-1}onGraphMouseMove_(o){const c=this.view.element.getBoundingClientRect();this.cursor_.rawValue=Math.floor(le(o.offsetX,0,c.width,0,this.value.rawValue.length))}onGraphPointerDown_(o){this.onGraphPointerMove_(o)}onGraphPointerMove_(o){if(!o.data.point){this.cursor_.rawValue=-1;return}this.cursor_.rawValue=Math.floor(le(o.data.point.x,0,o.data.bounds.width,0,this.value.rawValue.length))}onGraphPointerUp_(){this.cursor_.rawValue=-1}}function Xa(d){return"format"in d&&!f(d.format)?d.format:Se(2)}function Gg(d){var o;return d.value.rawValue.length===1?new ja(d.document,{formatter:Xa(d.params),value:d.value,viewProps:d.viewProps}):new Wa(d.document,{formatter:Xa(d.params),lineCount:(o=d.params.lineCount)!==null&&o!==void 0?o:er.monitor.defaultLineCount,value:d.value,viewProps:d.viewProps})}function Wg(d){var o,c,g;return new Hg(d.document,{formatter:Xa(d.params),lineCount:(o=d.params.lineCount)!==null&&o!==void 0?o:er.monitor.defaultLineCount,props:j.fromObject({maxValue:(c="max"in d.params?d.params.max:null)!==null&&c!==void 0?c:100,minValue:(g="min"in d.params?d.params.min:null)!==null&&g!==void 0?g:0}),value:d.value,viewProps:d.viewProps})}function Vu(d){return"view"in d&&d.view==="graph"}const jg={id:"monitor-number",type:"monitor",accept:(d,o)=>{if(typeof d!="number")return null;const c=ct,g=ft(o,{format:c.optional.function,lineCount:c.optional.number,max:c.optional.number,min:c.optional.number,view:c.optional.string});return g?{initialValue:d,params:g}:null},binding:{defaultBufferSize:d=>Vu(d)?64:1,reader:d=>Zc},controller:d=>Vu(d.params)?Wg(d):Gg(d)},Xg={id:"monitor-string",type:"monitor",accept:(d,o)=>{if(typeof d!="string")return null;const c=ct,g=ft(o,{lineCount:c.optional.number,multiline:c.optional.boolean});return g?{initialValue:d,params:g}:null},binding:{reader:d=>Kc},controller:d=>{var o;const c=d.value;return c.rawValue.length>1||"multiline"in d.params&&d.params.multiline?new Wa(d.document,{formatter:Ea,lineCount:(o=d.params.lineCount)!==null&&o!==void 0?o:er.monitor.defaultLineCount,value:c,viewProps:d.viewProps}):new ja(d.document,{formatter:Ea,value:c,viewProps:d.viewProps})}};class qg{constructor(o){this.onValueChange_=this.onValueChange_.bind(this),this.reader=o.reader,this.writer=o.writer,this.emitter=new _,this.value=o.value,this.value.emitter.on("change",this.onValueChange_),this.target=o.target,this.read()}read(){const o=this.target.read();o!==void 0&&(this.value.rawValue=this.reader(o))}write_(o){this.writer(this.target,o)}onValueChange_(o){this.write_(o.rawValue),this.emitter.emit("change",{options:o.options,rawValue:o.rawValue,sender:this})}}function Yg(d,o){const c=d.accept(o.target.read(),o.params);if(f(c))return null;const g=ct,S={target:o.target,initialValue:c.initialValue,params:c.params},k=d.binding.reader(S),X=d.binding.constraint?d.binding.constraint(S):void 0,st=B(k(c.initialValue),{constraint:X,equals:d.binding.equals}),Ct=new qg({reader:k,target:o.target,value:st,writer:d.binding.writer(S)}),Bt=g.optional.boolean(o.params.disabled).value,Kt=g.optional.boolean(o.params.hidden).value,$t=d.controller({constraint:X,document:o.document,initialValue:c.initialValue,params:c.params,value:Ct.value,viewProps:cn.create({disabled:Bt,hidden:Kt})}),Pn=g.optional.string(o.params.label).value;return new be(o.document,{binding:Ct,blade:St(),props:j.fromObject({label:Pn!=null?Pn:o.target.key}),valueController:$t})}class Zg{constructor(o){this.onTick_=this.onTick_.bind(this),this.reader_=o.reader,this.target=o.target,this.emitter=new _,this.value=o.value,this.ticker=o.ticker,this.ticker.emitter.on("tick",this.onTick_),this.read()}dispose(){this.ticker.dispose()}read(){const o=this.target.read();if(o===void 0)return;const c=this.value.rawValue,g=this.reader_(o);this.value.rawValue=Zf(c,g),this.emitter.emit("update",{rawValue:g,sender:this})}onTick_(o){this.read()}}function Kg(d,o){return o===0?new pf:new ff(d,o!=null?o:er.monitor.defaultInterval)}function $g(d,o){var c,g,S;const k=ct,X=d.accept(o.target.read(),o.params);if(f(X))return null;const st={target:o.target,initialValue:X.initialValue,params:X.params},Ct=d.binding.reader(st),Bt=(g=(c=k.optional.number(o.params.bufferSize).value)!==null&&c!==void 0?c:d.binding.defaultBufferSize&&d.binding.defaultBufferSize(X.params))!==null&&g!==void 0?g:1,Kt=k.optional.number(o.params.interval).value,$t=new Zg({reader:Ct,target:o.target,ticker:Kg(o.document,Kt),value:qf(Bt)}),Pn=k.optional.boolean(o.params.disabled).value,nr=k.optional.boolean(o.params.hidden).value,ir=d.controller({document:o.document,params:X.params,value:$t.value,viewProps:cn.create({disabled:Pn,hidden:nr})}),$i=(S=k.optional.string(o.params.label).value)!==null&&S!==void 0?S:o.target.key;return new an(o.document,{binding:$t,blade:St(),props:j.fromObject({label:$i}),valueController:ir})}class Jg{constructor(){this.pluginsMap_={blades:[],inputs:[],monitors:[]}}getAll(){return[...this.pluginsMap_.blades,...this.pluginsMap_.inputs,...this.pluginsMap_.monitors]}register(o){o.type==="blade"?this.pluginsMap_.blades.unshift(o):o.type==="input"?this.pluginsMap_.inputs.unshift(o):o.type==="monitor"&&this.pluginsMap_.monitors.unshift(o)}createInput(o,c,g){const S=c.read();if(f(S))throw new x({context:{key:c.key},type:"nomatchingcontroller"});const k=this.pluginsMap_.inputs.reduce((X,st)=>X!=null?X:Yg(st,{document:o,target:c,params:g}),null);if(k)return k;throw new x({context:{key:c.key},type:"nomatchingcontroller"})}createMonitor(o,c,g){const S=this.pluginsMap_.monitors.reduce((k,X)=>k!=null?k:$g(X,{document:o,params:g,target:c}),null);if(S)return S;throw new x({context:{key:c.key},type:"nomatchingcontroller"})}createBlade(o,c){const g=this.pluginsMap_.blades.reduce((S,k)=>S!=null?S:df(k,{document:o,params:c}),null);if(!g)throw new x({type:"nomatchingview",context:{params:c}});return g}createBladeApi(o){if(o instanceof be)return new Vi(o);if(o instanceof an)return new zi(o);if(o instanceof kt)return new gi(o,this);const c=this.pluginsMap_.blades.reduce((g,S)=>g!=null?g:S.api({controller:o,pool:this}),null);if(!c)throw x.shouldNeverHappen();return c}}function Qg(){const d=new Jg;return[Tg,Lg,Fg,Bg,gg,ug,cg,rg,rm,zg,Xg,jg,at,Gt,fe,zc].forEach(o=>{d.register(o)}),d}class zu extends i{constructor(o){super(o),this.emitter_=new _,this.controller_.valueController.value.emitter.on("change",c=>{this.emitter_.emit("change",{event:new a(this,c.rawValue)})})}get label(){return this.controller_.props.get("label")}set label(o){this.controller_.props.set("label",o)}get options(){return this.controller_.valueController.props.get("options")}set options(o){this.controller_.valueController.props.set("options",o)}get value(){return this.controller_.valueController.value.rawValue}set value(o){this.controller_.valueController.value.rawValue=o}on(o,c){const g=c.bind(this);return this.emitter_.on(o,S=>{g(S.event)}),this}}class Uu extends i{constructor(o){super(o),this.emitter_=new _,this.controller_.valueController.value.emitter.on("change",c=>{this.emitter_.emit("change",{event:new a(this,c.rawValue)})})}get label(){return this.controller_.props.get("label")}set label(o){this.controller_.props.set("label",o)}get maxValue(){return this.controller_.valueController.sliderController.props.get("maxValue")}set maxValue(o){this.controller_.valueController.sliderController.props.set("maxValue",o)}get minValue(){return this.controller_.valueController.sliderController.props.get("minValue")}set minValue(o){this.controller_.valueController.sliderController.props.set("minValue",o)}get value(){return this.controller_.valueController.value.rawValue}set value(o){this.controller_.valueController.value.rawValue=o}on(o,c){const g=c.bind(this);return this.emitter_.on(o,S=>{g(S.event)}),this}}class Hu extends i{constructor(o){super(o),this.emitter_=new _,this.controller_.valueController.value.emitter.on("change",c=>{this.emitter_.emit("change",{event:new a(this,c.rawValue)})})}get label(){return this.controller_.props.get("label")}set label(o){this.controller_.props.set("label",o)}get formatter(){return this.controller_.valueController.props.get("formatter")}set formatter(o){this.controller_.valueController.props.set("formatter",o)}get value(){return this.controller_.valueController.value.rawValue}set value(o){this.controller_.valueController.value.rawValue=o}on(o,c){const g=c.bind(this);return this.emitter_.on(o,S=>{g(S.event)}),this}}const tv=function(){return{id:"list",type:"blade",accept(d){const o=ct,c=ft(d,{options:o.required.custom(no),value:o.required.raw,view:o.required.constant("list"),label:o.optional.string});return c?{params:c}:null},controller(d){const o=new qs(d.document,{props:j.fromObject({options:nu(d.params.options)}),value:B(d.params.value),viewProps:d.viewProps});return new Rt(d.document,{blade:d.blade,props:j.fromObject({label:d.params.label}),valueController:o})},api(d){return!(d.controller instanceof Rt)||!(d.controller.valueController instanceof qs)?null:new zu(d.controller)}}}();function ev(d){return d.reduce((o,c)=>Object.assign(o,{[c.presetKey]:c.read()}),{})}function nv(d,o){d.forEach(c=>{const g=o[c.presetKey];g!==void 0&&c.write(g)})}class iv extends Gi{constructor(o,c){super(o,c)}get element(){return this.controller_.view.element}importPreset(o){const c=this.controller_.rackController.rack.find(be).map(g=>g.binding.target);nv(c,o),this.refresh()}exportPreset(){const o=this.controller_.rackController.rack.find(be).map(c=>c.binding.target);return ev(o)}refresh(){this.controller_.rackController.rack.find(be).forEach(o=>{o.binding.read()}),this.controller_.rackController.rack.find(an).forEach(o=>{o.binding.read()})}}class sv extends Lt{constructor(o,c){super(o,{expanded:c.expanded,blade:c.blade,props:c.props,root:!0,viewProps:c.viewProps})}}const rv={id:"slider",type:"blade",accept(d){const o=ct,c=ft(d,{max:o.required.number,min:o.required.number,view:o.required.constant("slider"),format:o.optional.function,label:o.optional.string,value:o.optional.number});return c?{params:c}:null},controller(d){var o,c;const g=(o=d.params.value)!==null&&o!==void 0?o:0,S=new Ca(d.document,{baseStep:1,parser:Tn,sliderProps:j.fromObject({maxValue:d.params.max,minValue:d.params.min}),textProps:j.fromObject({draggingScale:Xi(void 0,g),formatter:(c=d.params.format)!==null&&c!==void 0?c:jf}),value:B(g),viewProps:d.viewProps});return new Rt(d.document,{blade:d.blade,props:j.fromObject({label:d.params.label}),valueController:S})},api(d){return!(d.controller instanceof Rt)||!(d.controller.valueController instanceof Ca)?null:new Uu(d.controller)}},ov=function(){return{id:"text",type:"blade",accept(d){const o=ct,c=ft(d,{parse:o.required.function,value:o.required.raw,view:o.required.constant("text"),format:o.optional.function,label:o.optional.string});return c?{params:c}:null},controller(d){var o;const c=new to(d.document,{parser:d.params.parse,props:j.fromObject({formatter:(o=d.params.format)!==null&&o!==void 0?o:g=>String(g)}),value:B(d.params.value),viewProps:d.viewProps});return new Rt(d.document,{blade:d.blade,props:j.fromObject({label:d.params.label}),valueController:c})},api(d){return!(d.controller instanceof Rt)||!(d.controller.valueController instanceof to)?null:new Hu(d.controller)}}}();function av(d){const o=d.createElement("div");return o.classList.add(M("dfw")()),d.body&&d.body.appendChild(o),o}function Gu(d,o,c){if(d.querySelector(`style[data-tp-style=${o}]`))return;const g=d.createElement("style");g.dataset.tpStyle=o,g.textContent=c,d.head.appendChild(g)}class lv extends iv{constructor(o){var c,g;const S=o!=null?o:{},k=(c=S.document)!==null&&c!==void 0?c:At(),X=Qg(),st=new sv(k,{expanded:S.expanded,blade:St(),props:j.fromObject({title:S.title}),viewProps:cn.create()});super(st,X),this.pool_=X,this.containerElem_=(g=S.container)!==null&&g!==void 0?g:av(k),this.containerElem_.appendChild(this.element),this.doc_=k,this.usesDefaultWrapper_=!S.container,this.setUpDefaultPlugins_()}get document(){if(!this.doc_)throw x.alreadyDisposed();return this.doc_}dispose(){const o=this.containerElem_;if(!o)throw x.alreadyDisposed();if(this.usesDefaultWrapper_){const c=o.parentElement;c&&c.removeChild(o)}this.containerElem_=null,this.doc_=null,super.dispose()}registerPlugin(o){("plugin"in o?[o.plugin]:"plugins"in o?o.plugins:[]).forEach(g=>{this.pool_.register(g),this.embedPluginStyle_(g)})}embedPluginStyle_(o){o.css&&Gu(this.document,`plugin-${o.id}`,o.css)}setUpDefaultPlugins_(){Gu(this.document,"default",'.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor transparent;scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:transparent}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:transparent solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #28292e);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #28292e);--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i,.tp-fldv_c>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'),this.pool_.getAll().forEach(o=>{this.embedPluginStyle_(o)}),this.registerPlugin({plugins:[rv,tv,zc,ov]})}}const cv=new n("3.1.0");e.BladeApi=i,e.ButtonApi=w,e.FolderApi=Gi,e.InputBindingApi=Vi,e.ListApi=zu,e.MonitorBindingApi=zi,e.Pane=lv,e.SeparatorApi=Zt,e.SliderApi=Uu,e.TabApi=Bc,e.TabPageApi=kc,e.TextApi=Hu,e.TpChangeEvent=a,e.VERSION=cv,Object.defineProperty(e,"__esModule",{value:!0})})})(nc,nc.exports);var ic={d:(r,t)=>{for(var e in t)ic.o(t,e)&&!ic.o(r,e)&&Object.defineProperty(r,e,{enumerable:!0,get:t[e]})},o:(r,t)=>Object.prototype.hasOwnProperty.call(r,t)},Qp={};ic.d(Qp,{Q:()=>fS});var kl=function(r,t,e,n){return new(e||(e=Promise))(function(i,s){function a(h){try{u(n.next(h))}catch(p){s(p)}}function l(h){try{u(n.throw(h))}catch(p){s(p)}}function u(h){var p;h.done?i(h.value):(p=h.value,p instanceof e?p:new e(function(f){f(p)})).then(a,l)}u((n=n.apply(r,t||[])).next())})};const tf=Symbol("Comlink.proxy"),hS=Symbol("Comlink.endpoint"),dS=Symbol("Comlink.releaseProxy"),sc=Symbol("Comlink.thrown"),kd=r=>typeof r=="object"&&r!==null||typeof r=="function",ef=new Map([["proxy",{canHandle:r=>kd(r)&&r[tf],serialize(r){const{port1:t,port2:e}=new MessageChannel;return nf(r,t),[e,[e]]},deserialize:r=>(r.start(),rf(r))}],["throw",{canHandle:r=>kd(r)&&sc in r,serialize({value:r}){let t;return t=r instanceof Error?{isError:!0,value:{message:r.message,name:r.name,stack:r.stack}}:{isError:!1,value:r},[t,[]]},deserialize(r){throw r.isError?Object.assign(new Error(r.value.message),r.value):r.value}}]]);function nf(r,t=self){t.addEventListener("message",function e(n){if(!n||!n.data)return;const{id:i,type:s,path:a}=Object.assign({path:[]},n.data),l=(n.data.argumentList||[]).map(Ci);let u;try{const h=a.slice(0,-1).reduce((f,m)=>f[m],r),p=a.reduce((f,m)=>f[m],r);switch(s){case"GET":u=p;break;case"SET":h[a.slice(-1)[0]]=Ci(n.data.value),u=!0;break;case"APPLY":u=p.apply(h,l);break;case"CONSTRUCT":u=na(new p(...l));break;case"ENDPOINT":{const{port1:f,port2:m}=new MessageChannel;nf(r,m),u=function(v,x){return of.set(v,x),v}(f,[f])}break;case"RELEASE":u=void 0;break;default:return}}catch(h){u={value:h,[sc]:0}}Promise.resolve(u).catch(h=>({value:h,[sc]:0})).then(h=>{const[p,f]=Nc(h);t.postMessage(Object.assign(Object.assign({},p),{id:i}),f),s==="RELEASE"&&(t.removeEventListener("message",e),sf(t))})}),t.start&&t.start()}function sf(r){(function(t){return t.constructor.name==="MessagePort"})(r)&&r.close()}function rf(r,t){return rc(r,[],t)}function Jo(r){if(r)throw new Error("Proxy has been released and is not useable")}function rc(r,t=[],e=function(){}){let n=!1;const i=new Proxy(e,{get(s,a){if(Jo(n),a===dS)return()=>ys(r,{type:"RELEASE",path:t.map(l=>l.toString())}).then(()=>{sf(r),n=!0});if(a==="then"){if(t.length===0)return{then:()=>i};const l=ys(r,{type:"GET",path:t.map(u=>u.toString())}).then(Ci);return l.then.bind(l)}return rc(r,[...t,a])},set(s,a,l){Jo(n);const[u,h]=Nc(l);return ys(r,{type:"SET",path:[...t,a].map(p=>p.toString()),value:u},h).then(Ci)},apply(s,a,l){Jo(n);const u=t[t.length-1];if(u===hS)return ys(r,{type:"ENDPOINT"}).then(Ci);if(u==="bind")return rc(r,t.slice(0,-1));const[h,p]=Bd(l);return ys(r,{type:"APPLY",path:t.map(f=>f.toString()),argumentList:h},p).then(Ci)},construct(s,a){Jo(n);const[l,u]=Bd(a);return ys(r,{type:"CONSTRUCT",path:t.map(h=>h.toString()),argumentList:l},u).then(Ci)}});return i}function Bd(r){const t=r.map(Nc);return[t.map(n=>n[0]),(e=t.map(n=>n[1]),Array.prototype.concat.apply([],e))];var e}const of=new WeakMap;function na(r){return Object.assign(r,{[tf]:!0})}function Nc(r){for(const[t,e]of ef)if(e.canHandle(r)){const[n,i]=e.serialize(r);return[{type:"HANDLER",name:t,value:n},i]}return[{type:"RAW",value:r},of.get(r)||[]]}function Ci(r){switch(r.type){case"HANDLER":return ef.get(r.name).deserialize(r.value);case"RAW":return r.value}}function ys(r,t,e){return new Promise(n=>{const i=new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-");r.addEventListener("message",function s(a){a.data&&a.data.id&&a.data.id===i&&(r.removeEventListener("message",s),n(a.data))}),r.start&&r.start(),r.postMessage(Object.assign({id:i},t),e)})}class pS extends class{}{init(t,e,n,i){if(!this.api){if(!i)throw new Error("workerFilePath is required");(()=>{var s,a,l,u;s=this,a=void 0,u=function*(){const h=yield fetch(i).then(m=>m.blob()),p=URL.createObjectURL(h),f=new Worker(p,{type:"module"});this.api=yield new(rf(f))(na(()=>{t(),URL.revokeObjectURL(p)}),na((m,v)=>m==="xatlas_web.wasm"?n:m+v),na(e))},new((l=void 0)||(l=Promise))(function(h,p){function f(x){try{v(u.next(x))}catch(b){p(b)}}function m(x){try{v(u.throw(x))}catch(b){p(b)}}function v(x){var b;x.done?h(x.value):(b=x.value,b instanceof l?b:new l(function(w){w(b)})).then(f,m)}v((u=u.apply(s,a||[])).next())})})()}}}class fS extends class{constructor(t,e={resolution:2048},n={},i=!1,s=!1,a=!1){this.THREE=t,this.packOptions=e,this.chartOptions=n,this.useNormals=i,this.timeUnwrap=s,this.logProgress=a,this._libraryLoaded=!1,this._isUnwrapping=!1,this.xAtlas=this._createXAtlas()}loadLibrary(t,e,n){return kl(this,void 0,void 0,function*(){if(!this._libraryLoaded){for(yield new Promise((i,s)=>{try{this.xAtlas.init(()=>{i()},t,e,n)}catch(a){s(a)}});!this.xAtlas.api||!(yield this.xAtlas.api.loaded);)yield new Promise(i=>setTimeout(i,100));this._libraryLoaded=!0}})}packAtlas(t,e="uv2",n="uv"){return kl(this,void 0,void 0,function*(){if(!this._libraryLoaded)return console.warn("xatlas-three: library not loaded"),[];if(!t)return[];if(t.length<1)return[];const i=this.chartOptions.useInputMeshUvs;for(;this._isUnwrapping;)console.log("xatlas-three: unwrapping another mesh, waiting 100 ms"),yield new Promise(h=>setTimeout(h,100));this._isUnwrapping=!0,yield this.xAtlas.api.setProgressLogging(this.logProgress),yield this.xAtlas.api.createAtlas();let s=[],a="";for(let h of t){let{uuid:p,index:f,attributes:m}=h;const v=h.userData.worldScale||1;s.push(p),f&&m.position&&m.position.itemSize===3?(a="Mesh"+s.length+" added to atlas: "+p,this.timeUnwrap&&console.time(a),yield this.xAtlas.api.addMesh(f.array,m.position.array,m.normal?m.normal.array:void 0,m.uv?m.uv.array:void 0,p,this.useNormals,i,v),this.timeUnwrap&&console.timeEnd(a)):console.warn("xatlas-three: Geometry not supported: ",h)}a="Generated atlas with "+s.length+" meshes",this.timeUnwrap&&console.time(a);let l=yield this.xAtlas.api.generateAtlas(this.chartOptions,this.packOptions,!0);this.timeUnwrap&&console.timeEnd(a);let u=[];for(let h of l){let p=t.find(f=>f.uuid===h.mesh);p?(h.vertex.vertices&&p.setAttribute("position",new this.THREE.BufferAttribute(h.vertex.vertices,3,!1)),h.vertex.normals&&p.setAttribute("normal",new this.THREE.BufferAttribute(h.vertex.normals,3,!0)),h.vertex.coords1&&p.setAttribute(e,new this.THREE.BufferAttribute(h.vertex.coords1,2,!1)),h.vertex.coords&&e!==n&&p.setAttribute(n,new this.THREE.BufferAttribute(h.vertex.coords,2,!1)),h.index&&p.setIndex(new this.THREE.BufferAttribute(h.index,1,!1)),u.push(p)):console.error("xatlas-three: Mesh not found: ",h.mesh)}return yield this.xAtlas.api.destroyAtlas(),this._isUnwrapping=!1,u})}unwrapGeometry(t,e="uv",n="uv2"){return kl(this,void 0,void 0,function*(){return this.packAtlas([t],e,n)})}}{_createXAtlas(){return new pS}}var mS=Qp.Q;const af=new mS({BufferAttribute:ae});var lf=(r=>(r[r.AddMesh=0]="AddMesh",r[r.ComputeCharts=1]="ComputeCharts",r[r.PackCharts=2]="PackCharts",r[r.BuildOutputMeshes=3]="BuildOutputMeshes",r))(lf||{});const gS=async()=>{const r=(t,e)=>{console.log(`\u{1F5FA}\uFE0F XAtlas ${lf[t]} ${e}%`)};await af.loadLibrary(r,"https://cdn.jsdelivr.net/npm/xatlasjs@0.1.0/dist/xatlas.wasm","https://cdn.jsdelivr.net/npm/xatlasjs@0.1.0/dist/xatlas.js"),console.log("Loaded")},vS=async r=>{const t=r.map(e=>e.geometry);await af.packAtlas(t,"uv2","uv")},_S=`
    uniform vec2 offset;
    attribute vec2 uv2;
    centroid varying vec4 vWorldPosition; 
    varying vec3 vNormal;


    void main() {
        vWorldPosition = modelMatrix * vec4(position, 1.0) ;

        gl_Position = vec4((uv2 + offset) * 2.0 - 1.0, 0.0, 1.0); 
    }
`,xS=`
    varying vec4 vWorldPosition; 
    varying vec3 vNormal;

    void main() {
        gl_FragColor = vWorldPosition;
    }
`,yS=new yn({vertexShader:_S,fragmentShader:xS,side:on,fog:!1,uniforms:{offset:new $r(new nt(0,0))}}),bS=`
    varying vec4 vNormal;
    attribute vec2 uv2;
    uniform vec2 offset;

    void main() {
        vNormal = normalize(modelMatrix * vec4(normal, 0.0));

        gl_Position = vec4((uv2 + offset) * 2.0 - 1.0, 0.0, 1.0);
    }
`,wS=`
    varying vec4 vWorldPosition; 
    varying vec4 vNormal;

    void main() {
        gl_FragColor = normalize(vNormal);//vec4(0.0, 0.0, 1.0, 1.0);
    }
`,MS=new yn({vertexShader:bS,fragmentShader:wS,side:on,fog:!1,uniforms:{offset:new $r(new nt(0,0))}}),ES=[{x:-2,y:-2},{x:2,y:-2},{x:-2,y:2},{x:2,y:2},{x:-1,y:-2},{x:1,y:-2},{x:-2,y:-1},{x:2,y:-1},{x:-2,y:1},{x:2,y:1},{x:-1,y:2},{x:1,y:2},{x:-2,y:0},{x:2,y:0},{x:0,y:-2},{x:0,y:2},{x:-1,y:-1},{x:1,y:-1},{x:-1,y:0},{x:1,y:0},{x:-1,y:1},{x:1,y:1},{x:0,y:-1},{x:0,y:1},{x:0,y:0}],SS=(r,t,e,n=!0)=>{const i=l=>{const u=new rn(e,e,{type:Ne,magFilter:oe,minFilter:oe}),h=new Kr(-100,100,-100,100,-100,200);h.updateMatrix();const p=new Wt;for(const f of t){const m=f.clone();m.material=l,p.add(m)}if(r.autoClear=!1,r.setRenderTarget(u),r.setClearColor(0,0),r.clear(),n)for(const f of ES)l.uniforms.offset.value.x=f.x*(1/e),l.uniforms.offset.value.y=f.y*(1/e),r.render(p,h);return l.uniforms.offset.value.x=0,l.uniforms.offset.value.y=0,r.render(p,h),r.setRenderTarget(null),u},s=i(yS),a=i(MS);return{positionTexture:s,normalTexture:a}};class TS extends yn{constructor(t){const e=new tS;e.updateFrom(t.bvh),super({transparent:!0,uniforms:{bvh:{value:e},positions:{value:t.positions},normals:{value:t.normals},invModelMatrix:{value:t.invModelMatrix},casts:{value:t.casts},lightPosition:{value:t.lightPosition},lightSize:{value:t.lightSize},opacity:{value:1},sampleIndex:{value:0},directLightEnabled:{value:t.directLightEnabled},indirectLightEnabled:{value:t.indirectLightEnabled},ambientLightEnabled:{value:t.ambientLightEnabled},ambientDistance:{value:t.ambientDistance}},vertexShader:`
                varying vec2 vUv;
                void main() {
                    gl_Position = vec4( position, 1.0 );
                    vUv = uv;
                }
            `,fragmentShader:`
                precision highp isampler2D;
                precision highp usampler2D;
                ${eS}
                ${nS}
                
                uniform mat4 invModelMatrix;
                uniform sampler2D positions;
                uniform sampler2D normals;
                uniform int casts;
                
                uniform vec3 lightPosition;
                uniform float lightSize;
                uniform int sampleIndex;
        
                uniform bool directLightEnabled;
                uniform bool indirectLightEnabled;
                uniform bool ambientLightEnabled;
                uniform float ambientDistance;
                uniform float opacity;
        
                uniform BVH bvh;
                varying vec2 vUv;
        
                uvec4 s0;
                void rng_initialize(vec2 p, int frame) {
                    // white noise seed
                    s0 = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );
                }
        
                void pcg4d( inout uvec4 v ) {
                    v = v * 1664525u + 1013904223u;
                    v.x += v.y * v.w;
                    v.y += v.z * v.x;
                    v.z += v.x * v.y;
                    v.w += v.y * v.z;
                    v = v ^ ( v >> 16u );
                    v.x += v.y*v.w;
                    v.y += v.z*v.x;
                    v.z += v.x*v.y;
                    v.w += v.y*v.z;
                }
                
                float rand() {
                    pcg4d(s0);
                    return float( s0.x ) / float( 0xffffffffu );
                }
                vec2 rand2() {
                    pcg4d( s0 );
                    return vec2( s0.xy ) / float(0xffffffffu);
                }
                vec3 rand3() {
                    pcg4d(s0);
                    return vec3( s0.xyz ) / float( 0xffffffffu );
                }
                vec4 rand4() {
                    pcg4d(s0);
                    return vec4(s0)/float(0xffffffffu);
                }
        
                vec3 randomSpherePoint(vec3 rand) {
                    float ang1 = (rand.x + 1.0) * 3.1415; // [-1..1) -> [0..2*PI)
                    float u = rand.y; // [-1..1), cos and acos(2v-1) cancel each other out, so we arrive at [-1..1)
                    float u2 = u * u;
                    float sqrt1MinusU2 = sqrt(1.0 - u2);
                    float x = sqrt1MinusU2 * cos(ang1);
                    float y = sqrt1MinusU2 * sin(ang1);
                    float z = u;
                    return vec3(x, y, z);
                  }
        
                  vec3 getHemisphereSample( vec3 n, vec2 uv ) {
                    // https://www.rorydriscoll.com/2009/01/07/better-sampling/
                    // https://graphics.pixar.com/library/OrthonormalB/paper.pdf
                    float sign = n.z == 0.0 ? 1.0 : sign( n.z );
                    float a = - 1.0 / ( sign + n.z );
                    float b = n.x * n.y * a;
                    vec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );
                    vec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );
                    float r = sqrt( uv.x );
                    float theta = 2.0 * 3.1415 * uv.y;
                    float x = r * cos( theta );
                    float y = r * sin( theta );
                    return x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;
                }
        
                void main() {
                    vec4 position = texture2D(positions, vUv);
                    vec4 normal = texture2D(normals, vUv);
                    
                    rng_initialize( gl_FragCoord.xy, sampleIndex );
                    
                    vec3 rayOrigin = vec3(position.r, position.g, position.b);
                    vec3 rayDirection = vec3(normal.r, normal.g, normal.b);
        
                    rayOrigin += rayDirection * 0.001;
                    
                    uvec4 faceIndices = uvec4( 0u );
                    vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );
                    vec3 barycoord = vec3( 0.0 );
                    float side = 1.0;
                    float dist = 0.0;
        
                    vec3 totalIndirectLight = vec3(0.0);
                    vec3 totalAO = vec3(0.0);
                    vec3 totalDirectLight = vec3(0.0);
                    
                    if(ambientLightEnabled || indirectLightEnabled) {
                        for ( int i = 0; i < casts; i++ ) {
                            vec3 newDirection = getHemisphereSample(normal.xyz, rand4().xy);
                            
                            if(dot(rayDirection, newDirection) > 0.0) {
                                bool hit = bvhIntersectFirstHit( bvh, rayOrigin, newDirection, faceIndices, faceNormal, barycoord, side, dist );
        
                                if(!hit) {
                                    totalIndirectLight.r += 1.0;
                                    totalIndirectLight.g += 1.0;
                                    totalIndirectLight.b += 1.0;
                                }
        
                                if(!hit || dist > ambientDistance) {
                                    totalAO.r += 1.0;
                                    totalAO.g += 1.0;
                                    totalAO.b += 1.0;
                                }
                            }
                        }
                    }
                    
                    if(directLightEnabled) {
                        for ( int i = 0; i < casts; i++ ) {
                            vec3 newDirection = lightPosition - (rayOrigin + randomSpherePoint(rand3() * 0.05) * lightSize);
                            
                            newDirection = normalize(newDirection);
                            bool hit = bvhIntersectFirstHit( bvh, rayOrigin, newDirection, faceIndices, faceNormal, barycoord, side, dist );
                            
                            if(!hit) {
                                totalDirectLight.r += 1.0;
                                totalDirectLight.g += 1.0;
                                totalDirectLight.b += 1.0;
                            }
                        }
                    }
                    
                    vec4 adverageDirectLight = vec4(totalDirectLight / float(casts), 1.0);
                    vec4 adverageAO = vec4(totalAO / float(casts), 1.0);
                    vec4 adverageIndirectLight = vec4(totalIndirectLight / float(casts), 1.0);
        
                    float multiplier = directLightEnabled && indirectLightEnabled ? 0.5 : 1.0;
        
                    vec4 finalColor = vec4(0.0);
        
                    if(directLightEnabled) {
                        finalColor += adverageDirectLight * multiplier;
                    }
        
                    if(indirectLightEnabled) {
                        finalColor += adverageIndirectLight * multiplier;
                    }
        
                    if(ambientLightEnabled) {
                        if(!directLightEnabled && !indirectLightEnabled) {
                            finalColor = adverageAO;
                        } else {
                            finalColor *= adverageAO;
                        }
                    }
                    
                    finalColor.a = opacity;
        
                    gl_FragColor = finalColor;
                }
            `})}}const AS=(r,t,e,n,i)=>{const s=new TS({bvh:n,invModelMatrix:new Et().identity(),positions:t,normals:e,casts:i.casts,lightPosition:i.lightPosition,lightSize:i.lightSize,opacity:1,sampleIndex:0,directLightEnabled:i.directLightEnabled,indirectLightEnabled:i.indirectLightEnabled,ambientLightEnabled:i.ambientLightEnabled,ambientDistance:i.ambientDistance}),a=new rn(i.resolution,i.resolution,{type:Ne,minFilter:zv,magFilter:Re,generateMipmaps:!0});r.setRenderTarget(a),r.setClearColor(16711680,0),r.clear();const l=new wt(new mn(2,2),s),u=new Kr(-1,1,1,-1,0,1);let h=0;const p=()=>(r.setRenderTarget(a),s.uniforms.sampleIndex.value=h,s.uniforms.opacity.value=h==0?1:1/h,r.render(l,u),r.setRenderTarget(null),h++,h);return r.setRenderTarget(null),{renderTexture:a,render:p}};class CS{static computeTangents(t){t.computeTangents(),console.warn("THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.")}static mergeBufferGeometries(t,e=!1){const n=t[0].index!==null,i=new Set(Object.keys(t[0].attributes)),s=new Set(Object.keys(t[0].morphAttributes)),a={},l={},u=t[0].morphTargetsRelative,h=new Yt;let p=0;for(let f=0;f<t.length;++f){const m=t[f];let v=0;if(n!==(m.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const x in m.attributes){if(!i.has(x))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+'. All geometries must have compatible attributes; make sure "'+x+'" attribute exists among all geometries, or in none of them.'),null;a[x]===void 0&&(a[x]=[]),a[x].push(m.attributes[x]),v++}if(v!==i.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". Make sure all geometries have the same number of attributes."),null;if(u!==m.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const x in m.morphAttributes){if(!s.has(x))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+".  .morphAttributes must be consistent throughout all geometries."),null;l[x]===void 0&&(l[x]=[]),l[x].push(m.morphAttributes[x])}if(h.userData.mergedUserData=h.userData.mergedUserData||[],h.userData.mergedUserData.push(m.userData),e){let x;if(n)x=m.index.count;else if(m.attributes.position!==void 0)x=m.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". The geometry must have either an index or a position attribute"),null;h.addGroup(p,x,f),p+=x}}if(n){let f=0;const m=[];for(let v=0;v<t.length;++v){const x=t[v].index;for(let b=0;b<x.count;++b)m.push(x.getX(b)+f);f+=t[v].attributes.position.count}h.setIndex(m)}for(const f in a){const m=this.mergeBufferAttributes(a[f]);if(!m)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+f+" attribute."),null;h.setAttribute(f,m)}for(const f in l){const m=l[f][0].length;if(m===0)break;h.morphAttributes=h.morphAttributes||{},h.morphAttributes[f]=[];for(let v=0;v<m;++v){const x=[];for(let w=0;w<l[f].length;++w)x.push(l[f][w][v]);const b=this.mergeBufferAttributes(x);if(!b)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+f+" morphAttribute."),null;h.morphAttributes[f].push(b)}}return h}static mergeBufferAttributes(t){let e,n,i,s=0;for(let u=0;u<t.length;++u){const h=t[u];if(h.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(e===void 0&&(e=h.array.constructor),e!==h.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(n===void 0&&(n=h.itemSize),n!==h.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(i===void 0&&(i=h.normalized),i!==h.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;s+=h.array.length}const a=new e(s);let l=0;for(let u=0;u<t.length;++u)a.set(t[u].array,l),l+=t[u].array.length;return new ae(a,n,i)}static interleaveAttributes(t){let e,n=0,i=0;for(let p=0,f=t.length;p<f;++p){const m=t[p];if(e===void 0&&(e=m.array.constructor),e!==m.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;n+=m.array.length,i+=m.itemSize}const s=new ki(new e(n),i);let a=0;const l=[],u=["getX","getY","getZ","getW"],h=["setX","setY","setZ","setW"];for(let p=0,f=t.length;p<f;p++){const m=t[p],v=m.itemSize,x=m.count,b=new Ii(s,v,a,m.normalized);l.push(b),a+=v;for(let w=0;w<x;w++)for(let _=0;_<v;_++)b[h[_]](w,m[u[_]](w))}return l}static estimateBytesUsed(t){let e=0;for(const i in t.attributes){const s=t.getAttribute(i);e+=s.count*s.itemSize*s.array.BYTES_PER_ELEMENT}const n=t.getIndex();return e+=n?n.count*n.itemSize*n.array.BYTES_PER_ELEMENT:0,e}static mergeVertices(t,e=1e-4){e=Math.max(e,Number.EPSILON);const n={},i=t.getIndex(),s=t.getAttribute("position"),a=i?i.count:s.count;let l=0;const u=Object.keys(t.attributes),h={},p={},f=[],m=["getX","getY","getZ","getW"];for(let w=0,_=u.length;w<_;w++){const y=u[w];h[y]=[];const M=t.morphAttributes[y];M&&(p[y]=new Array(M.length).fill().map(()=>[]))}const v=Math.log10(1/e),x=Math.pow(10,v);for(let w=0;w<a;w++){const _=i?i.getX(w):w;let y="";for(let M=0,T=u.length;M<T;M++){const A=u[M],E=t.getAttribute(A),P=E.itemSize;for(let I=0;I<P;I++)y+=`${~~(E[m[I]](_)*x)},`}if(y in n)f.push(n[y]);else{for(let M=0,T=u.length;M<T;M++){const A=u[M],E=t.getAttribute(A),P=t.morphAttributes[A],I=E.itemSize,N=h[A],z=p[A];for(let W=0;W<I;W++){const H=m[W];if(N.push(E[H](_)),P)for(let D=0,V=P.length;D<V;D++)z[D].push(P[D][H](_))}}n[y]=l,f.push(l),l++}}const b=t.clone();for(let w=0,_=u.length;w<_;w++){const y=u[w],M=t.getAttribute(y),T=new M.array.constructor(h[y]),A=new ae(T,M.itemSize,M.normalized);if(b.setAttribute(y,A),y in p)for(let E=0;E<p[y].length;E++){const P=t.morphAttributes[y][E],I=new P.array.constructor(p[y][E]),N=new ae(I,P.itemSize,P.normalized);b.morphAttributes[y][E]=N}}return b.setIndex(f),b}static toTrianglesDrawMode(t,e){if(e===Kd)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(e===aa||e===$d){let n=t.getIndex();if(n===null){const l=[],u=t.getAttribute("position");if(u!==void 0){for(let h=0;h<u.count;h++)l.push(h);t.setIndex(l),n=t.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t}const i=n.count-2,s=[];if(e===aa)for(let l=1;l<=i;l++)s.push(n.getX(0)),s.push(n.getX(l)),s.push(n.getX(l+1));else for(let l=0;l<i;l++)l%2===0?(s.push(n.getX(l)),s.push(n.getX(l+1)),s.push(n.getX(l+2))):(s.push(n.getX(l+2)),s.push(n.getX(l+1)),s.push(n.getX(l)));s.length/3!==i&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const a=t.clone();return a.setIndex(s),a.clearGroups(),a}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),t}static computeMorphedAttributes(t){if(t.geometry.isBufferGeometry!==!0)return console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."),null;const e=new C,n=new C,i=new C,s=new C,a=new C,l=new C,u=new C,h=new C,p=new C;function f(rt,Tt,ct,ft,Ft,K,Ot,Dt,Mt){e.fromBufferAttribute(ct,K),n.fromBufferAttribute(ct,Ot),i.fromBufferAttribute(ct,Dt);const bt=rt.morphTargetInfluences;if(Tt.morphTargets&&ft&&bt){u.set(0,0,0),h.set(0,0,0),p.set(0,0,0);for(let Nt=0,tt=ft.length;Nt<tt;Nt++){const et=bt[Nt],lt=ft[Nt];et!==0&&(s.fromBufferAttribute(lt,K),a.fromBufferAttribute(lt,Ot),l.fromBufferAttribute(lt,Dt),Ft?(u.addScaledVector(s,et),h.addScaledVector(a,et),p.addScaledVector(l,et)):(u.addScaledVector(s.sub(e),et),h.addScaledVector(a.sub(n),et),p.addScaledVector(l.sub(i),et)))}e.add(u),n.add(h),i.add(p)}rt.isSkinnedMesh&&(rt.boneTransform(K,e),rt.boneTransform(Ot,n),rt.boneTransform(Dt,i)),Mt[K*3+0]=e.x,Mt[K*3+1]=e.y,Mt[K*3+2]=e.z,Mt[Ot*3+0]=n.x,Mt[Ot*3+1]=n.y,Mt[Ot*3+2]=n.z,Mt[Dt*3+0]=i.x,Mt[Dt*3+1]=i.y,Mt[Dt*3+2]=i.z}const m=t.geometry,v=t.material;let x,b,w;const _=m.index,y=m.attributes.position,M=m.morphAttributes.position,T=m.morphTargetsRelative,A=m.attributes.normal,E=m.morphAttributes.position,P=m.groups,I=m.drawRange;let N,z,W,H,D,V,G,B;const j=new Float32Array(y.count*y.itemSize),ot=new Float32Array(A.count*A.itemSize);if(_!==null)if(Array.isArray(v))for(N=0,W=P.length;N<W;N++)for(D=P[N],V=v[D.materialIndex],G=Math.max(D.start,I.start),B=Math.min(D.start+D.count,I.start+I.count),z=G,H=B;z<H;z+=3)x=_.getX(z),b=_.getX(z+1),w=_.getX(z+2),f(t,V,y,M,T,x,b,w,j),f(t,V,A,E,T,x,b,w,ot);else for(G=Math.max(0,I.start),B=Math.min(_.count,I.start+I.count),N=G,W=B;N<W;N+=3)x=_.getX(N),b=_.getX(N+1),w=_.getX(N+2),f(t,v,y,M,T,x,b,w,j),f(t,v,A,E,T,x,b,w,ot);else if(y!==void 0)if(Array.isArray(v))for(N=0,W=P.length;N<W;N++)for(D=P[N],V=v[D.materialIndex],G=Math.max(D.start,I.start),B=Math.min(D.start+D.count,I.start+I.count),z=G,H=B;z<H;z+=3)x=z,b=z+1,w=z+2,f(t,V,y,M,T,x,b,w,j),f(t,V,A,E,T,x,b,w,ot);else for(G=Math.max(0,I.start),B=Math.min(y.count,I.start+I.count),N=G,W=B;N<W;N+=3)x=N,b=N+1,w=N+2,f(t,v,y,M,T,x,b,w,j),f(t,v,A,E,T,x,b,w,ot);const Q=new qt(j,3),ut=new qt(ot,3);return{positionAttribute:y,normalAttribute:A,morphedPositionAttribute:Q,morphedNormalAttribute:ut}}}const PS=r=>CS.mergeBufferGeometries(r.map(t=>{const e=new wt(t.geometry.clone(),t.material);return e.geometry.deleteAttribute("color"),e.geometry.applyMatrix4(t.matrixWorld),e.geometry})),LS={["level_blockout.glb"]:"level_blockout.glb"},RS={Standard:"standard",Positions:"positions",Normals:"normals","UV2 Debug":"uv",Lightmap:"lightmap",Beauty:"beauty"},IS={LinearFilter:"linear",Nearest:"nearest"};class DS{constructor(t){this.currentModelMeshs=[],this.options={model:"level_blockout",renderMode:"beauty",lightMapSize:1024,casts:1,filterMode:"linear",directLightEnabled:!0,indirectLightEnabled:!0,ambientLightEnabled:!0,ambientDistance:.3,debugTextures:!1,pause:!1},this.uvDebugTexture=t,this.scene=new mc,this.scene.background=new yt(7649791),this.camera=new De(75,window.innerWidth/window.innerHeight,.1,1e3),this.camera.position.set(0,10,10),this.renderer=new ie({antialias:!0}),this.renderer.outputEncoding=Br,this.renderer.setSize(window.innerWidth,window.innerHeight),document.body.appendChild(this.renderer.domElement),this.controls=new iS(this.camera,this.renderer.domElement),this.directionalLight=new Pc(16777215,1),this.lightDummy=new Wt,this.lightDummy.position.set(15,30,8),this.lightTranformController=new Kp(this.camera,this.renderer.domElement),this.lightTranformController.addEventListener("dragging-changed",e=>{this.controls.enabled=!e.value}),this.lightTranformController.attach(this.lightDummy),this.scene.add(this.lightDummy),this.scene.add(this.lightTranformController),this.pane=new nc.exports.Pane,this.pane.addInput(this.options,"model",{options:LS}).on("change",()=>this.onMapChange()),this.pane.addInput(this.options,"renderMode",{options:RS}).on("change",()=>this.onRenderModeChange()),this.pane.addInput(this.options,"lightMapSize",{max:4096,min:128,step:128}),this.pane.addInput(this.options,"casts",{max:4,min:1,step:1}),this.pane.addInput(this.options,"directLightEnabled"),this.pane.addInput(this.options,"indirectLightEnabled"),this.pane.addInput(this.options,"ambientLightEnabled"),this.pane.addInput(this.options,"ambientDistance",{max:2,min:.01}),this.pane.addInput(this.options,"debugTextures").on("change",()=>this.onRenderModeChange()),this.pane.addInput(this.options,"filterMode",{options:IS}).on("change",()=>this.onRenderModeChange()),this.pane.addButton({title:"Reset"}).on("click",()=>{this.options.pause=!1,this.pane.refresh(),this.generateLightmap(),setTimeout(()=>{this.lightmapper.render()},0)}),this.pane.addInput(this.options,"pause"),this.initialSetup()}updateSize(){this.renderer.setSize(window.innerWidth,window.innerHeight),this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix()}async initialSetup(){await this.onMapChange()}async onMapChange(){this.currentModel&&this.scene.remove(this.currentModel),this.camera.position.set(0,10,10),this.currentModelMeshs=[],this.lightmapper=null;const t=await wE(this.options.model);t.scene.traverse(e=>{e.isMesh&&(e.material._originalMap=e.material.map,this.currentModelMeshs.push(e))}),this.currentModel=t.scene,this.scene.add(t.scene),await this.updateAtlasTextures(),this.update(),await this.generateLightmap(),this.lightmapper.render()}async updateAtlasTextures(){await vS(this.currentModelMeshs)}async generateLightmap(){const t=this.options.lightMapSize,e=SS(this.renderer,this.currentModelMeshs,t,!0);this.positionTexture=e.positionTexture,this.normalTexture=e.normalTexture,this.update();const n=PS(this.currentModelMeshs),i=new Ir(n),s={resolution:t,casts:this.options.casts,filterMode:this.options.filterMode=="linear"?Re:oe,lightPosition:this.lightDummy.position,lightSize:3,ambientDistance:this.options.ambientDistance,ambientLightEnabled:this.options.ambientLightEnabled,directLightEnabled:this.options.directLightEnabled,indirectLightEnabled:this.options.indirectLightEnabled};this.lightmapper=await AS(this.renderer,e.positionTexture.texture,e.normalTexture.texture,i,s),this.lightmapTexture=this.lightmapper.renderTexture,this.onRenderModeChange(),setTimeout(()=>{this.options.pause=!0,this.pane.refresh()},2e3)}createDebugTexture(t,e){const n=new wt(new mn(20,20),new sn({map:t,side:on}));return n.position.copy(e),n.scale.set(.5,.5,.5),this.scene.add(n),n}onDebugTexturesChange(){this.debugPosition&&this.scene.remove(this.debugPosition),this.debugNormals&&this.scene.remove(this.debugNormals),this.debugLightmap&&this.scene.remove(this.debugLightmap),this.options.debugTextures&&(this.debugPosition=this.createDebugTexture(this.positionTexture.texture,new C(0,10,0)),this.debugNormals=this.createDebugTexture(this.normalTexture.texture,new C(12,10,0)),this.debugLightmap=this.createDebugTexture(this.lightmapTexture,new C(24,10,0)))}onRenderModeChange(){this.currentModel.traverse(t=>{t.isMesh&&(t.material.map=null,this.options.renderMode=="standard"&&(t.material.lightMap=null,t.material.map=t.material._originalMap),this.options.renderMode=="positions"&&(t.material.lightMap=this.positionTexture),this.options.renderMode=="normals"&&(t.material.lightMap=this.normalTexture),this.options.renderMode=="uv"&&(t.material.lightMap=this.uvDebugTexture),this.options.renderMode=="lightmap"&&(t.material.lightMap=this.lightmapTexture),this.options.renderMode=="beauty"&&(t.material.lightMap=this.lightmapTexture,t.material.map=t.material._originalMap),t.material.lightMap&&(t.material.lightMap.needsUpdate=!0),t.material.lightMapIntensity=1,t.material.needsUpdate=!0)}),this.options.renderMode=="standard"?this.scene.add(this.directionalLight):this.scene.remove(this.directionalLight),this.onDebugTexturesChange()}update(){requestAnimationFrame(()=>this.update()),this.lightmapper&&!this.options.pause&&this.lightmapper.render(),this.controls.update(),this.renderer.render(this.scene,this.camera)}}(async()=>{await gS();const r=await bE("uv_map.jpg"),t=new DS(r);window.addEventListener("resize",()=>{t.updateSize()})})();
